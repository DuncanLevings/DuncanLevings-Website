  /**
   * Represents an object that is both an observable sequence as well as an observer.
   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
   */
  var ReplaySubject = Rx.ReplaySubject = (function (__super__) ***REMOVED***

    function createRemovableDisposable(subject, observer) ***REMOVED***
      return disposableCreate(function () ***REMOVED***
        observer.dispose();
        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
      ***REMOVED***);
    ***REMOVED***

    function subscribe(observer) ***REMOVED***
      var so = new ScheduledObserver(this.scheduler, observer),
        subscription = createRemovableDisposable(this, so);
      checkDisposed.call(this);
      this._trim(this.scheduler.now());
      this.observers.push(so);

      for (var i = 0, len = this.q.length; i < len; i++) ***REMOVED***
        so.onNext(this.q[i].value);
      ***REMOVED***

      if (this.hasError) ***REMOVED***
        so.onError(this.error);
      ***REMOVED*** else if (this.isStopped) ***REMOVED***
        so.onCompleted();
      ***REMOVED***

      so.ensureActive();
      return subscription;
    ***REMOVED***

    inherits(ReplaySubject, __super__);

    /**
     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.
     *  @param ***REMOVED***Number***REMOVED*** [bufferSize] Maximum element count of the replay buffer.
     *  @param ***REMOVED***Number***REMOVED*** [windowSize] Maximum time length of the replay buffer.
     *  @param ***REMOVED***Scheduler***REMOVED*** [scheduler] Scheduler the observers are invoked on.
     */
    function ReplaySubject(bufferSize, windowSize, scheduler) ***REMOVED***
      this.bufferSize = bufferSize == null ? Number.MAX_VALUE : bufferSize;
      this.windowSize = windowSize == null ? Number.MAX_VALUE : windowSize;
      this.scheduler = scheduler || currentThreadScheduler;
      this.q = [];
      this.observers = [];
      this.isStopped = false;
      this.isDisposed = false;
      this.hasError = false;
      this.error = null;
      __super__.call(this, subscribe);
    ***REMOVED***

    addProperties(ReplaySubject.prototype, Observer.prototype, ***REMOVED***
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns ***REMOVED***Boolean***REMOVED*** Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function () ***REMOVED***
        return this.observers.length > 0;
      ***REMOVED***,
      _trim: function (now) ***REMOVED***
        while (this.q.length > this.bufferSize) ***REMOVED***
          this.q.shift();
        ***REMOVED***
        while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) ***REMOVED***
          this.q.shift();
        ***REMOVED***
      ***REMOVED***,
      /**
       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
       * @param ***REMOVED***Mixed***REMOVED*** value The value to send to all observers.
       */
      onNext: function (value) ***REMOVED***
        checkDisposed.call(this);
        if (this.isStopped) ***REMOVED*** return; ***REMOVED***
        var now = this.scheduler.now();
        this.q.push(***REMOVED*** interval: now, value: value ***REMOVED***);
        this._trim(now);

        var o = this.observers.slice(0);
        for (var i = 0, len = o.length; i < len; i++) ***REMOVED***
          var observer = o[i];
          observer.onNext(value);
          observer.ensureActive();
        ***REMOVED***
      ***REMOVED***,
      /**
       * Notifies all subscribed observers about the exception.
       * @param ***REMOVED***Mixed***REMOVED*** error The exception to send to all observers.
       */
      onError: function (error) ***REMOVED***
        checkDisposed.call(this);
        if (this.isStopped) ***REMOVED*** return; ***REMOVED***
        this.isStopped = true;
        this.error = error;
        this.hasError = true;
        var now = this.scheduler.now();
        this._trim(now);
        var o = this.observers.slice(0);
        for (var i = 0, len = o.length; i < len; i++) ***REMOVED***
          var observer = o[i];
          observer.onError(error);
          observer.ensureActive();
        ***REMOVED***
        this.observers = [];
      ***REMOVED***,
      /**
       * Notifies all subscribed observers about the end of the sequence.
       */
      onCompleted: function () ***REMOVED***
        checkDisposed.call(this);
        if (this.isStopped) ***REMOVED*** return; ***REMOVED***
        this.isStopped = true;
        var now = this.scheduler.now();
        this._trim(now);
        var o = this.observers.slice(0);
        for (var i = 0, len = o.length; i < len; i++) ***REMOVED***
          var observer = o[i];
          observer.onCompleted();
          observer.ensureActive();
        ***REMOVED***
        this.observers = [];
      ***REMOVED***,
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function () ***REMOVED***
        this.isDisposed = true;
        this.observers = null;
      ***REMOVED***
    ***REMOVED***);

    return ReplaySubject;
  ***REMOVED***(Observable));
