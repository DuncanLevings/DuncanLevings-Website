  /**
   *  Represents the result of an asynchronous operation.
   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.
   */
  var AsyncSubject = Rx.AsyncSubject = (function (__super__) ***REMOVED***

    function subscribe(observer) ***REMOVED***
      checkDisposed.call(this);

      if (!this.isStopped) ***REMOVED***
        this.observers.push(observer);
        return new InnerSubscription(this, observer);
      ***REMOVED***

      if (this.hasError) ***REMOVED***
        observer.onError(this.error);
      ***REMOVED*** else if (this.hasValue) ***REMOVED***
        observer.onNext(this.value);
        observer.onCompleted();
      ***REMOVED*** else ***REMOVED***
        observer.onCompleted();
      ***REMOVED***

      return disposableEmpty;
    ***REMOVED***

    inherits(AsyncSubject, __super__);

    /**
     * Creates a subject that can only receive one value and that value is cached for all future observations.
     * @constructor
     */
    function AsyncSubject() ***REMOVED***
      __super__.call(this, subscribe);

      this.isDisposed = false;
      this.isStopped = false;
      this.hasValue = false;
      this.observers = [];
      this.hasError = false;
    ***REMOVED***

    addProperties(AsyncSubject.prototype, Observer, ***REMOVED***
      /**
       * Indicates whether the subject has observers subscribed to it.
       * @returns ***REMOVED***Boolean***REMOVED*** Indicates whether the subject has observers subscribed to it.
       */
      hasObservers: function () ***REMOVED***
        checkDisposed.call(this);
        return this.observers.length > 0;
      ***REMOVED***,
      /**
       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).
       */
      onCompleted: function () ***REMOVED***
        var i, len;
        checkDisposed.call(this);
        if (!this.isStopped) ***REMOVED***
          this.isStopped = true;
          var os = this.observers.slice(0), len = os.length;

          if (this.hasValue) ***REMOVED***
            for (i = 0; i < len; i++) ***REMOVED***
              var o = os[i];
              o.onNext(this.value);
              o.onCompleted();
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            for (i = 0; i < len; i++) ***REMOVED***
              os[i].onCompleted();
            ***REMOVED***
          ***REMOVED***

          this.observers.length = 0;
        ***REMOVED***
      ***REMOVED***,
      /**
       * Notifies all subscribed observers about the error.
       * @param ***REMOVED***Mixed***REMOVED*** error The Error to send to all observers.
       */
      onError: function (error) ***REMOVED***
        checkDisposed.call(this);
        if (!this.isStopped) ***REMOVED***
          var os = this.observers.slice(0);
          this.isStopped = true;
          this.hasError = true;
          this.error = error;

          for (var i = 0, len = os.length; i < len; i++) ***REMOVED***
            os[i].onError(error);
          ***REMOVED***

          this.observers.length = 0;
        ***REMOVED***
      ***REMOVED***,
      /**
       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.
       * @param ***REMOVED***Mixed***REMOVED*** value The value to store in the subject.
       */
      onNext: function (value) ***REMOVED***
        checkDisposed.call(this);
        if (this.isStopped) ***REMOVED*** return; ***REMOVED***
        this.value = value;
        this.hasValue = true;
      ***REMOVED***,
      /**
       * Unsubscribe all observers and release resources.
       */
      dispose: function () ***REMOVED***
        this.isDisposed = true;
        this.observers = null;
        this.exception = null;
        this.value = null;
      ***REMOVED***
    ***REMOVED***);

    return AsyncSubject;
  ***REMOVED***(Observable));
