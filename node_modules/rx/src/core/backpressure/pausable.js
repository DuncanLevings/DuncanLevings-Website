  var PausableObservable = (function (__super__) ***REMOVED***

    inherits(PausableObservable, __super__);

    function subscribe(observer) ***REMOVED***
      var conn = this.source.publish(),
        subscription = conn.subscribe(observer),
        connection = disposableEmpty;

      var pausable = this.pauser.distinctUntilChanged().subscribe(function (b) ***REMOVED***
        if (b) ***REMOVED***
          connection = conn.connect();
        ***REMOVED*** else ***REMOVED***
          connection.dispose();
          connection = disposableEmpty;
        ***REMOVED***
      ***REMOVED***);

      return new CompositeDisposable(subscription, connection, pausable);
    ***REMOVED***

    function PausableObservable(source, pauser) ***REMOVED***
      this.source = source;
      this.controller = new Subject();

      if (pauser && pauser.subscribe) ***REMOVED***
        this.pauser = this.controller.merge(pauser);
      ***REMOVED*** else ***REMOVED***
        this.pauser = this.controller;
      ***REMOVED***

      __super__.call(this, subscribe, source);
    ***REMOVED***

    PausableObservable.prototype.pause = function () ***REMOVED***
      this.controller.onNext(false);
    ***REMOVED***;

    PausableObservable.prototype.resume = function () ***REMOVED***
      this.controller.onNext(true);
    ***REMOVED***;

    return PausableObservable;

  ***REMOVED***(Observable));

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausable(pauser);
   * @param ***REMOVED***Observable***REMOVED*** pauser The observable sequence used to pause the underlying sequence.
   * @returns ***REMOVED***Observable***REMOVED*** The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausable = function (pauser) ***REMOVED***
    return new PausableObservable(this, pauser);
  ***REMOVED***;
