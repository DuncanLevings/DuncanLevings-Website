  function combineLatestSource(source, subject, resultSelector) ***REMOVED***
    return new AnonymousObservable(function (o) ***REMOVED***
      var hasValue = [false, false],
        hasValueAll = false,
        isDone = false,
        values = new Array(2),
        err;

      function next(x, i) ***REMOVED***
        values[i] = x
        var res;
        hasValue[i] = true;
        if (hasValueAll || (hasValueAll = hasValue.every(identity))) ***REMOVED***
          if (err) ***REMOVED***
            o.onError(err);
            return;
          ***REMOVED***

          try ***REMOVED***
            res = resultSelector.apply(null, values);
          ***REMOVED*** catch (ex) ***REMOVED***
            o.onError(ex);
            return;
          ***REMOVED***
          o.onNext(res);
        ***REMOVED***
        if (isDone && values[1]) ***REMOVED***
          o.onCompleted();
        ***REMOVED***
      ***REMOVED***

      return new CompositeDisposable(
        source.subscribe(
          function (x) ***REMOVED***
            next(x, 0);
          ***REMOVED***,
          function (e) ***REMOVED***
            if (values[1]) ***REMOVED***
              o.onError(e);
            ***REMOVED*** else ***REMOVED***
              err = e;
            ***REMOVED***
          ***REMOVED***,
          function () ***REMOVED***
            isDone = true;
            values[1] && o.onCompleted();
          ***REMOVED***),
        subject.subscribe(
          function (x) ***REMOVED***
            next(x, 1);
          ***REMOVED***,
          function (e) ***REMOVED*** o.onError(e); ***REMOVED***,
          function () ***REMOVED***
            isDone = true;
            next(true, 1);
          ***REMOVED***)
        );
    ***REMOVED***, source);
  ***REMOVED***

  var PausableBufferedObservable = (function (__super__) ***REMOVED***

    inherits(PausableBufferedObservable, __super__);

    function subscribe(o) ***REMOVED***
      var q = [], previousShouldFire;

      var subscription =
        combineLatestSource(
          this.source,
          this.pauser.distinctUntilChanged().startWith(false),
          function (data, shouldFire) ***REMOVED***
            return ***REMOVED*** data: data, shouldFire: shouldFire ***REMOVED***;
          ***REMOVED***)
          .subscribe(
            function (results) ***REMOVED***
              if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) ***REMOVED***
                previousShouldFire = results.shouldFire;
                // change in shouldFire
                if (results.shouldFire) ***REMOVED***
                  while (q.length > 0) ***REMOVED***
                    o.onNext(q.shift());
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                previousShouldFire = results.shouldFire;
                // new data
                if (results.shouldFire) ***REMOVED***
                  o.onNext(results.data);
                ***REMOVED*** else ***REMOVED***
                  q.push(results.data);
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***,
            function (err) ***REMOVED***
              // Empty buffer before sending error
              while (q.length > 0) ***REMOVED***
                o.onNext(q.shift());
              ***REMOVED***
              o.onError(err);
            ***REMOVED***,
            function () ***REMOVED***
              // Empty buffer before sending completion
              while (q.length > 0) ***REMOVED***
                o.onNext(q.shift());
              ***REMOVED***
              o.onCompleted();
            ***REMOVED***
          );
      return subscription;
    ***REMOVED***

    function PausableBufferedObservable(source, pauser) ***REMOVED***
      this.source = source;
      this.controller = new Subject();

      if (pauser && pauser.subscribe) ***REMOVED***
        this.pauser = this.controller.merge(pauser);
      ***REMOVED*** else ***REMOVED***
        this.pauser = this.controller;
      ***REMOVED***

      __super__.call(this, subscribe, source);
    ***REMOVED***

    PausableBufferedObservable.prototype.pause = function () ***REMOVED***
      this.controller.onNext(false);
    ***REMOVED***;

    PausableBufferedObservable.prototype.resume = function () ***REMOVED***
      this.controller.onNext(true);
    ***REMOVED***;

    return PausableBufferedObservable;

  ***REMOVED***(Observable));

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,
   * and yields the values that were buffered while paused.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);
   * @param ***REMOVED***Observable***REMOVED*** pauser The observable sequence used to pause the underlying sequence.
   * @returns ***REMOVED***Observable***REMOVED*** The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausableBuffered = function (subject) ***REMOVED***
    return new PausableBufferedObservable(this, subject);
  ***REMOVED***;
