  /*
   * Performs a exclusive waiting for the first to finish before subscribing to another observable.
   * Observables that come in between subscriptions will be dropped on the floor.
   * @returns ***REMOVED***Observable***REMOVED*** A exclusive observable with only the results that happen when subscribed.
   */
  observableProto.exclusive = function () ***REMOVED***
    var sources = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var hasCurrent = false,
        isStopped = false,
        m = new SingleAssignmentDisposable(),
        g = new CompositeDisposable();

      g.add(m);

      m.setDisposable(sources.subscribe(
        function (innerSource) ***REMOVED***
          if (!hasCurrent) ***REMOVED***
            hasCurrent = true;

            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));

            var innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);

            innerSubscription.setDisposable(innerSource.subscribe(
              observer.onNext.bind(observer),
              observer.onError.bind(observer),
              function () ***REMOVED***
                g.remove(innerSubscription);
                hasCurrent = false;
                if (isStopped && g.length === 1) ***REMOVED***
                  observer.onCompleted();
                ***REMOVED***
            ***REMOVED***));
          ***REMOVED***
        ***REMOVED***,
        observer.onError.bind(observer),
        function () ***REMOVED***
          isStopped = true;
          if (!hasCurrent && g.length === 1) ***REMOVED***
            observer.onCompleted();
          ***REMOVED***
        ***REMOVED***));

      return g;
    ***REMOVED***, this);
  ***REMOVED***;
