  /*
   * Performs a exclusive map waiting for the first to finish before subscribing to another observable.
   * Observables that come in between subscriptions will be dropped on the floor.
   * @param ***REMOVED***Function***REMOVED*** selector Selector to invoke for every item in the current subscription.
   * @param ***REMOVED***Any***REMOVED*** [thisArg] An optional context to invoke with the selector parameter.
   * @returns ***REMOVED***Observable***REMOVED*** An exclusive observable with only the results that happen when subscribed.
   */
  observableProto.exclusiveMap = function (selector, thisArg) ***REMOVED***
    var sources = this,
        selectorFunc = bindCallback(selector, thisArg, 3);
    return new AnonymousObservable(function (observer) ***REMOVED***
      var index = 0,
        hasCurrent = false,
        isStopped = true,
        m = new SingleAssignmentDisposable(),
        g = new CompositeDisposable();

      g.add(m);

      m.setDisposable(sources.subscribe(
        function (innerSource) ***REMOVED***

          if (!hasCurrent) ***REMOVED***
            hasCurrent = true;

            innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);

            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));

            innerSubscription.setDisposable(innerSource.subscribe(
              function (x) ***REMOVED***
                var result;
                try ***REMOVED***
                  result = selectorFunc(x, index++, innerSource);
                ***REMOVED*** catch (e) ***REMOVED***
                  observer.onError(e);
                  return;
                ***REMOVED***

                observer.onNext(result);
              ***REMOVED***,
              function (e) ***REMOVED*** observer.onError(e); ***REMOVED***,
              function () ***REMOVED***
                g.remove(innerSubscription);
                hasCurrent = false;

                if (isStopped && g.length === 1) ***REMOVED***
                  observer.onCompleted();
                ***REMOVED***
              ***REMOVED***));
          ***REMOVED***
        ***REMOVED***,
        function (e) ***REMOVED*** observer.onError(e); ***REMOVED***,
        function () ***REMOVED***
          isStopped = true;
          if (g.length === 1 && !hasCurrent) ***REMOVED***
            observer.onCompleted();
          ***REMOVED***
        ***REMOVED***));
      return g;
    ***REMOVED***, this);
  ***REMOVED***;
