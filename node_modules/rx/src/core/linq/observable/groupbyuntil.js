    /**
     *  Groups the elements of an observable sequence according to a specified key selector function.
     *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
     *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
     *
     * @example
     *  var res = observable.groupByUntil(function (x) ***REMOVED*** return x.id; ***REMOVED***, null,  function () ***REMOVED*** return Rx.Observable.never(); ***REMOVED***);
     *  2 - observable.groupBy(function (x) ***REMOVED*** return x.id; ***REMOVED***), function (x) ***REMOVED*** return x.name; ***REMOVED***,  function () ***REMOVED*** return Rx.Observable.never(); ***REMOVED***);
     *  3 - observable.groupBy(function (x) ***REMOVED*** return x.id; ***REMOVED***), function (x) ***REMOVED*** return x.name; ***REMOVED***,  function () ***REMOVED*** return Rx.Observable.never(); ***REMOVED***, function (x) ***REMOVED*** return x.toString(); ***REMOVED***);
     * @param ***REMOVED***Function***REMOVED*** keySelector A function to extract the key for each element.
     * @param ***REMOVED***Function***REMOVED*** durationSelector A function to signal the expiration of a group.
     * @param ***REMOVED***Function***REMOVED*** [comparer] Used to compare objects. When not specified, the default comparer is used.
     * @returns ***REMOVED***Observable***REMOVED***
     *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
     *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
     *
     */
    observableProto.groupByUntil = function (keySelector, elementSelector, durationSelector, comparer) ***REMOVED***
      var source = this;
      elementSelector || (elementSelector = identity);
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function (observer) ***REMOVED***
        function handleError(e) ***REMOVED*** return function (item) ***REMOVED*** item.onError(e); ***REMOVED***; ***REMOVED***
        var map = new Dictionary(0, comparer),
          groupDisposable = new CompositeDisposable(),
          refCountDisposable = new RefCountDisposable(groupDisposable);

        groupDisposable.add(source.subscribe(function (x) ***REMOVED***
          var key;
          try ***REMOVED***
            key = keySelector(x);
          ***REMOVED*** catch (e) ***REMOVED***
            map.getValues().forEach(handleError(e));
            observer.onError(e);
            return;
          ***REMOVED***

          var fireNewMapEntry = false,
            writer = map.tryGetValue(key);
          if (!writer) ***REMOVED***
            writer = new Subject();
            map.set(key, writer);
            fireNewMapEntry = true;
          ***REMOVED***

          if (fireNewMapEntry) ***REMOVED***
            var group = new GroupedObservable(key, writer, refCountDisposable),
              durationGroup = new GroupedObservable(key, writer);
            try ***REMOVED***
              duration = durationSelector(durationGroup);
            ***REMOVED*** catch (e) ***REMOVED***
              map.getValues().forEach(handleError(e));
              observer.onError(e);
              return;
            ***REMOVED***

            observer.onNext(group);

            var md = new SingleAssignmentDisposable();
            groupDisposable.add(md);

            var expire = function () ***REMOVED***
              map.remove(key) && writer.onCompleted();
              groupDisposable.remove(md);
            ***REMOVED***;

            md.setDisposable(duration.take(1).subscribe(
              noop,
              function (exn) ***REMOVED***
                map.getValues().forEach(handleError(exn));
                observer.onError(exn);
              ***REMOVED***,
              expire)
            );
          ***REMOVED***

          var element;
          try ***REMOVED***
            element = elementSelector(x);
          ***REMOVED*** catch (e) ***REMOVED***
            map.getValues().forEach(handleError(e));
            observer.onError(e);
            return;
          ***REMOVED***

          writer.onNext(element);
      ***REMOVED***, function (ex) ***REMOVED***
        map.getValues().forEach(handleError(ex));
        observer.onError(ex);
      ***REMOVED***, function () ***REMOVED***
        map.getValues().forEach(function (item) ***REMOVED*** item.onCompleted(); ***REMOVED***);
        observer.onCompleted();
      ***REMOVED***));

      return refCountDisposable;
    ***REMOVED***, source);
  ***REMOVED***;
