  /**
   * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.
   * Or merges two observable sequences into a single observable sequence.
   *
   * @example
   * 1 - merged = sources.merge(1);
   * 2 - merged = source.merge(otherSource);
   * @param ***REMOVED***Mixed***REMOVED*** [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.
   * @returns ***REMOVED***Observable***REMOVED*** The observable sequence that merges the elements of the inner sequences.
   */
  observableProto.merge = function (maxConcurrentOrOther) ***REMOVED***
    if (typeof maxConcurrentOrOther !== 'number') ***REMOVED*** return observableMerge(this, maxConcurrentOrOther); ***REMOVED***
    var sources = this;
    return new AnonymousObservable(function (o) ***REMOVED***
      var activeCount = 0, group = new CompositeDisposable(), isStopped = false, q = [];

      function subscribe(xs) ***REMOVED***
        var subscription = new SingleAssignmentDisposable();
        group.add(subscription);

        // Check for promises support
        isPromise(xs) && (xs = observableFromPromise(xs));

        subscription.setDisposable(xs.subscribe(function (x) ***REMOVED*** o.onNext(x); ***REMOVED***, function (e) ***REMOVED*** o.onError(e); ***REMOVED***, function () ***REMOVED***
          group.remove(subscription);
          if (q.length > 0) ***REMOVED***
            subscribe(q.shift());
          ***REMOVED*** else ***REMOVED***
            activeCount--;
            isStopped && activeCount === 0 && o.onCompleted();
          ***REMOVED***
        ***REMOVED***));
      ***REMOVED***
      group.add(sources.subscribe(function (innerSource) ***REMOVED***
        if (activeCount < maxConcurrentOrOther) ***REMOVED***
          activeCount++;
          subscribe(innerSource);
        ***REMOVED*** else ***REMOVED***
          q.push(innerSource);
        ***REMOVED***
      ***REMOVED***, function (e) ***REMOVED*** o.onError(e); ***REMOVED***, function () ***REMOVED***
        isStopped = true;
        activeCount === 0 && o.onCompleted();
      ***REMOVED***));
      return group;
    ***REMOVED***, sources);
  ***REMOVED***;
