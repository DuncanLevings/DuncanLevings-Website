  /**
   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
   *
   * @example
   *  res = source.generateWithRelativeTime(0,
   *      function (x) ***REMOVED*** return return true; ***REMOVED***,
   *      function (x) ***REMOVED*** return x + 1; ***REMOVED***,
   *      function (x) ***REMOVED*** return x; ***REMOVED***,
   *      function (x) ***REMOVED*** return 500; ***REMOVED***
   *  );
   *
   * @param ***REMOVED***Mixed***REMOVED*** initialState Initial state.
   * @param ***REMOVED***Function***REMOVED*** condition Condition to terminate generation (upon returning false).
   * @param ***REMOVED***Function***REMOVED*** iterate Iteration step function.
   * @param ***REMOVED***Function***REMOVED*** resultSelector Selector function for results produced in the sequence.
   * @param ***REMOVED***Function***REMOVED*** timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.
   * @param ***REMOVED***Scheduler***REMOVED*** [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
   * @returns ***REMOVED***Observable***REMOVED*** The generated sequence.
   */
  Observable.generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) ***REMOVED***
    isScheduler(scheduler) || (scheduler = timeoutScheduler);
    return new AnonymousObservable(function (observer) ***REMOVED***
      var first = true,
        hasResult = false,
        result,
        state = initialState,
        time;
      return scheduler.scheduleRecursiveWithRelative(0, function (self) ***REMOVED***
        hasResult && observer.onNext(result);

        try ***REMOVED***
          if (first) ***REMOVED***
            first = false;
          ***REMOVED*** else ***REMOVED***
            state = iterate(state);
          ***REMOVED***
          hasResult = condition(state);
          if (hasResult) ***REMOVED***
            result = resultSelector(state);
            time = timeSelector(state);
          ***REMOVED***
        ***REMOVED*** catch (e) ***REMOVED***
          observer.onError(e);
          return;
        ***REMOVED***
        if (hasResult) ***REMOVED***
          self(time);
        ***REMOVED*** else ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***;
