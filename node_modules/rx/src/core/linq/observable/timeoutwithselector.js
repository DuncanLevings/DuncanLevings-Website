    /**
     *  Returns the source observable sequence, switching to the other observable sequence if a timeout is signaled.
     * @param ***REMOVED***Observable***REMOVED*** [firstTimeout]  Observable sequence that represents the timeout for the first element. If not provided, this defaults to Observable.never().
     * @param ***REMOVED***Function***REMOVED*** [timeoutDurationSelector] Selector to retrieve an observable sequence that represents the timeout between the current element and the next element.
     * @param ***REMOVED***Observable***REMOVED*** [other]  Sequence to return in case of a timeout. If not provided, this is set to Observable.throwException().
     * @returns ***REMOVED***Observable***REMOVED*** The source sequence switching to the other sequence in case of a timeout.
     */
    observableProto.timeoutWithSelector = function (firstTimeout, timeoutdurationSelector, other) ***REMOVED***
      if (arguments.length === 1) ***REMOVED***
          timeoutdurationSelector = firstTimeout;
          firstTimeout = observableNever();
      ***REMOVED***
      other || (other = observableThrow(new Error('Timeout')));
      var source = this;
      return new AnonymousObservable(function (observer) ***REMOVED***
        var subscription = new SerialDisposable(), timer = new SerialDisposable(), original = new SingleAssignmentDisposable();

        subscription.setDisposable(original);

        var id = 0, switched = false;

        function setTimer(timeout) ***REMOVED***
          var myId = id;

          function timerWins () ***REMOVED***
            return id === myId;
          ***REMOVED***

          var d = new SingleAssignmentDisposable();
          timer.setDisposable(d);
          d.setDisposable(timeout.subscribe(function () ***REMOVED***
            timerWins() && subscription.setDisposable(other.subscribe(observer));
            d.dispose();
          ***REMOVED***, function (e) ***REMOVED***
            timerWins() && observer.onError(e);
          ***REMOVED***, function () ***REMOVED***
            timerWins() && subscription.setDisposable(other.subscribe(observer));
          ***REMOVED***));
        ***REMOVED***;

        setTimer(firstTimeout);

        function observerWins() ***REMOVED***
          var res = !switched;
          if (res) ***REMOVED*** id++; ***REMOVED***
          return res;
        ***REMOVED***

        original.setDisposable(source.subscribe(function (x) ***REMOVED***
          if (observerWins()) ***REMOVED***
            observer.onNext(x);
            var timeout;
            try ***REMOVED***
              timeout = timeoutdurationSelector(x);
            ***REMOVED*** catch (e) ***REMOVED***
              observer.onError(e);
              return;
            ***REMOVED***
            setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
          ***REMOVED***
        ***REMOVED***, function (e) ***REMOVED***
          observerWins() && observer.onError(e);
        ***REMOVED***, function () ***REMOVED***
          observerWins() && observer.onCompleted();
        ***REMOVED***));
        return new CompositeDisposable(subscription, timer);
      ***REMOVED***, source);
    ***REMOVED***;
