  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.
   *
   * @example
   * 1 - obs = obs1.withLatestFrom(obs2, obs3, function (o1, o2, o3) ***REMOVED*** return o1 + o2 + o3; ***REMOVED***);
   * 2 - obs = obs1.withLatestFrom([obs2, obs3], function (o1, o2, o3) ***REMOVED*** return o1 + o2 + o3; ***REMOVED***);
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  observableProto.withLatestFrom = function () ***REMOVED***
    var source = this;
    var args = slice.call(arguments);
    var resultSelector = args.pop();

    if (typeof source === 'undefined') ***REMOVED***
      throw new Error('Source observable not found for withLatestFrom().');
    ***REMOVED***
    if (typeof resultSelector !== 'function') ***REMOVED***
      throw new Error('withLatestFrom() expects a resultSelector function.');
    ***REMOVED***
    if (Array.isArray(args[0])) ***REMOVED***
      args = args[0];
    ***REMOVED***

    return new AnonymousObservable(function (observer) ***REMOVED***
      var falseFactory = function () ***REMOVED*** return false; ***REMOVED***,
        n = args.length,
        hasValue = arrayInitialize(n, falseFactory),
        hasValueAll = false,
        values = new Array(n);

      var subscriptions = new Array(n + 1);
      for (var idx = 0; idx < n; idx++) ***REMOVED***
        (function (i) ***REMOVED***
          var other = args[i], sad = new SingleAssignmentDisposable();
          isPromise(other) && (other = observableFromPromise(other));
          sad.setDisposable(other.subscribe(function (x) ***REMOVED***
            values[i] = x;
            hasValue[i] = true;
            hasValueAll = hasValue.every(identity);
          ***REMOVED***, observer.onError.bind(observer), function () ***REMOVED******REMOVED***));
          subscriptions[i] = sad;
        ***REMOVED***(idx));
      ***REMOVED***

      var sad = new SingleAssignmentDisposable();
      sad.setDisposable(source.subscribe(function (x) ***REMOVED***
        var res;
        var allValues = [x].concat(values);
        if (!hasValueAll) return;
        try ***REMOVED***
          res = resultSelector.apply(null, allValues);
        ***REMOVED*** catch (ex) ***REMOVED***
          observer.onError(ex);
          return;
        ***REMOVED***
        observer.onNext(res);
      ***REMOVED***, observer.onError.bind(observer), function () ***REMOVED***
        observer.onCompleted();
      ***REMOVED***));
      subscriptions[n] = sad;

      return new CompositeDisposable(subscriptions);
    ***REMOVED***, this);
  ***REMOVED***;
