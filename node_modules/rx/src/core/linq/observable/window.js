  /**
   *  Projects each element of an observable sequence into zero or more windows.
   *
   *  @param ***REMOVED***Mixed***REMOVED*** windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
   *  @param ***REMOVED***Function***REMOVED*** [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
   *  @returns ***REMOVED***Observable***REMOVED*** An observable sequence of windows.
   */
  observableProto.window = function (windowOpeningsOrClosingSelector, windowClosingSelector) ***REMOVED***
    if (arguments.length === 1 && typeof arguments[0] !== 'function') ***REMOVED***
      return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
    ***REMOVED***
    return typeof windowOpeningsOrClosingSelector === 'function' ?
      observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) :
      observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
  ***REMOVED***;

  function observableWindowWithOpenings(windowOpenings, windowClosingSelector) ***REMOVED***
    return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function (_, win) ***REMOVED***
      return win;
    ***REMOVED***);
  ***REMOVED***

  function observableWindowWithBoundaries(windowBoundaries) ***REMOVED***
    var source = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var win = new Subject(),
        d = new CompositeDisposable(),
        r = new RefCountDisposable(d);

      observer.onNext(addRef(win, r));

      d.add(source.subscribe(function (x) ***REMOVED***
        win.onNext(x);
      ***REMOVED***, function (err) ***REMOVED***
        win.onError(err);
        observer.onError(err);
      ***REMOVED***, function () ***REMOVED***
        win.onCompleted();
        observer.onCompleted();
      ***REMOVED***));

      isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));

      d.add(windowBoundaries.subscribe(function (w) ***REMOVED***
        win.onCompleted();
        win = new Subject();
        observer.onNext(addRef(win, r));
      ***REMOVED***, function (err) ***REMOVED***
        win.onError(err);
        observer.onError(err);
      ***REMOVED***, function () ***REMOVED***
        win.onCompleted();
        observer.onCompleted();
      ***REMOVED***));

      return r;
    ***REMOVED***, source);
  ***REMOVED***

  function observableWindowWithClosingSelector(windowClosingSelector) ***REMOVED***
    var source = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var m = new SerialDisposable(),
        d = new CompositeDisposable(m),
        r = new RefCountDisposable(d),
        win = new Subject();
      observer.onNext(addRef(win, r));
      d.add(source.subscribe(function (x) ***REMOVED***
          win.onNext(x);
      ***REMOVED***, function (err) ***REMOVED***
          win.onError(err);
          observer.onError(err);
      ***REMOVED***, function () ***REMOVED***
          win.onCompleted();
          observer.onCompleted();
      ***REMOVED***));

      function createWindowClose () ***REMOVED***
        var windowClose;
        try ***REMOVED***
          windowClose = windowClosingSelector();
        ***REMOVED*** catch (e) ***REMOVED***
          observer.onError(e);
          return;
        ***REMOVED***

        isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));

        var m1 = new SingleAssignmentDisposable();
        m.setDisposable(m1);
        m1.setDisposable(windowClose.take(1).subscribe(noop, function (err) ***REMOVED***
          win.onError(err);
          observer.onError(err);
        ***REMOVED***, function () ***REMOVED***
          win.onCompleted();
          win = new Subject();
          observer.onNext(addRef(win, r));
          createWindowClose();
        ***REMOVED***));
      ***REMOVED***

      createWindowClose();
      return r;
    ***REMOVED***, source);
  ***REMOVED***
