  function observableDelayTimeSpan(source, dueTime, scheduler) ***REMOVED***
    return new AnonymousObservable(function (observer) ***REMOVED***
      var active = false,
        cancelable = new SerialDisposable(),
        exception = null,
        q = [],
        running = false,
        subscription;
      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) ***REMOVED***
        var d, shouldRun;
        if (notification.value.kind === 'E') ***REMOVED***
          q = [];
          q.push(notification);
          exception = notification.value.exception;
          shouldRun = !running;
        ***REMOVED*** else ***REMOVED***
          q.push(***REMOVED*** value: notification.value, timestamp: notification.timestamp + dueTime ***REMOVED***);
          shouldRun = !active;
          active = true;
        ***REMOVED***
        if (shouldRun) ***REMOVED***
          if (exception !== null) ***REMOVED***
            observer.onError(exception);
          ***REMOVED*** else ***REMOVED***
            d = new SingleAssignmentDisposable();
            cancelable.setDisposable(d);
            d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function (self) ***REMOVED***
              var e, recurseDueTime, result, shouldRecurse;
              if (exception !== null) ***REMOVED***
                return;
              ***REMOVED***
              running = true;
              do ***REMOVED***
                result = null;
                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) ***REMOVED***
                  result = q.shift().value;
                ***REMOVED***
                if (result !== null) ***REMOVED***
                  result.accept(observer);
                ***REMOVED***
              ***REMOVED*** while (result !== null);
              shouldRecurse = false;
              recurseDueTime = 0;
              if (q.length > 0) ***REMOVED***
                shouldRecurse = true;
                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
              ***REMOVED*** else ***REMOVED***
                active = false;
              ***REMOVED***
              e = exception;
              running = false;
              if (e !== null) ***REMOVED***
                observer.onError(e);
              ***REMOVED*** else if (shouldRecurse) ***REMOVED***
                self(recurseDueTime);
              ***REMOVED***
            ***REMOVED***));
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***);
      return new CompositeDisposable(subscription, cancelable);
    ***REMOVED***, source);
  ***REMOVED***

  function observableDelayDate(source, dueTime, scheduler) ***REMOVED***
    return observableDefer(function () ***REMOVED***
      return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler);
    ***REMOVED***);
  ***REMOVED***

  /**
   *  Time shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.
   *
   * @example
   *  1 - res = Rx.Observable.delay(new Date());
   *  2 - res = Rx.Observable.delay(new Date(), Rx.Scheduler.timeout);
   *
   *  3 - res = Rx.Observable.delay(5000);
   *  4 - res = Rx.Observable.delay(5000, 1000, Rx.Scheduler.timeout);
   * @memberOf Observable#
   * @param ***REMOVED***Number***REMOVED*** dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.
   * @param ***REMOVED***Scheduler***REMOVED*** [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.
   * @returns ***REMOVED***Observable***REMOVED*** Time-shifted sequence.
   */
  observableProto.delay = function (dueTime, scheduler) ***REMOVED***
    isScheduler(scheduler) || (scheduler = timeoutScheduler);
    return dueTime instanceof Date ?
      observableDelayDate(this, dueTime.getTime(), scheduler) :
      observableDelayTimeSpan(this, dueTime, scheduler);
  ***REMOVED***;
