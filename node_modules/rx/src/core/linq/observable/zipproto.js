  function zipArray(second, resultSelector) ***REMOVED***
    var first = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var index = 0, len = second.length;
      return first.subscribe(function (left) ***REMOVED***
        if (index < len) ***REMOVED***
          var right = second[index++], result;
          try ***REMOVED***
            result = resultSelector(left, right);
          ***REMOVED*** catch (e) ***REMOVED***
            observer.onError(e);
            return;
          ***REMOVED***
          observer.onNext(result);
        ***REMOVED*** else ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ***REMOVED***, function (e) ***REMOVED*** observer.onError(e); ***REMOVED***, function () ***REMOVED*** observer.onCompleted(); ***REMOVED***);
    ***REMOVED***, first);
  ***REMOVED***

  /**
   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the sources.
   *
   * @example
   * 1 - res = obs1.zip(obs2, fn);
   * 1 - res = x1.zip([1,2,3], fn);
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   */
  observableProto.zip = function () ***REMOVED***
    if (Array.isArray(arguments[0])) ***REMOVED***
      return zipArray.apply(this, arguments);
    ***REMOVED***
    var parent = this, sources = slice.call(arguments), resultSelector = sources.pop();
    sources.unshift(parent);
    return new AnonymousObservable(function (observer) ***REMOVED***
      var n = sources.length,
        queues = arrayInitialize(n, function () ***REMOVED*** return []; ***REMOVED***),
        isDone = arrayInitialize(n, function () ***REMOVED*** return false; ***REMOVED***);

      function next(i) ***REMOVED***
        var res, queuedValues;
        if (queues.every(function (x) ***REMOVED*** return x.length > 0; ***REMOVED***)) ***REMOVED***
          try ***REMOVED***
            queuedValues = queues.map(function (x) ***REMOVED*** return x.shift(); ***REMOVED***);
            res = resultSelector.apply(parent, queuedValues);
          ***REMOVED*** catch (ex) ***REMOVED***
            observer.onError(ex);
            return;
          ***REMOVED***
          observer.onNext(res);
        ***REMOVED*** else if (isDone.filter(function (x, j) ***REMOVED*** return j !== i; ***REMOVED***).every(identity)) ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ***REMOVED***;

      function done(i) ***REMOVED***
        isDone[i] = true;
        if (isDone.every(function (x) ***REMOVED*** return x; ***REMOVED***)) ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ***REMOVED***

      var subscriptions = new Array(n);
      for (var idx = 0; idx < n; idx++) ***REMOVED***
        (function (i) ***REMOVED***
          var source = sources[i], sad = new SingleAssignmentDisposable();
          isPromise(source) && (source = observableFromPromise(source));
          sad.setDisposable(source.subscribe(function (x) ***REMOVED***
            queues[i].push(x);
            next(i);
          ***REMOVED***, function (e) ***REMOVED*** observer.onError(e); ***REMOVED***, function () ***REMOVED***
            done(i);
          ***REMOVED***));
          subscriptions[i] = sad;
        ***REMOVED***)(idx);
      ***REMOVED***

      return new CompositeDisposable(subscriptions);
    ***REMOVED***, parent);
  ***REMOVED***;
