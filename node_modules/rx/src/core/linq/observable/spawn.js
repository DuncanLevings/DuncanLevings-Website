  var fnString = 'function',
      throwString = 'throw',
      isObject = Rx.internals.isObject;

  function toThunk(obj, ctx) ***REMOVED***
    if (Array.isArray(obj)) ***REMOVED***  return objectToThunk.call(ctx, obj); ***REMOVED***
    if (isGeneratorFunction(obj)) ***REMOVED*** return observableSpawn(obj.call(ctx)); ***REMOVED***
    if (isGenerator(obj)) ***REMOVED***  return observableSpawn(obj); ***REMOVED***
    if (isObservable(obj)) ***REMOVED*** return observableToThunk(obj); ***REMOVED***
    if (isPromise(obj)) ***REMOVED*** return promiseToThunk(obj); ***REMOVED***
    if (typeof obj === fnString) ***REMOVED*** return obj; ***REMOVED***
    if (isObject(obj) || Array.isArray(obj)) ***REMOVED*** return objectToThunk.call(ctx, obj); ***REMOVED***

    return obj;
  ***REMOVED***

  function objectToThunk(obj) ***REMOVED***
    var ctx = this;

    return function (done) ***REMOVED***
      var keys = Object.keys(obj),
          pending = keys.length,
          results = new obj.constructor(),
          finished;

      if (!pending) ***REMOVED***
        timeoutScheduler.schedule(function () ***REMOVED*** done(null, results); ***REMOVED***);
        return;
      ***REMOVED***

      for (var i = 0, len = keys.length; i < len; i++) ***REMOVED***
        run(obj[keys[i]], keys[i]);
      ***REMOVED***

      function run(fn, key) ***REMOVED***
        if (finished) ***REMOVED*** return; ***REMOVED***
        try ***REMOVED***
          fn = toThunk(fn, ctx);

          if (typeof fn !== fnString) ***REMOVED***
            results[key] = fn;
            return --pending || done(null, results);
          ***REMOVED***

          fn.call(ctx, function(err, res) ***REMOVED***
            if (finished) ***REMOVED*** return; ***REMOVED***

            if (err) ***REMOVED***
              finished = true;
              return done(err);
            ***REMOVED***

            results[key] = res;
            --pending || done(null, results);
          ***REMOVED***);
        ***REMOVED*** catch (e) ***REMOVED***
          finished = true;
          done(e);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function observableToThunk(observable) ***REMOVED***
    return function (fn) ***REMOVED***
      var value, hasValue = false;
      observable.subscribe(
        function (v) ***REMOVED***
          value = v;
          hasValue = true;
        ***REMOVED***,
        fn,
        function () ***REMOVED***
          hasValue && fn(null, value);
        ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  function promiseToThunk(promise) ***REMOVED***
    return function(fn) ***REMOVED***
      promise.then(function(res) ***REMOVED***
        fn(null, res);
      ***REMOVED***, fn);
    ***REMOVED***
  ***REMOVED***

  function isObservable(obj) ***REMOVED***
    return obj && typeof obj.subscribe === fnString;
  ***REMOVED***

  function isGeneratorFunction(obj) ***REMOVED***
    return obj && obj.constructor && obj.constructor.name === 'GeneratorFunction';
  ***REMOVED***

  function isGenerator(obj) ***REMOVED***
    return obj && typeof obj.next === fnString && typeof obj[throwString] === fnString;
  ***REMOVED***

  /*
   * Spawns a generator function which allows for Promises, Observable sequences, Arrays, Objects, Generators and functions.
   * @param ***REMOVED***Function***REMOVED*** The spawning function.
   * @returns ***REMOVED***Function***REMOVED*** a function which has a done continuation.
   */
  var observableSpawn = Rx.spawn = function (fn) ***REMOVED***
    var isGenFun = isGeneratorFunction(fn);

    return function (done) ***REMOVED***
      var ctx = this,
        gen = fn;

      if (isGenFun) ***REMOVED***
        var args = slice.call(arguments),
          len = args.length,
          hasCallback = len && typeof args[len - 1] === fnString;

        done = hasCallback ? args.pop() : handleError;
        gen = fn.apply(this, args);
      ***REMOVED*** else ***REMOVED***
        done = done || handleError;
      ***REMOVED***

      next();

      function exit(err, res) ***REMOVED***
        timeoutScheduler.schedule(done.bind(ctx, err, res));
      ***REMOVED***

      function next(err, res) ***REMOVED***
        var ret;

        // multiple args
        if (arguments.length > 2) ***REMOVED***
          res = slice.call(arguments, 1);
        ***REMOVED***

        if (err) ***REMOVED***
          try ***REMOVED***
            ret = gen[throwString](err);
          ***REMOVED*** catch (e) ***REMOVED***
            return exit(e);
          ***REMOVED***
        ***REMOVED***

        if (!err) ***REMOVED***
          try ***REMOVED***
            ret = gen.next(res);
          ***REMOVED*** catch (e) ***REMOVED***
            return exit(e);
          ***REMOVED***
        ***REMOVED***

        if (ret.done)  ***REMOVED***
          return exit(null, ret.value);
        ***REMOVED***

        ret.value = toThunk(ret.value, ctx);

        if (typeof ret.value === fnString) ***REMOVED***
          var called = false;
          try ***REMOVED***
            ret.value.call(ctx, function() ***REMOVED***
              if (called) ***REMOVED***
                return;
              ***REMOVED***

              called = true;
              next.apply(ctx, arguments);
            ***REMOVED***);
          ***REMOVED*** catch (e) ***REMOVED***
            timeoutScheduler.schedule(function () ***REMOVED***
              if (called) ***REMOVED***
                return;
              ***REMOVED***

              called = true;
              next.call(ctx, e);
            ***REMOVED***);
          ***REMOVED***
          return;
        ***REMOVED***

        // Not supported
        next(new TypeError('Rx.spawn only supports a function, Promise, Observable, Object or Array.'));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  function handleError(err) ***REMOVED***
    if (!err) ***REMOVED*** return; ***REMOVED***
    timeoutScheduler.schedule(function() ***REMOVED***
      throw err;
    ***REMOVED***);
  ***REMOVED***
