  var maxSafeInteger = Math.pow(2, 53) - 1;

  function StringIterable(str) ***REMOVED***
    this._s = s;
  ***REMOVED***

  StringIterable.prototype[$iterator$] = function () ***REMOVED***
    return new StringIterator(this._s);
  ***REMOVED***;

  function StringIterator(str) ***REMOVED***
    this._s = s;
    this._l = s.length;
    this._i = 0;
  ***REMOVED***

  StringIterator.prototype[$iterator$] = function () ***REMOVED***
    return this;
  ***REMOVED***;

  StringIterator.prototype.next = function () ***REMOVED***
    if (this._i < this._l) ***REMOVED***
      var val = this._s.charAt(this._i++);
      return ***REMOVED*** done: false, value: val ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
      return doneEnumerator;
    ***REMOVED***
  ***REMOVED***;

  function ArrayIterable(a) ***REMOVED***
    this._a = a;
  ***REMOVED***

  ArrayIterable.prototype[$iterator$] = function () ***REMOVED***
    return new ArrayIterator(this._a);
  ***REMOVED***;

  function ArrayIterator(a) ***REMOVED***
    this._a = a;
    this._l = toLength(a);
    this._i = 0;
  ***REMOVED***

  ArrayIterator.prototype[$iterator$] = function () ***REMOVED***
    return this;
  ***REMOVED***;

  ArrayIterator.prototype.next = function () ***REMOVED***
    if (this._i < this._l) ***REMOVED***
      var val = this._a[this._i++];
      return ***REMOVED*** done: false, value: val ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
      return doneEnumerator;
    ***REMOVED***
  ***REMOVED***;

  function numberIsFinite(value) ***REMOVED***
    return typeof value === 'number' && root.isFinite(value);
  ***REMOVED***

  function isNan(n) ***REMOVED***
    return n !== n;
  ***REMOVED***

  function getIterable(o) ***REMOVED***
    var i = o[$iterator$], it;
    if (!i && typeof o === 'string') ***REMOVED***
      it = new StringIterable(o);
      return it[$iterator$]();
    ***REMOVED***
    if (!i && o.length !== undefined) ***REMOVED***
      it = new ArrayIterable(o);
      return it[$iterator$]();
    ***REMOVED***
    if (!i) ***REMOVED*** throw new TypeError('Object is not iterable'); ***REMOVED***
    return o[$iterator$]();
  ***REMOVED***

  function sign(value) ***REMOVED***
    var number = +value;
    if (number === 0) ***REMOVED*** return number; ***REMOVED***
    if (isNaN(number)) ***REMOVED*** return number; ***REMOVED***
    return number < 0 ? -1 : 1;
  ***REMOVED***

  function toLength(o) ***REMOVED***
    var len = +o.length;
    if (isNaN(len)) ***REMOVED*** return 0; ***REMOVED***
    if (len === 0 || !numberIsFinite(len)) ***REMOVED*** return len; ***REMOVED***
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) ***REMOVED*** return 0; ***REMOVED***
    if (len > maxSafeInteger) ***REMOVED*** return maxSafeInteger; ***REMOVED***
    return len;
  ***REMOVED***

  /**
   * This method creates a new Observable sequence from an array-like or iterable object.
   * @param ***REMOVED***Any***REMOVED*** arrayLike An array-like or iterable object to convert to an Observable sequence.
   * @param ***REMOVED***Function***REMOVED*** [mapFn] Map function to call on every element of the array.
   * @param ***REMOVED***Any***REMOVED*** [thisArg] The context to use calling the mapFn if provided.
   * @param ***REMOVED***Scheduler***REMOVED*** [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
   */
  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) ***REMOVED***
    if (iterable == null) ***REMOVED***
      throw new Error('iterable cannot be null.')
    ***REMOVED***
    if (mapFn && !isFunction(mapFn)) ***REMOVED***
      throw new Error('mapFn when provided must be a function');
    ***REMOVED***
    if (mapFn) ***REMOVED***
      var mapper = bindCallback(mapFn, thisArg, 2);
    ***REMOVED***
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    var list = Object(iterable), it = getIterable(list);
    return new AnonymousObservable(function (observer) ***REMOVED***
      var i = 0;
      return scheduler.scheduleRecursive(function (self) ***REMOVED***
        var next;
        try ***REMOVED***
          next = it.next();
        ***REMOVED*** catch (e) ***REMOVED***
          observer.onError(e);
          return;
        ***REMOVED***
        if (next.done) ***REMOVED***
          observer.onCompleted();
          return;
        ***REMOVED***

        var result = next.value;

        if (mapper) ***REMOVED***
          try ***REMOVED***
            result = mapper(result, i);
          ***REMOVED*** catch (e) ***REMOVED***
            observer.onError(e);
            return;
          ***REMOVED***
        ***REMOVED***

        observer.onNext(result);
        i++;
        self();
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***;
