   /**
   *  Expands an observable sequence by recursively invoking selector.
   *
   * @param ***REMOVED***Function***REMOVED*** selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.
   * @param ***REMOVED***Scheduler***REMOVED*** [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence containing all the elements produced by the recursive expansion.
   */
  observableProto.expand = function (selector, scheduler) ***REMOVED***
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    var source = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var q = [],
        m = new SerialDisposable(),
        d = new CompositeDisposable(m),
        activeCount = 0,
        isAcquired = false;

      var ensureActive = function () ***REMOVED***
        var isOwner = false;
        if (q.length > 0) ***REMOVED***
          isOwner = !isAcquired;
          isAcquired = true;
        ***REMOVED***
        if (isOwner) ***REMOVED***
          m.setDisposable(scheduler.scheduleRecursive(function (self) ***REMOVED***
            var work;
            if (q.length > 0) ***REMOVED***
              work = q.shift();
            ***REMOVED*** else ***REMOVED***
              isAcquired = false;
              return;
            ***REMOVED***
            var m1 = new SingleAssignmentDisposable();
            d.add(m1);
            m1.setDisposable(work.subscribe(function (x) ***REMOVED***
              observer.onNext(x);
              var result = null;
              try ***REMOVED***
                result = selector(x);
              ***REMOVED*** catch (e) ***REMOVED***
                observer.onError(e);
              ***REMOVED***
              q.push(result);
              activeCount++;
              ensureActive();
            ***REMOVED***, observer.onError.bind(observer), function () ***REMOVED***
              d.remove(m1);
              activeCount--;
              if (activeCount === 0) ***REMOVED***
                observer.onCompleted();
              ***REMOVED***
            ***REMOVED***));
            self();
          ***REMOVED***));
        ***REMOVED***
      ***REMOVED***;

      q.push(source);
      activeCount++;
      ensureActive();
      return d;
    ***REMOVED***, this);
  ***REMOVED***;
