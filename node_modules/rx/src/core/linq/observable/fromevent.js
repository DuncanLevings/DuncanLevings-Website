  function fixEvent(event) ***REMOVED***
    var stopPropagation = function () ***REMOVED***
      this.cancelBubble = true;
    ***REMOVED***;

    var preventDefault = function () ***REMOVED***
      this.bubbledKeyCode = this.keyCode;
      if (this.ctrlKey) ***REMOVED***
        try ***REMOVED***
          this.keyCode = 0;
        ***REMOVED*** catch (e) ***REMOVED*** ***REMOVED***
      ***REMOVED***
      this.defaultPrevented = true;
      this.returnValue = false;
      this.modified = true;
    ***REMOVED***;

    event || (event = root.event);
    if (!event.target) ***REMOVED***
      event.target = event.target || event.srcElement;

      if (event.type == 'mouseover') ***REMOVED***
        event.relatedTarget = event.fromElement;
      ***REMOVED***
      if (event.type == 'mouseout') ***REMOVED***
        event.relatedTarget = event.toElement;
      ***REMOVED***
      // Adding stopPropogation and preventDefault to IE
      if (!event.stopPropagation) ***REMOVED***
        event.stopPropagation = stopPropagation;
        event.preventDefault = preventDefault;
      ***REMOVED***
      // Normalize key events
      switch (event.type) ***REMOVED***
        case 'keypress':
          var c = ('charCode' in event ? event.charCode : event.keyCode);
          if (c == 10) ***REMOVED***
            c = 0;
            event.keyCode = 13;
          ***REMOVED*** else if (c == 13 || c == 27) ***REMOVED***
            c = 0;
          ***REMOVED*** else if (c == 3) ***REMOVED***
            c = 99;
          ***REMOVED***
          event.charCode = c;
          event.keyChar = event.charCode ? String.fromCharCode(event.charCode) : '';
          break;
      ***REMOVED***
    ***REMOVED***

    return event;
  ***REMOVED***

  function createListener (element, name, handler) ***REMOVED***
    // Standards compliant
    if (element.addEventListener) ***REMOVED***
      element.addEventListener(name, handler, false);
      return disposableCreate(function () ***REMOVED***
        element.removeEventListener(name, handler, false);
      ***REMOVED***);
    ***REMOVED***
    if (element.attachEvent) ***REMOVED***
      // IE Specific
      var innerHandler = function (event) ***REMOVED***
        handler(fixEvent(event));
      ***REMOVED***;
      element.attachEvent('on' + name, innerHandler);
      return disposableCreate(function () ***REMOVED***
        element.detachEvent('on' + name, innerHandler);
      ***REMOVED***);
    ***REMOVED***
    // Level 1 DOM Events
    element['on' + name] = handler;
    return disposableCreate(function () ***REMOVED***
      element['on' + name] = null;
    ***REMOVED***);
  ***REMOVED***

  function createEventListener (el, eventName, handler) ***REMOVED***
    var disposables = new CompositeDisposable();

    // Asume NodeList
    if (Object.prototype.toString.call(el) === '[object NodeList]') ***REMOVED***
      for (var i = 0, len = el.length; i < len; i++) ***REMOVED***
        disposables.add(createEventListener(el.item(i), eventName, handler));
      ***REMOVED***
    ***REMOVED*** else if (el) ***REMOVED***
      disposables.add(createListener(el, eventName, handler));
    ***REMOVED***

    return disposables;
  ***REMOVED***

  /**
   * Configuration option to determine whether to use native events only
   */
  Rx.config.useNativeEvents = false;

  /**
   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.
   *
   * @example
   *   var source = Rx.Observable.fromEvent(element, 'mouseup');
   *
   * @param ***REMOVED***Object***REMOVED*** element The DOMElement or NodeList to attach a listener.
   * @param ***REMOVED***String***REMOVED*** eventName The event name to attach the observable sequence.
   * @param ***REMOVED***Function***REMOVED*** [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence of events from the specified element and the specified event.
   */
  Observable.fromEvent = function (element, eventName, selector) ***REMOVED***
    // Node.js specific
    if (element.addListener) ***REMOVED***
      return fromEventPattern(
        function (h) ***REMOVED*** element.addListener(eventName, h); ***REMOVED***,
        function (h) ***REMOVED*** element.removeListener(eventName, h); ***REMOVED***,
        selector);
    ***REMOVED***

    // Use only if non-native events are allowed
    if (!Rx.config.useNativeEvents) ***REMOVED***
      // Handles jq, Angular.js, Zepto, Marionette
      if (typeof element.on === 'function' && typeof element.off === 'function') ***REMOVED***
        return fromEventPattern(
          function (h) ***REMOVED*** element.on(eventName, h); ***REMOVED***,
          function (h) ***REMOVED*** element.off(eventName, h); ***REMOVED***,
          selector);
      ***REMOVED***
      if (!!root.Ember && typeof root.Ember.addListener === 'function') ***REMOVED***
        return fromEventPattern(
          function (h) ***REMOVED*** Ember.addListener(element, eventName, h); ***REMOVED***,
          function (h) ***REMOVED*** Ember.removeListener(element, eventName, h); ***REMOVED***,
          selector);
        ***REMOVED***
    ***REMOVED***
    return new AnonymousObservable(function (observer) ***REMOVED***
      return createEventListener(
        element,
        eventName,
        function handler (e) ***REMOVED***
          var results = e;

          if (selector) ***REMOVED***
            try ***REMOVED***
              results = selector(arguments);
            ***REMOVED*** catch (err) ***REMOVED***
              observer.onError(err);
              return
            ***REMOVED***
          ***REMOVED***

          observer.onNext(results);
        ***REMOVED***);
    ***REMOVED***).publish().refCount();
  ***REMOVED***;
