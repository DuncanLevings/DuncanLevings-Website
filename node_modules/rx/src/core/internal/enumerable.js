  var Enumerable = Rx.internals.Enumerable = function (iterator) ***REMOVED***
    this._iterator = iterator;
  ***REMOVED***;

  Enumerable.prototype[$iterator$] = function () ***REMOVED***
    return this._iterator();
  ***REMOVED***;

  Enumerable.prototype.concat = function () ***REMOVED***
    var sources = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var e;
      try ***REMOVED***
        e = sources[$iterator$]();
      ***REMOVED*** catch (err) ***REMOVED***
        observer.onError(err);
        return;
      ***REMOVED***

      var isDisposed,
        subscription = new SerialDisposable();
      var cancelable = immediateScheduler.scheduleRecursive(function (self) ***REMOVED***
        var currentItem;
        if (isDisposed) ***REMOVED*** return; ***REMOVED***

        try ***REMOVED***
          currentItem = e.next();
        ***REMOVED*** catch (ex) ***REMOVED***
          observer.onError(ex);
          return;
        ***REMOVED***

        if (currentItem.done) ***REMOVED***
          observer.onCompleted();
          return;
        ***REMOVED***

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var d = new SingleAssignmentDisposable();
        subscription.setDisposable(d);
        d.setDisposable(currentValue.subscribe(
          observer.onNext.bind(observer),
          observer.onError.bind(observer),
          function () ***REMOVED*** self(); ***REMOVED***)
        );
      ***REMOVED***);

      return new CompositeDisposable(subscription, cancelable, disposableCreate(function () ***REMOVED***
        isDisposed = true;
      ***REMOVED***));
    ***REMOVED***);
  ***REMOVED***;

  Enumerable.prototype.catchError = function () ***REMOVED***
    var sources = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var e;
      try ***REMOVED***
        e = sources[$iterator$]();
      ***REMOVED*** catch (err) ***REMOVED***
        observer.onError(err);
        return;
      ***REMOVED***

      var isDisposed,
        lastException,
        subscription = new SerialDisposable();
      var cancelable = immediateScheduler.scheduleRecursive(function (self) ***REMOVED***
        if (isDisposed) ***REMOVED*** return; ***REMOVED***

        var currentItem;
        try ***REMOVED***
          currentItem = e.next();
        ***REMOVED*** catch (ex) ***REMOVED***
          observer.onError(ex);
          return;
        ***REMOVED***

        if (currentItem.done) ***REMOVED***
          if (lastException) ***REMOVED***
            observer.onError(lastException);
          ***REMOVED*** else ***REMOVED***
            observer.onCompleted();
          ***REMOVED***
          return;
        ***REMOVED***

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var d = new SingleAssignmentDisposable();
        subscription.setDisposable(d);
        d.setDisposable(currentValue.subscribe(
          observer.onNext.bind(observer),
          function (exn) ***REMOVED***
            lastException = exn;
            self();
          ***REMOVED***,
          observer.onCompleted.bind(observer)));
      ***REMOVED***);
      return new CompositeDisposable(subscription, cancelable, disposableCreate(function () ***REMOVED***
        isDisposed = true;
      ***REMOVED***));
    ***REMOVED***);
  ***REMOVED***;


  Enumerable.prototype.catchErrorWhen = function (notificationHandler) ***REMOVED***
    var sources = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var e;

      var exceptions = new Subject();

      var handled = notificationHandler(exceptions);

      var notifier = new Subject();

      var notificationDisposable = handled.subscribe(notifier);

      try ***REMOVED***
        e = sources[$iterator$]();
      ***REMOVED*** catch (err) ***REMOVED***
        observer.onError(err);
        return;
      ***REMOVED***

      var isDisposed,
        lastException,
        subscription = new SerialDisposable();
      var cancelable = immediateScheduler.scheduleRecursive(function (self) ***REMOVED***
        if (isDisposed) ***REMOVED*** return; ***REMOVED***

        var currentItem;
        try ***REMOVED***
          currentItem = e.next();
        ***REMOVED*** catch (ex) ***REMOVED***
          observer.onError(ex);
          return;
        ***REMOVED***

        if (currentItem.done) ***REMOVED***
          if (lastException) ***REMOVED***
            observer.onError(lastException);
          ***REMOVED*** else ***REMOVED***
            observer.onCompleted();
          ***REMOVED***
          return;
        ***REMOVED***

        // Check if promise
        var currentValue = currentItem.value;
        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

        var outer = new SingleAssignmentDisposable();
        var inner = new SingleAssignmentDisposable();
        subscription.setDisposable(new CompositeDisposable(inner, outer));
        outer.setDisposable(currentValue.subscribe(
          observer.onNext.bind(observer),
          function (exn) ***REMOVED***
            inner.setDisposable(notifier.subscribe(function()***REMOVED***
              self();
            ***REMOVED***, function(ex) ***REMOVED***
              observer.onError(ex);
            ***REMOVED***, function() ***REMOVED***
              observer.onCompleted();
            ***REMOVED***));

            exceptions.onNext(exn);
          ***REMOVED***,
          observer.onCompleted.bind(observer)));
      ***REMOVED***);

      return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function () ***REMOVED***
        isDisposed = true;
      ***REMOVED***));
    ***REMOVED***);
  ***REMOVED***;

  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) ***REMOVED***
    if (repeatCount == null) ***REMOVED*** repeatCount = -1; ***REMOVED***
    return new Enumerable(function () ***REMOVED***
      var left = repeatCount;
      return new Enumerator(function () ***REMOVED***
        if (left === 0) ***REMOVED*** return doneEnumerator; ***REMOVED***
        if (left > 0) ***REMOVED*** left--; ***REMOVED***
        return ***REMOVED*** done: false, value: value ***REMOVED***;
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***;

  var enumerableOf = Enumerable.of = function (source, selector, thisArg) ***REMOVED***
    selector || (selector = identity);
    return new Enumerable(function () ***REMOVED***
      var index = -1;
      return new Enumerator(
        function () ***REMOVED***
          return ++index < source.length ?
            ***REMOVED*** done: false, value: selector.call(thisArg, source[index], index, source) ***REMOVED*** :
            doneEnumerator;
        ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***;
