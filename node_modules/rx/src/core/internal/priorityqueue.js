  // Collections
  function IndexedItem(id, value) ***REMOVED***
    this.id = id;
    this.value = value;
  ***REMOVED***

  IndexedItem.prototype.compareTo = function (other) ***REMOVED***
    var c = this.value.compareTo(other.value);
    c === 0 && (c = this.id - other.id);
    return c;
  ***REMOVED***;

  // Priority Queue for Scheduling
  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) ***REMOVED***
    this.items = new Array(capacity);
    this.length = 0;
  ***REMOVED***;

  var priorityProto = PriorityQueue.prototype;
  priorityProto.isHigherPriority = function (left, right) ***REMOVED***
    return this.items[left].compareTo(this.items[right]) < 0;
  ***REMOVED***;

  priorityProto.percolate = function (index) ***REMOVED***
    if (index >= this.length || index < 0) ***REMOVED*** return; ***REMOVED***
    var parent = index - 1 >> 1;
    if (parent < 0 || parent === index) ***REMOVED*** return; ***REMOVED***
    if (this.isHigherPriority(index, parent)) ***REMOVED***
      var temp = this.items[index];
      this.items[index] = this.items[parent];
      this.items[parent] = temp;
      this.percolate(parent);
    ***REMOVED***
  ***REMOVED***;

  priorityProto.heapify = function (index) ***REMOVED***
    +index || (index = 0);
    if (index >= this.length || index < 0) ***REMOVED*** return; ***REMOVED***
    var left = 2 * index + 1,
        right = 2 * index + 2,
        first = index;
    if (left < this.length && this.isHigherPriority(left, first)) ***REMOVED***
      first = left;
    ***REMOVED***
    if (right < this.length && this.isHigherPriority(right, first)) ***REMOVED***
      first = right;
    ***REMOVED***
    if (first !== index) ***REMOVED***
      var temp = this.items[index];
      this.items[index] = this.items[first];
      this.items[first] = temp;
      this.heapify(first);
    ***REMOVED***
  ***REMOVED***;

  priorityProto.peek = function () ***REMOVED*** return this.items[0].value; ***REMOVED***;

  priorityProto.removeAt = function (index) ***REMOVED***
    this.items[index] = this.items[--this.length];
    delete this.items[this.length];
    this.heapify();
  ***REMOVED***;

  priorityProto.dequeue = function () ***REMOVED***
    var result = this.peek();
    this.removeAt(0);
    return result;
  ***REMOVED***;

  priorityProto.enqueue = function (item) ***REMOVED***
    var index = this.length++;
    this.items[index] = new IndexedItem(PriorityQueue.count++, item);
    this.percolate(index);
  ***REMOVED***;

  priorityProto.remove = function (item) ***REMOVED***
    for (var i = 0; i < this.length; i++) ***REMOVED***
      if (this.items[i].value === item) ***REMOVED***
        this.removeAt(i);
        return true;
      ***REMOVED***
    ***REMOVED***
    return false;
  ***REMOVED***;
  PriorityQueue.count = 0;
