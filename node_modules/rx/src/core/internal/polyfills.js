  // Utilities
  if (!Function.prototype.bind) ***REMOVED***
    Function.prototype.bind = function (that) ***REMOVED***
      var target = this,
        args = slice.call(arguments, 1);
      var bound = function () ***REMOVED***
        if (this instanceof bound) ***REMOVED***
          function F() ***REMOVED*** ***REMOVED***
          F.prototype = target.prototype;
          var self = new F();
          var result = target.apply(self, args.concat(slice.call(arguments)));
          if (Object(result) === result) ***REMOVED***
            return result;
          ***REMOVED***
          return self;
        ***REMOVED*** else ***REMOVED***
          return target.apply(that, args.concat(slice.call(arguments)));
        ***REMOVED***
      ***REMOVED***;

      return bound;
    ***REMOVED***;
  ***REMOVED***

  if (!Array.prototype.forEach) ***REMOVED***
    Array.prototype.forEach = function (callback, thisArg) ***REMOVED***
      var T, k;

      if (this == null) ***REMOVED***
        throw new TypeError(" this is null or not defined");
      ***REMOVED***

      var O = Object(this);
      var len = O.length >>> 0;

      if (typeof callback !== "function") ***REMOVED***
        throw new TypeError(callback + " is not a function");
      ***REMOVED***

      if (arguments.length > 1) ***REMOVED***
        T = thisArg;
      ***REMOVED***

      k = 0;
      while (k < len) ***REMOVED***
        var kValue;
        if (k in O) ***REMOVED***
          kValue = O[k];
          callback.call(T, kValue, k, O);
        ***REMOVED***
        k++;
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***

  var boxedString = Object("a"),
      splitString = boxedString[0] != "a" || !(0 in boxedString);
  if (!Array.prototype.every) ***REMOVED***
    Array.prototype.every = function every(fun /*, thisp */) ***REMOVED***
      var object = Object(this),
        self = splitString && ***REMOVED******REMOVED***.toString.call(this) == stringClass ?
          this.split("") :
          object,
        length = self.length >>> 0,
        thisp = arguments[1];

      if (***REMOVED******REMOVED***.toString.call(fun) != funcClass) ***REMOVED***
        throw new TypeError(fun + " is not a function");
      ***REMOVED***

      for (var i = 0; i < length; i++) ***REMOVED***
        if (i in self && !fun.call(thisp, self[i], i, object)) ***REMOVED***
          return false;
        ***REMOVED***
      ***REMOVED***
      return true;
    ***REMOVED***;
  ***REMOVED***

  if (!Array.prototype.map) ***REMOVED***
    Array.prototype.map = function map(fun /*, thisp*/) ***REMOVED***
      var object = Object(this),
        self = splitString && ***REMOVED******REMOVED***.toString.call(this) == stringClass ?
            this.split("") :
            object,
        length = self.length >>> 0,
        result = Array(length),
        thisp = arguments[1];

      if (***REMOVED******REMOVED***.toString.call(fun) != funcClass) ***REMOVED***
        throw new TypeError(fun + " is not a function");
      ***REMOVED***

      for (var i = 0; i < length; i++) ***REMOVED***
        if (i in self) ***REMOVED***
          result[i] = fun.call(thisp, self[i], i, object);
        ***REMOVED***
      ***REMOVED***
      return result;
    ***REMOVED***;
  ***REMOVED***

  if (!Array.prototype.filter) ***REMOVED***
    Array.prototype.filter = function (predicate) ***REMOVED***
      var results = [], item, t = new Object(this);
      for (var i = 0, len = t.length >>> 0; i < len; i++) ***REMOVED***
        item = t[i];
        if (i in t && predicate.call(arguments[1], item, i, t)) ***REMOVED***
          results.push(item);
        ***REMOVED***
      ***REMOVED***
      return results;
    ***REMOVED***;
  ***REMOVED***

  if (!Array.isArray) ***REMOVED***
    Array.isArray = function (arg) ***REMOVED***
      return ***REMOVED******REMOVED***.toString.call(arg) == arrayClass;
    ***REMOVED***;
  ***REMOVED***

  if (!Array.prototype.indexOf) ***REMOVED***
    Array.prototype.indexOf = function indexOf(searchElement) ***REMOVED***
      var t = Object(this);
      var len = t.length >>> 0;
      if (len === 0) ***REMOVED***
        return -1;
      ***REMOVED***
      var n = 0;
      if (arguments.length > 1) ***REMOVED***
        n = Number(arguments[1]);
        if (n !== n) ***REMOVED***
          n = 0;
        ***REMOVED*** else if (n !== 0 && n != Infinity && n !== -Infinity) ***REMOVED***
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        ***REMOVED***
      ***REMOVED***
      if (n >= len) ***REMOVED***
        return -1;
      ***REMOVED***
      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
      for (; k < len; k++) ***REMOVED***
        if (k in t && t[k] === searchElement) ***REMOVED***
          return k;
        ***REMOVED***
      ***REMOVED***
      return -1;
    ***REMOVED***;
  ***REMOVED***

  // Fix for Tessel
  if (!Object.prototype.propertyIsEnumerable) ***REMOVED***
    Object.prototype.propertyIsEnumerable = function (key) ***REMOVED***
      for (var k in this) ***REMOVED*** if (k === key) ***REMOVED*** return true; ***REMOVED*** ***REMOVED***
      return false;
    ***REMOVED***;
  ***REMOVED***

  if (!Object.keys) ***REMOVED***
    Object.keys = (function() ***REMOVED***
      'use strict';
      var hasOwnProperty = Object.prototype.hasOwnProperty,
      hasDontEnumBug = !(***REMOVED*** toString: null ***REMOVED***).propertyIsEnumerable('toString');

      return function(obj) ***REMOVED***
        if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) ***REMOVED***
          throw new TypeError('Object.keys called on non-object');
        ***REMOVED***

        var result = [], prop, i;

        for (prop in obj) ***REMOVED***
          if (hasOwnProperty.call(obj, prop)) ***REMOVED***
            result.push(prop);
          ***REMOVED***
        ***REMOVED***

        if (hasDontEnumBug) ***REMOVED***
          for (i = 0; i < dontEnumsLength; i++) ***REMOVED***
            if (hasOwnProperty.call(obj, dontEnums[i])) ***REMOVED***
              result.push(dontEnums[i]);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
        return result;
      ***REMOVED***;
    ***REMOVED***());
  ***REMOVED***
