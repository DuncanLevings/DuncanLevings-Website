  var CatchScheduler = (function (__super__) ***REMOVED***

    function scheduleNow(state, action) ***REMOVED***
      return this._scheduler.scheduleWithState(state, this._wrap(action));
    ***REMOVED***

    function scheduleRelative(state, dueTime, action) ***REMOVED***
      return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
    ***REMOVED***

    function scheduleAbsolute(state, dueTime, action) ***REMOVED***
      return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
    ***REMOVED***

    inherits(CatchScheduler, __super__);

    function CatchScheduler(scheduler, handler) ***REMOVED***
      this._scheduler = scheduler;
      this._handler = handler;
      this._recursiveOriginal = null;
      this._recursiveWrapper = null;
      __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
    ***REMOVED***

    CatchScheduler.prototype._clone = function (scheduler) ***REMOVED***
        return new CatchScheduler(scheduler, this._handler);
    ***REMOVED***;

    CatchScheduler.prototype._wrap = function (action) ***REMOVED***
      var parent = this;
      return function (self, state) ***REMOVED***
        try ***REMOVED***
          return action(parent._getRecursiveWrapper(self), state);
        ***REMOVED*** catch (e) ***REMOVED***
          if (!parent._handler(e)) ***REMOVED*** throw e; ***REMOVED***
          return disposableEmpty;
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***;

    CatchScheduler.prototype._getRecursiveWrapper = function (scheduler) ***REMOVED***
      if (this._recursiveOriginal !== scheduler) ***REMOVED***
        this._recursiveOriginal = scheduler;
        var wrapper = this._clone(scheduler);
        wrapper._recursiveOriginal = scheduler;
        wrapper._recursiveWrapper = wrapper;
        this._recursiveWrapper = wrapper;
      ***REMOVED***
      return this._recursiveWrapper;
    ***REMOVED***;

    CatchScheduler.prototype.schedulePeriodicWithState = function (state, period, action) ***REMOVED***
      var self = this, failed = false, d = new SingleAssignmentDisposable();

      d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function (state1) ***REMOVED***
        if (failed) ***REMOVED*** return null; ***REMOVED***
        try ***REMOVED***
          return action(state1);
        ***REMOVED*** catch (e) ***REMOVED***
          failed = true;
          if (!self._handler(e)) ***REMOVED*** throw e; ***REMOVED***
          d.dispose();
          return null;
        ***REMOVED***
      ***REMOVED***));

      return d;
    ***REMOVED***;

    return CatchScheduler;
  ***REMOVED***(Scheduler));
