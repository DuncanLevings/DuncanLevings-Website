// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

;(function (factory) ***REMOVED***
    var objectTypes = ***REMOVED***
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    ***REMOVED***;

    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;

    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) ***REMOVED***
        root = freeGlobal;
    ***REMOVED***

    // Because of build optimizers
    if (typeof define === 'function' && define.amd) ***REMOVED***
        define(['rx'], function (Rx, exports) ***REMOVED***
            return factory(root, exports, Rx);
        ***REMOVED***);
    ***REMOVED*** else if (typeof module === 'object' && module && module.exports === freeExports) ***REMOVED***
        module.exports = factory(root, module.exports, require('./rx'));
    ***REMOVED*** else ***REMOVED***
        root.Rx = factory(root, ***REMOVED******REMOVED***, root.Rx);
    ***REMOVED***
***REMOVED***.call(this, function (root, exp, Rx, undefined) ***REMOVED***

  // References
  var Observable = Rx.Observable,
    observableProto = Observable.prototype,
    AnonymousObservable = Rx.AnonymousObservable,
    AbstractObserver = Rx.internals.AbstractObserver,
    CompositeDisposable = Rx.CompositeDisposable,
    Subject = Rx.Subject,
    Observer = Rx.Observer,
    disposableEmpty = Rx.Disposable.empty,
    disposableCreate = Rx.Disposable.create,
    inherits = Rx.internals.inherits,
    addProperties = Rx.internals.addProperties,
    timeoutScheduler = Rx.Scheduler.timeout,
    currentThreadScheduler = Rx.Scheduler.currentThread,
    identity = Rx.helpers.identity;

  var objectDisposed = 'Object has been disposed';
  function checkDisposed() ***REMOVED*** if (this.isDisposed) ***REMOVED*** throw new Error(objectDisposed); ***REMOVED*** ***REMOVED***

  /**
  * Used to pause and resume streams.
  */
  Rx.Pauser = (function (__super__) ***REMOVED***
    inherits(Pauser, __super__);

    function Pauser() ***REMOVED***
      __super__.call(this);
    ***REMOVED***

    /**
     * Pauses the underlying sequence.
     */
    Pauser.prototype.pause = function () ***REMOVED*** this.onNext(false); ***REMOVED***;

    /**
    * Resumes the underlying sequence.
    */
    Pauser.prototype.resume = function () ***REMOVED*** this.onNext(true); ***REMOVED***;

    return Pauser;
  ***REMOVED***(Subject));

  var PausableObservable = (function (__super__) ***REMOVED***

    inherits(PausableObservable, __super__);

    function subscribe(observer) ***REMOVED***
      var conn = this.source.publish(),
        subscription = conn.subscribe(observer),
        connection = disposableEmpty;

      var pausable = this.pauser.distinctUntilChanged().subscribe(function (b) ***REMOVED***
        if (b) ***REMOVED***
          connection = conn.connect();
        ***REMOVED*** else ***REMOVED***
          connection.dispose();
          connection = disposableEmpty;
        ***REMOVED***
      ***REMOVED***);

      return new CompositeDisposable(subscription, connection, pausable);
    ***REMOVED***

    function PausableObservable(source, pauser) ***REMOVED***
      this.source = source;
      this.controller = new Subject();

      if (pauser && pauser.subscribe) ***REMOVED***
        this.pauser = this.controller.merge(pauser);
      ***REMOVED*** else ***REMOVED***
        this.pauser = this.controller;
      ***REMOVED***

      __super__.call(this, subscribe, source);
    ***REMOVED***

    PausableObservable.prototype.pause = function () ***REMOVED***
      this.controller.onNext(false);
    ***REMOVED***;

    PausableObservable.prototype.resume = function () ***REMOVED***
      this.controller.onNext(true);
    ***REMOVED***;

    return PausableObservable;

  ***REMOVED***(Observable));

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausable(pauser);
   * @param ***REMOVED***Observable***REMOVED*** pauser The observable sequence used to pause the underlying sequence.
   * @returns ***REMOVED***Observable***REMOVED*** The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausable = function (pauser) ***REMOVED***
    return new PausableObservable(this, pauser);
  ***REMOVED***;

  function combineLatestSource(source, subject, resultSelector) ***REMOVED***
    return new AnonymousObservable(function (o) ***REMOVED***
      var hasValue = [false, false],
        hasValueAll = false,
        isDone = false,
        values = new Array(2),
        err;

      function next(x, i) ***REMOVED***
        values[i] = x
        var res;
        hasValue[i] = true;
        if (hasValueAll || (hasValueAll = hasValue.every(identity))) ***REMOVED***
          if (err) ***REMOVED***
            o.onError(err);
            return;
          ***REMOVED***

          try ***REMOVED***
            res = resultSelector.apply(null, values);
          ***REMOVED*** catch (ex) ***REMOVED***
            o.onError(ex);
            return;
          ***REMOVED***
          o.onNext(res);
        ***REMOVED***
        if (isDone && values[1]) ***REMOVED***
          o.onCompleted();
        ***REMOVED***
      ***REMOVED***

      return new CompositeDisposable(
        source.subscribe(
          function (x) ***REMOVED***
            next(x, 0);
          ***REMOVED***,
          function (e) ***REMOVED***
            if (values[1]) ***REMOVED***
              o.onError(e);
            ***REMOVED*** else ***REMOVED***
              err = e;
            ***REMOVED***
          ***REMOVED***,
          function () ***REMOVED***
            isDone = true;
            values[1] && o.onCompleted();
          ***REMOVED***),
        subject.subscribe(
          function (x) ***REMOVED***
            next(x, 1);
          ***REMOVED***,
          function (e) ***REMOVED*** o.onError(e); ***REMOVED***,
          function () ***REMOVED***
            isDone = true;
            next(true, 1);
          ***REMOVED***)
        );
    ***REMOVED***, source);
  ***REMOVED***

  var PausableBufferedObservable = (function (__super__) ***REMOVED***

    inherits(PausableBufferedObservable, __super__);

    function subscribe(o) ***REMOVED***
      var q = [], previousShouldFire;

      var subscription =
        combineLatestSource(
          this.source,
          this.pauser.distinctUntilChanged().startWith(false),
          function (data, shouldFire) ***REMOVED***
            return ***REMOVED*** data: data, shouldFire: shouldFire ***REMOVED***;
          ***REMOVED***)
          .subscribe(
            function (results) ***REMOVED***
              if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) ***REMOVED***
                previousShouldFire = results.shouldFire;
                // change in shouldFire
                if (results.shouldFire) ***REMOVED***
                  while (q.length > 0) ***REMOVED***
                    o.onNext(q.shift());
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                previousShouldFire = results.shouldFire;
                // new data
                if (results.shouldFire) ***REMOVED***
                  o.onNext(results.data);
                ***REMOVED*** else ***REMOVED***
                  q.push(results.data);
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***,
            function (err) ***REMOVED***
              // Empty buffer before sending error
              while (q.length > 0) ***REMOVED***
                o.onNext(q.shift());
              ***REMOVED***
              o.onError(err);
            ***REMOVED***,
            function () ***REMOVED***
              // Empty buffer before sending completion
              while (q.length > 0) ***REMOVED***
                o.onNext(q.shift());
              ***REMOVED***
              o.onCompleted();
            ***REMOVED***
          );
      return subscription;
    ***REMOVED***

    function PausableBufferedObservable(source, pauser) ***REMOVED***
      this.source = source;
      this.controller = new Subject();

      if (pauser && pauser.subscribe) ***REMOVED***
        this.pauser = this.controller.merge(pauser);
      ***REMOVED*** else ***REMOVED***
        this.pauser = this.controller;
      ***REMOVED***

      __super__.call(this, subscribe, source);
    ***REMOVED***

    PausableBufferedObservable.prototype.pause = function () ***REMOVED***
      this.controller.onNext(false);
    ***REMOVED***;

    PausableBufferedObservable.prototype.resume = function () ***REMOVED***
      this.controller.onNext(true);
    ***REMOVED***;

    return PausableBufferedObservable;

  ***REMOVED***(Observable));

  /**
   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,
   * and yields the values that were buffered while paused.
   * @example
   * var pauser = new Rx.Subject();
   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);
   * @param ***REMOVED***Observable***REMOVED*** pauser The observable sequence used to pause the underlying sequence.
   * @returns ***REMOVED***Observable***REMOVED*** The observable sequence which is paused based upon the pauser.
   */
  observableProto.pausableBuffered = function (subject) ***REMOVED***
    return new PausableBufferedObservable(this, subject);
  ***REMOVED***;

  var ControlledObservable = (function (__super__) ***REMOVED***

    inherits(ControlledObservable, __super__);

    function subscribe (observer) ***REMOVED***
      return this.source.subscribe(observer);
    ***REMOVED***

    function ControlledObservable (source, enableQueue) ***REMOVED***
      __super__.call(this, subscribe, source);
      this.subject = new ControlledSubject(enableQueue);
      this.source = source.multicast(this.subject).refCount();
    ***REMOVED***

    ControlledObservable.prototype.request = function (numberOfItems) ***REMOVED***
      if (numberOfItems == null) ***REMOVED*** numberOfItems = -1; ***REMOVED***
      return this.subject.request(numberOfItems);
    ***REMOVED***;

    return ControlledObservable;

  ***REMOVED***(Observable));

  var ControlledSubject = (function (__super__) ***REMOVED***

    function subscribe (observer) ***REMOVED***
      return this.subject.subscribe(observer);
    ***REMOVED***

    inherits(ControlledSubject, __super__);

    function ControlledSubject(enableQueue) ***REMOVED***
      enableQueue == null && (enableQueue = true);

      __super__.call(this, subscribe);
      this.subject = new Subject();
      this.enableQueue = enableQueue;
      this.queue = enableQueue ? [] : null;
      this.requestedCount = 0;
      this.requestedDisposable = disposableEmpty;
      this.error = null;
      this.hasFailed = false;
      this.hasCompleted = false;
      this.controlledDisposable = disposableEmpty;
    ***REMOVED***

    addProperties(ControlledSubject.prototype, Observer, ***REMOVED***
      onCompleted: function () ***REMOVED***
        this.hasCompleted = true;
        (!this.enableQueue || this.queue.length === 0) && this.subject.onCompleted();
      ***REMOVED***,
      onError: function (error) ***REMOVED***
        this.hasFailed = true;
        this.error = error;
        (!this.enableQueue || this.queue.length === 0) && this.subject.onError(error);
      ***REMOVED***,
      onNext: function (value) ***REMOVED***
        var hasRequested = false;

        if (this.requestedCount === 0) ***REMOVED***
          this.enableQueue && this.queue.push(value);
        ***REMOVED*** else ***REMOVED***
          (this.requestedCount !== -1 && this.requestedCount-- === 0) && this.disposeCurrentRequest();
          hasRequested = true;
        ***REMOVED***
        hasRequested && this.subject.onNext(value);
      ***REMOVED***,
      _processRequest: function (numberOfItems) ***REMOVED***
        if (this.enableQueue) ***REMOVED***
          while (this.queue.length >= numberOfItems && numberOfItems > 0) ***REMOVED***
            this.subject.onNext(this.queue.shift());
            numberOfItems--;
          ***REMOVED***

          return this.queue.length !== 0 ?
            ***REMOVED*** numberOfItems: numberOfItems, returnValue: true ***REMOVED*** :
            ***REMOVED*** numberOfItems: numberOfItems, returnValue: false ***REMOVED***;
        ***REMOVED***

        if (this.hasFailed) ***REMOVED***
          this.subject.onError(this.error);
          this.controlledDisposable.dispose();
          this.controlledDisposable = disposableEmpty;
        ***REMOVED*** else if (this.hasCompleted) ***REMOVED***
          this.subject.onCompleted();
          this.controlledDisposable.dispose();
          this.controlledDisposable = disposableEmpty;
        ***REMOVED***

        return ***REMOVED*** numberOfItems: numberOfItems, returnValue: false ***REMOVED***;
      ***REMOVED***,
      request: function (number) ***REMOVED***
        this.disposeCurrentRequest();
        var self = this, r = this._processRequest(number);

        var number = r.numberOfItems;
        if (!r.returnValue) ***REMOVED***
          this.requestedCount = number;
          this.requestedDisposable = disposableCreate(function () ***REMOVED***
            self.requestedCount = 0;
          ***REMOVED***);

          return this.requestedDisposable
        ***REMOVED*** else ***REMOVED***
          return disposableEmpty;
        ***REMOVED***
      ***REMOVED***,
      disposeCurrentRequest: function () ***REMOVED***
        this.requestedDisposable.dispose();
        this.requestedDisposable = disposableEmpty;
      ***REMOVED***
    ***REMOVED***);

    return ControlledSubject;
  ***REMOVED***(Observable));

  /**
   * Attaches a controller to the observable sequence with the ability to queue.
   * @example
   * var source = Rx.Observable.interval(100).controlled();
   * source.request(3); // Reads 3 values
   * @param ***REMOVED***Observable***REMOVED*** pauser The observable sequence used to pause the underlying sequence.
   * @returns ***REMOVED***Observable***REMOVED*** The observable sequence which is paused based upon the pauser.
   */
  observableProto.controlled = function (enableQueue) ***REMOVED***
    if (enableQueue == null) ***REMOVED***  enableQueue = true; ***REMOVED***
    return new ControlledObservable(this, enableQueue);
  ***REMOVED***;

  var StopAndWaitObservable = (function (__super__) ***REMOVED***

    function subscribe (observer) ***REMOVED***
      this.subscription = this.source.subscribe(new StopAndWaitObserver(observer, this, this.subscription));

      var self = this;
      timeoutScheduler.schedule(function () ***REMOVED*** self.source.request(1); ***REMOVED***);

      return this.subscription;
    ***REMOVED***

    inherits(StopAndWaitObservable, __super__);

    function StopAndWaitObservable (source) ***REMOVED***
      __super__.call(this, subscribe, source);
      this.source = source;
    ***REMOVED***

    var StopAndWaitObserver = (function (__sub__) ***REMOVED***

      inherits(StopAndWaitObserver, __sub__);

      function StopAndWaitObserver (observer, observable, cancel) ***REMOVED***
        __sub__.call(this);
        this.observer = observer;
        this.observable = observable;
        this.cancel = cancel;
      ***REMOVED***

      var stopAndWaitObserverProto = StopAndWaitObserver.prototype;

      stopAndWaitObserverProto.completed = function () ***REMOVED***
        this.observer.onCompleted();
        this.dispose();
      ***REMOVED***;

      stopAndWaitObserverProto.error = function (error) ***REMOVED***
        this.observer.onError(error);
        this.dispose();
      ***REMOVED***

      stopAndWaitObserverProto.next = function (value) ***REMOVED***
        this.observer.onNext(value);

        var self = this;
        timeoutScheduler.schedule(function () ***REMOVED***
          self.observable.source.request(1);
        ***REMOVED***);
      ***REMOVED***;

      stopAndWaitObserverProto.dispose = function () ***REMOVED***
        this.observer = null;
        if (this.cancel) ***REMOVED***
          this.cancel.dispose();
          this.cancel = null;
        ***REMOVED***
        __sub__.prototype.dispose.call(this);
      ***REMOVED***;

      return StopAndWaitObserver;
    ***REMOVED***(AbstractObserver));

    return StopAndWaitObservable;
  ***REMOVED***(Observable));


  /**
   * Attaches a stop and wait observable to the current observable.
   * @returns ***REMOVED***Observable***REMOVED*** A stop and wait observable.
   */
  ControlledObservable.prototype.stopAndWait = function () ***REMOVED***
    return new StopAndWaitObservable(this);
  ***REMOVED***;

  var WindowedObservable = (function (__super__) ***REMOVED***

    function subscribe (observer) ***REMOVED***
      this.subscription = this.source.subscribe(new WindowedObserver(observer, this, this.subscription));

      var self = this;
      timeoutScheduler.schedule(function () ***REMOVED***
        self.source.request(self.windowSize);
      ***REMOVED***);

      return this.subscription;
    ***REMOVED***

    inherits(WindowedObservable, __super__);

    function WindowedObservable(source, windowSize) ***REMOVED***
      __super__.call(this, subscribe, source);
      this.source = source;
      this.windowSize = windowSize;
    ***REMOVED***

    var WindowedObserver = (function (__sub__) ***REMOVED***

      inherits(WindowedObserver, __sub__);

      function WindowedObserver(observer, observable, cancel) ***REMOVED***
        this.observer = observer;
        this.observable = observable;
        this.cancel = cancel;
        this.received = 0;
      ***REMOVED***

      var windowedObserverPrototype = WindowedObserver.prototype;

      windowedObserverPrototype.completed = function () ***REMOVED***
        this.observer.onCompleted();
        this.dispose();
      ***REMOVED***;

      windowedObserverPrototype.error = function (error) ***REMOVED***
        this.observer.onError(error);
        this.dispose();
      ***REMOVED***;

      windowedObserverPrototype.next = function (value) ***REMOVED***
        this.observer.onNext(value);

        this.received = ++this.received % this.observable.windowSize;
        if (this.received === 0) ***REMOVED***
          var self = this;
          timeoutScheduler.schedule(function () ***REMOVED***
            self.observable.source.request(self.observable.windowSize);
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***;

      windowedObserverPrototype.dispose = function () ***REMOVED***
        this.observer = null;
        if (this.cancel) ***REMOVED***
          this.cancel.dispose();
          this.cancel = null;
        ***REMOVED***
        __sub__.prototype.dispose.call(this);
      ***REMOVED***;

      return WindowedObserver;
    ***REMOVED***(AbstractObserver));

    return WindowedObservable;
  ***REMOVED***(Observable));

  /**
   * Creates a sliding windowed observable based upon the window size.
   * @param ***REMOVED***Number***REMOVED*** windowSize The number of items in the window
   * @returns ***REMOVED***Observable***REMOVED*** A windowed observable based upon the window size.
   */
  ControlledObservable.prototype.windowed = function (windowSize) ***REMOVED***
    return new WindowedObservable(this, windowSize);
  ***REMOVED***;

    return Rx;
***REMOVED***));
