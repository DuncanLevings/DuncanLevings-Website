// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

;(function (factory) ***REMOVED***
    var objectTypes = ***REMOVED***
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    ***REMOVED***;

    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;

    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) ***REMOVED***
        root = freeGlobal;
    ***REMOVED***

    // Because of build optimizers
    if (typeof define === 'function' && define.amd) ***REMOVED***
        define(['rx.binding', 'exports'], function (Rx, exports) ***REMOVED***
            root.Rx = factory(root, exports, Rx);
            return root.Rx;
        ***REMOVED***);
    ***REMOVED*** else if (typeof module === 'object' && module && module.exports === freeExports) ***REMOVED***
        module.exports = factory(root, module.exports, require('./rx'));
    ***REMOVED*** else ***REMOVED***
        root.Rx = factory(root, ***REMOVED******REMOVED***, root.Rx);
    ***REMOVED***
***REMOVED***.call(this, function (root, exp, Rx, undefined) ***REMOVED***

  // Aliases
  var Observable = Rx.Observable,
    observableProto = Observable.prototype,
    observableFromPromise = Observable.fromPromise,
    observableThrow = Observable.throwException,
    AnonymousObservable = Rx.AnonymousObservable,
    AsyncSubject = Rx.AsyncSubject,
    disposableCreate = Rx.Disposable.create,
    CompositeDisposable = Rx.CompositeDisposable,
    immediateScheduler = Rx.Scheduler.immediate,
    timeoutScheduler = Rx.Scheduler.timeout,
    isScheduler = Rx.helpers.isScheduler,
    slice = Array.prototype.slice;

  var fnString = 'function',
      throwString = 'throw',
      isObject = Rx.internals.isObject;

  function toThunk(obj, ctx) ***REMOVED***
    if (Array.isArray(obj)) ***REMOVED***  return objectToThunk.call(ctx, obj); ***REMOVED***
    if (isGeneratorFunction(obj)) ***REMOVED*** return observableSpawn(obj.call(ctx)); ***REMOVED***
    if (isGenerator(obj)) ***REMOVED***  return observableSpawn(obj); ***REMOVED***
    if (isObservable(obj)) ***REMOVED*** return observableToThunk(obj); ***REMOVED***
    if (isPromise(obj)) ***REMOVED*** return promiseToThunk(obj); ***REMOVED***
    if (typeof obj === fnString) ***REMOVED*** return obj; ***REMOVED***
    if (isObject(obj) || Array.isArray(obj)) ***REMOVED*** return objectToThunk.call(ctx, obj); ***REMOVED***

    return obj;
  ***REMOVED***

  function objectToThunk(obj) ***REMOVED***
    var ctx = this;

    return function (done) ***REMOVED***
      var keys = Object.keys(obj),
          pending = keys.length,
          results = new obj.constructor(),
          finished;

      if (!pending) ***REMOVED***
        timeoutScheduler.schedule(function () ***REMOVED*** done(null, results); ***REMOVED***);
        return;
      ***REMOVED***

      for (var i = 0, len = keys.length; i < len; i++) ***REMOVED***
        run(obj[keys[i]], keys[i]);
      ***REMOVED***

      function run(fn, key) ***REMOVED***
        if (finished) ***REMOVED*** return; ***REMOVED***
        try ***REMOVED***
          fn = toThunk(fn, ctx);

          if (typeof fn !== fnString) ***REMOVED***
            results[key] = fn;
            return --pending || done(null, results);
          ***REMOVED***

          fn.call(ctx, function(err, res) ***REMOVED***
            if (finished) ***REMOVED*** return; ***REMOVED***

            if (err) ***REMOVED***
              finished = true;
              return done(err);
            ***REMOVED***

            results[key] = res;
            --pending || done(null, results);
          ***REMOVED***);
        ***REMOVED*** catch (e) ***REMOVED***
          finished = true;
          done(e);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function observableToThunk(observable) ***REMOVED***
    return function (fn) ***REMOVED***
      var value, hasValue = false;
      observable.subscribe(
        function (v) ***REMOVED***
          value = v;
          hasValue = true;
        ***REMOVED***,
        fn,
        function () ***REMOVED***
          hasValue && fn(null, value);
        ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  function promiseToThunk(promise) ***REMOVED***
    return function(fn) ***REMOVED***
      promise.then(function(res) ***REMOVED***
        fn(null, res);
      ***REMOVED***, fn);
    ***REMOVED***
  ***REMOVED***

  function isObservable(obj) ***REMOVED***
    return obj && typeof obj.subscribe === fnString;
  ***REMOVED***

  function isGeneratorFunction(obj) ***REMOVED***
    return obj && obj.constructor && obj.constructor.name === 'GeneratorFunction';
  ***REMOVED***

  function isGenerator(obj) ***REMOVED***
    return obj && typeof obj.next === fnString && typeof obj[throwString] === fnString;
  ***REMOVED***

  /*
   * Spawns a generator function which allows for Promises, Observable sequences, Arrays, Objects, Generators and functions.
   * @param ***REMOVED***Function***REMOVED*** The spawning function.
   * @returns ***REMOVED***Function***REMOVED*** a function which has a done continuation.
   */
  var observableSpawn = Rx.spawn = function (fn) ***REMOVED***
    var isGenFun = isGeneratorFunction(fn);

    return function (done) ***REMOVED***
      var ctx = this,
        gen = fn;

      if (isGenFun) ***REMOVED***
        var args = slice.call(arguments),
          len = args.length,
          hasCallback = len && typeof args[len - 1] === fnString;

        done = hasCallback ? args.pop() : handleError;
        gen = fn.apply(this, args);
      ***REMOVED*** else ***REMOVED***
        done = done || handleError;
      ***REMOVED***

      next();

      function exit(err, res) ***REMOVED***
        timeoutScheduler.schedule(done.bind(ctx, err, res));
      ***REMOVED***

      function next(err, res) ***REMOVED***
        var ret;

        // multiple args
        if (arguments.length > 2) ***REMOVED***
          res = slice.call(arguments, 1);
        ***REMOVED***

        if (err) ***REMOVED***
          try ***REMOVED***
            ret = gen[throwString](err);
          ***REMOVED*** catch (e) ***REMOVED***
            return exit(e);
          ***REMOVED***
        ***REMOVED***

        if (!err) ***REMOVED***
          try ***REMOVED***
            ret = gen.next(res);
          ***REMOVED*** catch (e) ***REMOVED***
            return exit(e);
          ***REMOVED***
        ***REMOVED***

        if (ret.done)  ***REMOVED***
          return exit(null, ret.value);
        ***REMOVED***

        ret.value = toThunk(ret.value, ctx);

        if (typeof ret.value === fnString) ***REMOVED***
          var called = false;
          try ***REMOVED***
            ret.value.call(ctx, function() ***REMOVED***
              if (called) ***REMOVED***
                return;
              ***REMOVED***

              called = true;
              next.apply(ctx, arguments);
            ***REMOVED***);
          ***REMOVED*** catch (e) ***REMOVED***
            timeoutScheduler.schedule(function () ***REMOVED***
              if (called) ***REMOVED***
                return;
              ***REMOVED***

              called = true;
              next.call(ctx, e);
            ***REMOVED***);
          ***REMOVED***
          return;
        ***REMOVED***

        // Not supported
        next(new TypeError('Rx.spawn only supports a function, Promise, Observable, Object or Array.'));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  function handleError(err) ***REMOVED***
    if (!err) ***REMOVED*** return; ***REMOVED***
    timeoutScheduler.schedule(function() ***REMOVED***
      throw err;
    ***REMOVED***);
  ***REMOVED***

  /**
   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.
   *
   * @example
   * var res = Rx.Observable.start(function () ***REMOVED*** console.log('hello'); ***REMOVED***);
   * var res = Rx.Observable.start(function () ***REMOVED*** console.log('hello'); ***REMOVED***, Rx.Scheduler.timeout);
   * var res = Rx.Observable.start(function () ***REMOVED*** this.log('hello'); ***REMOVED***, Rx.Scheduler.timeout, console);
   *
   * @param ***REMOVED***Function***REMOVED*** func Function to run asynchronously.
   * @param ***REMOVED***Scheduler***REMOVED*** [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence exposing the function's result value, or an exception.
   *
   * Remarks
   * * The function is called immediately, not during the subscription of the resulting sequence.
   * * Multiple subscriptions to the resulting sequence can observe the function's result.
   */
  Observable.start = function (func, context, scheduler) ***REMOVED***
    return observableToAsync(func, context, scheduler)();
  ***REMOVED***;

  /**
   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.
   * @param ***REMOVED***Function***REMOVED*** function Function to convert to an asynchronous function.
   * @param ***REMOVED***Scheduler***REMOVED*** [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
   * @param ***REMOVED***Mixed***REMOVED*** [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @returns ***REMOVED***Function***REMOVED*** Asynchronous function.
   */
  var observableToAsync = Observable.toAsync = function (func, context, scheduler) ***REMOVED***
    isScheduler(scheduler) || (scheduler = timeoutScheduler);
    return function () ***REMOVED***
      var args = arguments,
        subject = new AsyncSubject();

      scheduler.schedule(function () ***REMOVED***
        var result;
        try ***REMOVED***
          result = func.apply(context, args);
        ***REMOVED*** catch (e) ***REMOVED***
          subject.onError(e);
          return;
        ***REMOVED***
        subject.onNext(result);
        subject.onCompleted();
      ***REMOVED***);
      return subject.asObservable();
    ***REMOVED***;
  ***REMOVED***;

  /**
   * Converts a callback function to an observable sequence.
   *
   * @param ***REMOVED***Function***REMOVED*** function Function with a callback as the last parameter to convert to an Observable sequence.
   * @param ***REMOVED***Mixed***REMOVED*** [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param ***REMOVED***Function***REMOVED*** [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.
   * @returns ***REMOVED***Function***REMOVED*** A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.
   */
  Observable.fromCallback = function (func, context, selector) ***REMOVED***
    return function () ***REMOVED***
      var args = slice.call(arguments, 0);

      return new AnonymousObservable(function (observer) ***REMOVED***
        function handler() ***REMOVED***
          var results = arguments;

          if (selector) ***REMOVED***
            try ***REMOVED***
              results = selector(results);
            ***REMOVED*** catch (err) ***REMOVED***
              observer.onError(err);
              return;
            ***REMOVED***

            observer.onNext(results);
          ***REMOVED*** else ***REMOVED***
            if (results.length <= 1) ***REMOVED***
              observer.onNext.apply(observer, results);
            ***REMOVED*** else ***REMOVED***
              observer.onNext(results);
            ***REMOVED***
          ***REMOVED***

          observer.onCompleted();
        ***REMOVED***

        args.push(handler);
        func.apply(context, args);
      ***REMOVED***).publishLast().refCount();
    ***REMOVED***;
  ***REMOVED***;

  /**
   * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.
   * @param ***REMOVED***Function***REMOVED*** func The function to call
   * @param ***REMOVED***Mixed***REMOVED*** [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param ***REMOVED***Function***REMOVED*** [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.
   * @returns ***REMOVED***Function***REMOVED*** An async function which when applied, returns an observable sequence with the callback arguments as an array.
   */
  Observable.fromNodeCallback = function (func, context, selector) ***REMOVED***
    return function () ***REMOVED***
      var args = slice.call(arguments, 0);

      return new AnonymousObservable(function (observer) ***REMOVED***
        function handler(err) ***REMOVED***
          if (err) ***REMOVED***
            observer.onError(err);
            return;
          ***REMOVED***

          var results = slice.call(arguments, 1);

          if (selector) ***REMOVED***
            try ***REMOVED***
              results = selector(results);
            ***REMOVED*** catch (e) ***REMOVED***
              observer.onError(e);
              return;
            ***REMOVED***
            observer.onNext(results);
          ***REMOVED*** else ***REMOVED***
            if (results.length <= 1) ***REMOVED***
              observer.onNext.apply(observer, results);
            ***REMOVED*** else ***REMOVED***
              observer.onNext(results);
            ***REMOVED***
          ***REMOVED***

          observer.onCompleted();
        ***REMOVED***

        args.push(handler);
        func.apply(context, args);
      ***REMOVED***).publishLast().refCount();
    ***REMOVED***;
  ***REMOVED***;

  function fixEvent(event) ***REMOVED***
    var stopPropagation = function () ***REMOVED***
      this.cancelBubble = true;
    ***REMOVED***;

    var preventDefault = function () ***REMOVED***
      this.bubbledKeyCode = this.keyCode;
      if (this.ctrlKey) ***REMOVED***
        try ***REMOVED***
          this.keyCode = 0;
        ***REMOVED*** catch (e) ***REMOVED*** ***REMOVED***
      ***REMOVED***
      this.defaultPrevented = true;
      this.returnValue = false;
      this.modified = true;
    ***REMOVED***;

    event || (event = root.event);
    if (!event.target) ***REMOVED***
      event.target = event.target || event.srcElement;

      if (event.type == 'mouseover') ***REMOVED***
        event.relatedTarget = event.fromElement;
      ***REMOVED***
      if (event.type == 'mouseout') ***REMOVED***
        event.relatedTarget = event.toElement;
      ***REMOVED***
      // Adding stopPropogation and preventDefault to IE
      if (!event.stopPropagation) ***REMOVED***
        event.stopPropagation = stopPropagation;
        event.preventDefault = preventDefault;
      ***REMOVED***
      // Normalize key events
      switch (event.type) ***REMOVED***
        case 'keypress':
          var c = ('charCode' in event ? event.charCode : event.keyCode);
          if (c == 10) ***REMOVED***
            c = 0;
            event.keyCode = 13;
          ***REMOVED*** else if (c == 13 || c == 27) ***REMOVED***
            c = 0;
          ***REMOVED*** else if (c == 3) ***REMOVED***
            c = 99;
          ***REMOVED***
          event.charCode = c;
          event.keyChar = event.charCode ? String.fromCharCode(event.charCode) : '';
          break;
      ***REMOVED***
    ***REMOVED***

    return event;
  ***REMOVED***

  function createListener (element, name, handler) ***REMOVED***
    // Standards compliant
    if (element.addEventListener) ***REMOVED***
      element.addEventListener(name, handler, false);
      return disposableCreate(function () ***REMOVED***
        element.removeEventListener(name, handler, false);
      ***REMOVED***);
    ***REMOVED***
    if (element.attachEvent) ***REMOVED***
      // IE Specific
      var innerHandler = function (event) ***REMOVED***
        handler(fixEvent(event));
      ***REMOVED***;
      element.attachEvent('on' + name, innerHandler);
      return disposableCreate(function () ***REMOVED***
        element.detachEvent('on' + name, innerHandler);
      ***REMOVED***);
    ***REMOVED***
    // Level 1 DOM Events
    element['on' + name] = handler;
    return disposableCreate(function () ***REMOVED***
      element['on' + name] = null;
    ***REMOVED***);
  ***REMOVED***

  function createEventListener (el, eventName, handler) ***REMOVED***
    var disposables = new CompositeDisposable();

    // Asume NodeList
    if (Object.prototype.toString.call(el) === '[object NodeList]') ***REMOVED***
      for (var i = 0, len = el.length; i < len; i++) ***REMOVED***
        disposables.add(createEventListener(el.item(i), eventName, handler));
      ***REMOVED***
    ***REMOVED*** else if (el) ***REMOVED***
      disposables.add(createListener(el, eventName, handler));
    ***REMOVED***

    return disposables;
  ***REMOVED***

  /**
   * Configuration option to determine whether to use native events only
   */
  Rx.config.useNativeEvents = false;

  /**
   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.
   *
   * @example
   *   var source = Rx.Observable.fromEvent(element, 'mouseup');
   *
   * @param ***REMOVED***Object***REMOVED*** element The DOMElement or NodeList to attach a listener.
   * @param ***REMOVED***String***REMOVED*** eventName The event name to attach the observable sequence.
   * @param ***REMOVED***Function***REMOVED*** [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence of events from the specified element and the specified event.
   */
  Observable.fromEvent = function (element, eventName, selector) ***REMOVED***
    // Node.js specific
    if (element.addListener) ***REMOVED***
      return fromEventPattern(
        function (h) ***REMOVED*** element.addListener(eventName, h); ***REMOVED***,
        function (h) ***REMOVED*** element.removeListener(eventName, h); ***REMOVED***,
        selector);
    ***REMOVED***

    // Use only if non-native events are allowed
    if (!Rx.config.useNativeEvents) ***REMOVED***
      // Handles jq, Angular.js, Zepto, Marionette
      if (typeof element.on === 'function' && typeof element.off === 'function') ***REMOVED***
        return fromEventPattern(
          function (h) ***REMOVED*** element.on(eventName, h); ***REMOVED***,
          function (h) ***REMOVED*** element.off(eventName, h); ***REMOVED***,
          selector);
      ***REMOVED***
      if (!!root.Ember && typeof root.Ember.addListener === 'function') ***REMOVED***
        return fromEventPattern(
          function (h) ***REMOVED*** Ember.addListener(element, eventName, h); ***REMOVED***,
          function (h) ***REMOVED*** Ember.removeListener(element, eventName, h); ***REMOVED***,
          selector);
        ***REMOVED***
    ***REMOVED***
    return new AnonymousObservable(function (observer) ***REMOVED***
      return createEventListener(
        element,
        eventName,
        function handler (e) ***REMOVED***
          var results = e;

          if (selector) ***REMOVED***
            try ***REMOVED***
              results = selector(arguments);
            ***REMOVED*** catch (err) ***REMOVED***
              observer.onError(err);
              return
            ***REMOVED***
          ***REMOVED***

          observer.onNext(results);
        ***REMOVED***);
    ***REMOVED***).publish().refCount();
  ***REMOVED***;

  /**
   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.
   * @param ***REMOVED***Function***REMOVED*** addHandler The function to add a handler to the emitter.
   * @param ***REMOVED***Function***REMOVED*** [removeHandler] The optional function to remove a handler from an emitter.
   * @param ***REMOVED***Function***REMOVED*** [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which wraps an event from an event emitter
   */
  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) ***REMOVED***
    return new AnonymousObservable(function (observer) ***REMOVED***
      function innerHandler (e) ***REMOVED***
        var result = e;
        if (selector) ***REMOVED***
          try ***REMOVED***
            result = selector(arguments);
          ***REMOVED*** catch (err) ***REMOVED***
            observer.onError(err);
            return;
          ***REMOVED***
        ***REMOVED***
        observer.onNext(result);
      ***REMOVED***

      var returnValue = addHandler(innerHandler);
      return disposableCreate(function () ***REMOVED***
        if (removeHandler) ***REMOVED***
          removeHandler(innerHandler, returnValue);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***).publish().refCount();
  ***REMOVED***;

  /**
   * Invokes the asynchronous function, surfacing the result through an observable sequence.
   * @param ***REMOVED***Function***REMOVED*** functionAsync Asynchronous function which returns a Promise to run.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence exposing the function's result value, or an exception.
   */
  Observable.startAsync = function (functionAsync) ***REMOVED***
    var promise;
    try ***REMOVED***
      promise = functionAsync();
    ***REMOVED*** catch (e) ***REMOVED***
      return observableThrow(e);
    ***REMOVED***
    return observableFromPromise(promise);
  ***REMOVED***

    return Rx;
***REMOVED***));
