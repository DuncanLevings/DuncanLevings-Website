// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

;(function (factory) ***REMOVED***
    var objectTypes = ***REMOVED***
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    ***REMOVED***;

    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;

    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) ***REMOVED***
        root = freeGlobal;
    ***REMOVED***

    // Because of build optimizers
    if (typeof define === 'function' && define.amd) ***REMOVED***
        define(['rx'], function (Rx, exports) ***REMOVED***
            return factory(root, exports, Rx);
        ***REMOVED***);
    ***REMOVED*** else if (typeof module === 'object' && module && module.exports === freeExports) ***REMOVED***
        module.exports = factory(root, module.exports, require('./rx'));
    ***REMOVED*** else ***REMOVED***
        root.Rx = factory(root, ***REMOVED******REMOVED***, root.Rx);
    ***REMOVED***
***REMOVED***.call(this, function (root, exp, Rx, undefined) ***REMOVED***

  // References
  var Observable = Rx.Observable,
    observableProto = Observable.prototype,
    observableNever = Observable.never,
    observableThrow = Observable.throwException,
    AnonymousObservable = Rx.AnonymousObservable,
    AnonymousObserver = Rx.AnonymousObserver,
    notificationCreateOnNext = Rx.Notification.createOnNext,
    notificationCreateOnError = Rx.Notification.createOnError,
    notificationCreateOnCompleted = Rx.Notification.createOnCompleted,
    Observer = Rx.Observer,
    Subject = Rx.Subject,
    internals = Rx.internals,
    helpers = Rx.helpers,
    ScheduledObserver = internals.ScheduledObserver,
    SerialDisposable = Rx.SerialDisposable,
    SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
    CompositeDisposable = Rx.CompositeDisposable,
    RefCountDisposable = Rx.RefCountDisposable,
    disposableEmpty = Rx.Disposable.empty,
    immediateScheduler = Rx.Scheduler.immediate,
    defaultKeySerializer = helpers.defaultKeySerializer,
    addRef = Rx.internals.addRef,
    identity = helpers.identity,
    isPromise = helpers.isPromise,
    inherits = internals.inherits,
    bindCallback = internals.bindCallback,
    noop = helpers.noop,
    isScheduler = helpers.isScheduler,
    observableFromPromise = Observable.fromPromise,
    slice = Array.prototype.slice;

  function argsOrArray(args, idx) ***REMOVED***
    return args.length === 1 && Array.isArray(args[idx]) ?
      args[idx] :
      slice.call(args);
  ***REMOVED***

  var argumentOutOfRange = 'Argument out of range';

    function ScheduledDisposable(scheduler, disposable) ***REMOVED***
        this.scheduler = scheduler;
        this.disposable = disposable;
        this.isDisposed = false;
    ***REMOVED***

    ScheduledDisposable.prototype.dispose = function () ***REMOVED***
        var parent = this;
        this.scheduler.schedule(function () ***REMOVED***
            if (!parent.isDisposed) ***REMOVED***
                parent.isDisposed = true;
                parent.disposable.dispose();
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;

    var CheckedObserver = (function (_super) ***REMOVED***
        inherits(CheckedObserver, _super);

        function CheckedObserver(observer) ***REMOVED***
            _super.call(this);
            this._observer = observer;
            this._state = 0; // 0 - idle, 1 - busy, 2 - done
        ***REMOVED***

        var CheckedObserverPrototype = CheckedObserver.prototype;

        CheckedObserverPrototype.onNext = function (value) ***REMOVED***
            this.checkAccess();
            try ***REMOVED***
                this._observer.onNext(value);
            ***REMOVED*** catch (e) ***REMOVED***
                throw e;
            ***REMOVED*** finally ***REMOVED***
                this._state = 0;
            ***REMOVED***
        ***REMOVED***;

        CheckedObserverPrototype.onError = function (err) ***REMOVED***
            this.checkAccess();
            try ***REMOVED***
                this._observer.onError(err);
            ***REMOVED*** catch (e) ***REMOVED***
                throw e;
            ***REMOVED*** finally ***REMOVED***
                this._state = 2;
            ***REMOVED***
        ***REMOVED***;

        CheckedObserverPrototype.onCompleted = function () ***REMOVED***
            this.checkAccess();
            try ***REMOVED***
                this._observer.onCompleted();
            ***REMOVED*** catch (e) ***REMOVED***
                throw e;
            ***REMOVED*** finally ***REMOVED***
                this._state = 2;
            ***REMOVED***
        ***REMOVED***;

        CheckedObserverPrototype.checkAccess = function () ***REMOVED***
            if (this._state === 1) ***REMOVED*** throw new Error('Re-entrancy detected'); ***REMOVED***
            if (this._state === 2) ***REMOVED*** throw new Error('Observer completed'); ***REMOVED***
            if (this._state === 0) ***REMOVED*** this._state = 1; ***REMOVED***
        ***REMOVED***;

        return CheckedObserver;
    ***REMOVED***(Observer));

  var ObserveOnObserver = (function (__super__) ***REMOVED***
    inherits(ObserveOnObserver, __super__);

    function ObserveOnObserver(scheduler, observer, cancel) ***REMOVED***
      __super__.call(this, scheduler, observer);
      this._cancel = cancel;
    ***REMOVED***

    ObserveOnObserver.prototype.next = function (value) ***REMOVED***
      __super__.prototype.next.call(this, value);
      this.ensureActive();
    ***REMOVED***;

    ObserveOnObserver.prototype.error = function (e) ***REMOVED***
      __super__.prototype.error.call(this, e);
      this.ensureActive();
    ***REMOVED***;

    ObserveOnObserver.prototype.completed = function () ***REMOVED***
      __super__.prototype.completed.call(this);
      this.ensureActive();
    ***REMOVED***;

    ObserveOnObserver.prototype.dispose = function () ***REMOVED***
      __super__.prototype.dispose.call(this);
      this._cancel && this._cancel.dispose();
      this._cancel = null;
    ***REMOVED***;

    return ObserveOnObserver;
  ***REMOVED***)(ScheduledObserver);

  /**
   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.
   *  If a violation is detected, an Error is thrown from the offending observer method call.
   *
   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.
   */
  Observer.prototype.checked = function () ***REMOVED*** return new CheckedObserver(this); ***REMOVED***;

  /**
   * Schedules the invocation of observer methods on the given scheduler.
   * @param ***REMOVED***Scheduler***REMOVED*** scheduler Scheduler to schedule observer messages on.
   * @returns ***REMOVED***Observer***REMOVED*** Observer whose messages are scheduled on the given scheduler.
   */
  Observer.notifyOn = function (scheduler) ***REMOVED***
    return new ObserveOnObserver(scheduler, this);
  ***REMOVED***;

  /**
  *  Creates an observer from a notification callback.
  * @param ***REMOVED***Function***REMOVED*** handler Action that handles a notification.
  * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.
  */
  Observer.fromNotifier = function (handler, thisArg) ***REMOVED***
    var handlerFunc = bindCallback(handler, thisArg, 1);
    return new AnonymousObserver(function (x) ***REMOVED***
      return handlerFunc(notificationCreateOnNext(x));
    ***REMOVED***, function (e) ***REMOVED***
      return handlerFunc(notificationCreateOnError(e));
    ***REMOVED***, function () ***REMOVED***
      return handlerFunc(notificationCreateOnCompleted());
    ***REMOVED***);
  ***REMOVED***;

  /**
  *  Creates a notification callback from an observer.
  * @returns The action that forwards its input notification to the underlying observer.
  */
  Observer.prototype.toNotifier = function () ***REMOVED***
    var observer = this;
    return function (n) ***REMOVED*** return n.accept(observer); ***REMOVED***;
  ***REMOVED***;

  /**
  *  Hides the identity of an observer.
  * @returns An observer that hides the identity of the specified observer.
  */
  Observer.prototype.asObserver = function () ***REMOVED***
    var source = this;
    return new AnonymousObserver(
      function (x) ***REMOVED*** source.onNext(x); ***REMOVED***,
      function (e) ***REMOVED*** source.onError(e); ***REMOVED***,
      function () ***REMOVED*** source.onCompleted(); ***REMOVED***
    );
  ***REMOVED***;

   /**
   *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
   *
   *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects
   *  that require to be run on a scheduler, use subscribeOn.
   *
   *  @param ***REMOVED***Scheduler***REMOVED*** scheduler Scheduler to notify observers on.
   *  @returns ***REMOVED***Observable***REMOVED*** The source sequence whose observations happen on the specified scheduler.
   */
  observableProto.observeOn = function (scheduler) ***REMOVED***
    var source = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      return source.subscribe(new ObserveOnObserver(scheduler, observer));
    ***REMOVED***, source);
  ***REMOVED***;

   /**
   *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;
   *  see the remarks section for more information on the distinction between subscribeOn and observeOn.

   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer
   *  callbacks on a scheduler, use observeOn.

   *  @param ***REMOVED***Scheduler***REMOVED*** scheduler Scheduler to perform subscription and unsubscription actions on.
   *  @returns ***REMOVED***Observable***REMOVED*** The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
   */
  observableProto.subscribeOn = function (scheduler) ***REMOVED***
    var source = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var m = new SingleAssignmentDisposable(), d = new SerialDisposable();
      d.setDisposable(m);
      m.setDisposable(scheduler.schedule(function () ***REMOVED***
        d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
      ***REMOVED***));
      return d;
    ***REMOVED***, source);
  ***REMOVED***;

  /**
   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.
   *
   * @example
   *  var res = Rx.Observable.generate(0, function (x) ***REMOVED*** return x < 10; ***REMOVED***, function (x) ***REMOVED*** return x + 1; ***REMOVED***, function (x) ***REMOVED*** return x; ***REMOVED***);
   *  var res = Rx.Observable.generate(0, function (x) ***REMOVED*** return x < 10; ***REMOVED***, function (x) ***REMOVED*** return x + 1; ***REMOVED***, function (x) ***REMOVED*** return x; ***REMOVED***, Rx.Scheduler.timeout);
   * @param ***REMOVED***Mixed***REMOVED*** initialState Initial state.
   * @param ***REMOVED***Function***REMOVED*** condition Condition to terminate generation (upon returning false).
   * @param ***REMOVED***Function***REMOVED*** iterate Iteration step function.
   * @param ***REMOVED***Function***REMOVED*** resultSelector Selector function for results produced in the sequence.
   * @param ***REMOVED***Scheduler***REMOVED*** [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.
   * @returns ***REMOVED***Observable***REMOVED*** The generated sequence.
   */
  Observable.generate = function (initialState, condition, iterate, resultSelector, scheduler) ***REMOVED***
    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
    return new AnonymousObservable(function (observer) ***REMOVED***
      var first = true, state = initialState;
      return scheduler.scheduleRecursive(function (self) ***REMOVED***
        var hasResult, result;
        try ***REMOVED***
          if (first) ***REMOVED***
            first = false;
          ***REMOVED*** else ***REMOVED***
            state = iterate(state);
          ***REMOVED***
          hasResult = condition(state);
          if (hasResult) ***REMOVED***
            result = resultSelector(state);
          ***REMOVED***
        ***REMOVED*** catch (exception) ***REMOVED***
          observer.onError(exception);
          return;
        ***REMOVED***
        if (hasResult) ***REMOVED***
          observer.onNext(result);
          self();
        ***REMOVED*** else ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***;

  /**
   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
   * @param ***REMOVED***Function***REMOVED*** resourceFactory Factory function to obtain a resource object.
   * @param ***REMOVED***Function***REMOVED*** observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence whose lifetime controls the lifetime of the dependent resource object.
   */
  Observable.using = function (resourceFactory, observableFactory) ***REMOVED***
    return new AnonymousObservable(function (observer) ***REMOVED***
      var disposable = disposableEmpty, resource, source;
      try ***REMOVED***
        resource = resourceFactory();
        resource && (disposable = resource);
        source = observableFactory(resource);
      ***REMOVED*** catch (exception) ***REMOVED***
        return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable);
      ***REMOVED***
      return new CompositeDisposable(source.subscribe(observer), disposable);
    ***REMOVED***);
  ***REMOVED***;

  /**
   * Propagates the observable sequence or Promise that reacts first.
   * @param ***REMOVED***Observable***REMOVED*** rightSource Second observable sequence or Promise.
   * @returns ***REMOVED***Observable***REMOVED*** ***REMOVED***Observable***REMOVED*** An observable sequence that surfaces either of the given sequences, whichever reacted first.
   */
  observableProto.amb = function (rightSource) ***REMOVED***
    var leftSource = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var choice,
        leftChoice = 'L', rightChoice = 'R',
        leftSubscription = new SingleAssignmentDisposable(),
        rightSubscription = new SingleAssignmentDisposable();

      isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));

      function choiceL() ***REMOVED***
        if (!choice) ***REMOVED***
          choice = leftChoice;
          rightSubscription.dispose();
        ***REMOVED***
      ***REMOVED***

      function choiceR() ***REMOVED***
        if (!choice) ***REMOVED***
          choice = rightChoice;
          leftSubscription.dispose();
        ***REMOVED***
      ***REMOVED***

      leftSubscription.setDisposable(leftSource.subscribe(function (left) ***REMOVED***
        choiceL();
        if (choice === leftChoice) ***REMOVED***
          observer.onNext(left);
        ***REMOVED***
      ***REMOVED***, function (err) ***REMOVED***
        choiceL();
        if (choice === leftChoice) ***REMOVED***
          observer.onError(err);
        ***REMOVED***
      ***REMOVED***, function () ***REMOVED***
        choiceL();
        if (choice === leftChoice) ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ***REMOVED***));

      rightSubscription.setDisposable(rightSource.subscribe(function (right) ***REMOVED***
        choiceR();
        if (choice === rightChoice) ***REMOVED***
          observer.onNext(right);
        ***REMOVED***
      ***REMOVED***, function (err) ***REMOVED***
        choiceR();
        if (choice === rightChoice) ***REMOVED***
          observer.onError(err);
        ***REMOVED***
      ***REMOVED***, function () ***REMOVED***
        choiceR();
        if (choice === rightChoice) ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ***REMOVED***));

      return new CompositeDisposable(leftSubscription, rightSubscription);
    ***REMOVED***);
  ***REMOVED***;

  /**
   * Propagates the observable sequence or Promise that reacts first.
   *
   * @example
   * var = Rx.Observable.amb(xs, ys, zs);
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence that surfaces any of the given sequences, whichever reacted first.
   */
  Observable.amb = function () ***REMOVED***
    var acc = observableNever(),
      items = argsOrArray(arguments, 0);
    function func(previous, current) ***REMOVED***
      return previous.amb(current);
    ***REMOVED***
    for (var i = 0, len = items.length; i < len; i++) ***REMOVED***
      acc = func(acc, items[i]);
    ***REMOVED***
    return acc;
  ***REMOVED***;

  /**
   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
   * @param ***REMOVED***Observable***REMOVED*** second Second observable sequence used to produce results after the first sequence terminates.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.
   */
  observableProto.onErrorResumeNext = function (second) ***REMOVED***
    if (!second) ***REMOVED*** throw new Error('Second observable is required'); ***REMOVED***
    return onErrorResumeNext([this, second]);
  ***REMOVED***;

  /**
   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
   *
   * @example
   * 1 - res = Rx.Observable.onErrorResumeNext(xs, ys, zs);
   * 1 - res = Rx.Observable.onErrorResumeNext([xs, ys, zs]);
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.
   */
  var onErrorResumeNext = Observable.onErrorResumeNext = function () ***REMOVED***
    var sources = argsOrArray(arguments, 0);
    return new AnonymousObservable(function (observer) ***REMOVED***
      var pos = 0, subscription = new SerialDisposable(),
      cancelable = immediateScheduler.scheduleRecursive(function (self) ***REMOVED***
        var current, d;
        if (pos < sources.length) ***REMOVED***
          current = sources[pos++];
          isPromise(current) && (current = observableFromPromise(current));
          d = new SingleAssignmentDisposable();
          subscription.setDisposable(d);
          d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
        ***REMOVED*** else ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ***REMOVED***);
      return new CompositeDisposable(subscription, cancelable);
    ***REMOVED***);
  ***REMOVED***;

  /**
   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.
   *
   * @example
   *  var res = xs.bufferWithCount(10);
   *  var res = xs.bufferWithCount(10, 1);
   * @param ***REMOVED***Number***REMOVED*** count Length of each buffer.
   * @param ***REMOVED***Number***REMOVED*** [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence of buffers.
   */
  observableProto.bufferWithCount = function (count, skip) ***REMOVED***
    if (typeof skip !== 'number') ***REMOVED***
      skip = count;
    ***REMOVED***
    return this.windowWithCount(count, skip).selectMany(function (x) ***REMOVED***
      return x.toArray();
    ***REMOVED***).where(function (x) ***REMOVED***
      return x.length > 0;
    ***REMOVED***);
  ***REMOVED***;

  /**
   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.
   *
   *  var res = xs.windowWithCount(10);
   *  var res = xs.windowWithCount(10, 1);
   * @param ***REMOVED***Number***REMOVED*** count Length of each window.
   * @param ***REMOVED***Number***REMOVED*** [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence of windows.
   */
  observableProto.windowWithCount = function (count, skip) ***REMOVED***
    var source = this;
    +count || (count = 0);
    Math.abs(count) === Infinity && (count = 0);
    if (count <= 0) ***REMOVED*** throw new Error(argumentOutOfRange); ***REMOVED***
    skip == null && (skip = count);
    +skip || (skip = 0);
    Math.abs(skip) === Infinity && (skip = 0);

    if (skip <= 0) ***REMOVED*** throw new Error(argumentOutOfRange); ***REMOVED***
    return new AnonymousObservable(function (observer) ***REMOVED***
      var m = new SingleAssignmentDisposable(),
        refCountDisposable = new RefCountDisposable(m),
        n = 0,
        q = [];

      function createWindow () ***REMOVED***
        var s = new Subject();
        q.push(s);
        observer.onNext(addRef(s, refCountDisposable));
      ***REMOVED***

      createWindow();

      m.setDisposable(source.subscribe(
        function (x) ***REMOVED***
          for (var i = 0, len = q.length; i < len; i++) ***REMOVED*** q[i].onNext(x); ***REMOVED***
          var c = n - count + 1;
          c >= 0 && c % skip === 0 && q.shift().onCompleted();
          ++n % skip === 0 && createWindow();
        ***REMOVED***,
        function (e) ***REMOVED***
          while (q.length > 0) ***REMOVED*** q.shift().onError(e); ***REMOVED***
          observer.onError(e);
        ***REMOVED***,
        function () ***REMOVED***
          while (q.length > 0) ***REMOVED*** q.shift().onCompleted(); ***REMOVED***
          observer.onCompleted();
        ***REMOVED***
      ));
      return refCountDisposable;
    ***REMOVED***, source);
  ***REMOVED***;

  /**
   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.
   *
   * @description
   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the
   *  source sequence, this buffer is produced on the result sequence.
   * @param ***REMOVED***Number***REMOVED*** count Number of elements to take from the end of the source sequence.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence containing a single array with the specified number of elements from the end of the source sequence.
   */
  observableProto.takeLastBuffer = function (count) ***REMOVED***
    var source = this;
    return new AnonymousObservable(function (o) ***REMOVED***
      var q = [];
      return source.subscribe(function (x) ***REMOVED***
        q.push(x);
        q.length > count && q.shift();
      ***REMOVED***, function (e) ***REMOVED*** o.onError(e); ***REMOVED***, function () ***REMOVED***
        o.onNext(q);
        o.onCompleted();
      ***REMOVED***);
    ***REMOVED***, source);
  ***REMOVED***;

    /**
     *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.
     *
     *  var res = obs = xs.defaultIfEmpty();
     *  2 - obs = xs.defaultIfEmpty(false);
     *
     * @memberOf Observable#
     * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.
     * @returns ***REMOVED***Observable***REMOVED*** An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.
     */
    observableProto.defaultIfEmpty = function (defaultValue) ***REMOVED***
      var source = this;
      defaultValue === undefined && (defaultValue = null);
      return new AnonymousObservable(function (observer) ***REMOVED***
        var found = false;
        return source.subscribe(function (x) ***REMOVED***
          found = true;
          observer.onNext(x);
        ***REMOVED***,
        function (e) ***REMOVED*** observer.onError(e); ***REMOVED***, 
        function () ***REMOVED***
          !found && observer.onNext(defaultValue);
          observer.onCompleted();
        ***REMOVED***);
      ***REMOVED***, source);
    ***REMOVED***;

  // Swap out for Array.findIndex
  function arrayIndexOfComparer(array, item, comparer) ***REMOVED***
    for (var i = 0, len = array.length; i < len; i++) ***REMOVED***
      if (comparer(array[i], item)) ***REMOVED*** return i; ***REMOVED***
    ***REMOVED***
    return -1;
  ***REMOVED***

  function HashSet(comparer) ***REMOVED***
    this.comparer = comparer;
    this.set = [];
  ***REMOVED***
  HashSet.prototype.push = function(value) ***REMOVED***
    var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
    retValue && this.set.push(value);
    return retValue;
  ***REMOVED***;

  /**
   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.
   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.
   *
   * @example
   *  var res = obs = xs.distinct();
   *  2 - obs = xs.distinct(function (x) ***REMOVED*** return x.id; ***REMOVED***);
   *  2 - obs = xs.distinct(function (x) ***REMOVED*** return x.id; ***REMOVED***, function (a,b) ***REMOVED*** return a === b; ***REMOVED***);
   * @param ***REMOVED***Function***REMOVED*** [keySelector]  A function to compute the comparison key for each element.
   * @param ***REMOVED***Function***REMOVED*** [comparer]  Used to compare items in the collection.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.
   */
  observableProto.distinct = function (keySelector, comparer) ***REMOVED***
    var source = this;
    comparer || (comparer = defaultComparer);
    return new AnonymousObservable(function (o) ***REMOVED***
      var hashSet = new HashSet(comparer);
      return source.subscribe(function (x) ***REMOVED***
        var key = x;

        if (keySelector) ***REMOVED***
          try ***REMOVED***
            key = keySelector(x);
          ***REMOVED*** catch (e) ***REMOVED***
            o.onError(e);
            return;
          ***REMOVED***
        ***REMOVED***
        hashSet.push(key) && o.onNext(x);
      ***REMOVED***,
      function (e) ***REMOVED*** o.onError(e); ***REMOVED***, function () ***REMOVED*** o.onCompleted(); ***REMOVED***);
    ***REMOVED***, this);
  ***REMOVED***;

    return Rx;
***REMOVED***));
