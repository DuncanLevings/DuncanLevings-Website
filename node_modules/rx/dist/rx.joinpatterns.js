// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

;(function (factory) ***REMOVED***
    var objectTypes = ***REMOVED***
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    ***REMOVED***;

    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;

    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) ***REMOVED***
        root = freeGlobal;
    ***REMOVED***

    // Because of build optimizers
    if (typeof define === 'function' && define.amd) ***REMOVED***
        define(['rx'], function (Rx, exports) ***REMOVED***
            return factory(root, exports, Rx);
        ***REMOVED***);
    ***REMOVED*** else if (typeof module === 'object' && module && module.exports === freeExports) ***REMOVED***
        module.exports = factory(root, module.exports, require('./rx'));
    ***REMOVED*** else ***REMOVED***
        root.Rx = factory(root, ***REMOVED******REMOVED***, root.Rx);
    ***REMOVED***
***REMOVED***.call(this, function (root, exp, Rx, undefined) ***REMOVED***

  // Aliases
  var Observable = Rx.Observable,
      observableProto = Observable.prototype,
      AnonymousObservable = Rx.AnonymousObservable,
      observableThrow = Observable.throwException,
      observerCreate = Rx.Observer.create,
      SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
      CompositeDisposable = Rx.CompositeDisposable,
      AbstractObserver = Rx.internals.AbstractObserver,
      noop = Rx.helpers.noop,
      defaultComparer = Rx.internals.isEqual,
      inherits = Rx.internals.inherits,
      Enumerable = Rx.internals.Enumerable,
      Enumerator = Rx.internals.Enumerator,
      $iterator$ = Rx.iterator,
      doneEnumerator = Rx.doneEnumerator,
      slice = Array.prototype.slice;

  // Utilities
  function argsOrArray(args, idx) ***REMOVED***
    return args.length === 1 && Array.isArray(args[idx]) ?
      args[idx] :
      slice.call(args);
  ***REMOVED***

  /** @private */
  var Map = root.Map || (function () ***REMOVED***

    function Map() ***REMOVED***
      this._keys = [];
      this._values = [];
    ***REMOVED***

    Map.prototype.get = function (key) ***REMOVED***
      var i = this._keys.indexOf(key);
      return i !== -1 ? this._values[i] : undefined;
    ***REMOVED***;

    Map.prototype.set = function (key, value) ***REMOVED***
      var i = this._keys.indexOf(key);
      i !== -1 && (this._values[i] = value);
      this._values[this._keys.push(key) - 1] = value;
    ***REMOVED***;

    Map.prototype.forEach = function (callback, thisArg) ***REMOVED***
      for (var i = 0, len = this._keys.length; i < len; i++) ***REMOVED***
        callback.call(thisArg, this._values[i], this._keys[i]);
      ***REMOVED***
    ***REMOVED***;

    return Map;
  ***REMOVED***());

  /**
   * @constructor
   * Represents a join pattern over observable sequences.
   */
  function Pattern(patterns) ***REMOVED***
    this.patterns = patterns;
  ***REMOVED***

  /**
   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.
   *  @param other Observable sequence to match in addition to the current pattern.
   *  @return ***REMOVED***Pattern***REMOVED*** Pattern object that matches when all observable sequences in the pattern have an available value.
   */
  Pattern.prototype.and = function (other) ***REMOVED***
    return new Pattern(this.patterns.concat(other));
  ***REMOVED***;

  /**
   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.
   *  @param ***REMOVED***Function***REMOVED*** selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.
   *  @return ***REMOVED***Plan***REMOVED*** Plan that produces the projected values, to be fed (with other plans) to the when operator.
   */
  Pattern.prototype.thenDo = function (selector) ***REMOVED***
    return new Plan(this, selector);
  ***REMOVED***;

  function Plan(expression, selector) ***REMOVED***
      this.expression = expression;
      this.selector = selector;
  ***REMOVED***

  Plan.prototype.activate = function (externalSubscriptions, observer, deactivate) ***REMOVED***
    var self = this;
    var joinObservers = [];
    for (var i = 0, len = this.expression.patterns.length; i < len; i++) ***REMOVED***
      joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], observer.onError.bind(observer)));
    ***REMOVED***
    var activePlan = new ActivePlan(joinObservers, function () ***REMOVED***
      var result;
      try ***REMOVED***
        result = self.selector.apply(self, arguments);
      ***REMOVED*** catch (e) ***REMOVED***
        observer.onError(e);
        return;
      ***REMOVED***
      observer.onNext(result);
    ***REMOVED***, function () ***REMOVED***
      for (var j = 0, jlen = joinObservers.length; j < jlen; j++) ***REMOVED***
        joinObservers[j].removeActivePlan(activePlan);
      ***REMOVED***
      deactivate(activePlan);
    ***REMOVED***);
    for (i = 0, len = joinObservers.length; i < len; i++) ***REMOVED***
      joinObservers[i].addActivePlan(activePlan);
    ***REMOVED***
    return activePlan;
  ***REMOVED***;

  function planCreateObserver(externalSubscriptions, observable, onError) ***REMOVED***
    var entry = externalSubscriptions.get(observable);
    if (!entry) ***REMOVED***
      var observer = new JoinObserver(observable, onError);
      externalSubscriptions.set(observable, observer);
      return observer;
    ***REMOVED***
    return entry;
  ***REMOVED***

  function ActivePlan(joinObserverArray, onNext, onCompleted) ***REMOVED***
    this.joinObserverArray = joinObserverArray;
    this.onNext = onNext;
    this.onCompleted = onCompleted;
    this.joinObservers = new Map();
    for (var i = 0, len = this.joinObserverArray.length; i < len; i++) ***REMOVED***
      var joinObserver = this.joinObserverArray[i];
      this.joinObservers.set(joinObserver, joinObserver);
    ***REMOVED***
  ***REMOVED***

  ActivePlan.prototype.dequeue = function () ***REMOVED***
    this.joinObservers.forEach(function (v) ***REMOVED*** v.queue.shift(); ***REMOVED***);
  ***REMOVED***;

  ActivePlan.prototype.match = function () ***REMOVED***
    var i, len, hasValues = true;
    for (i = 0, len = this.joinObserverArray.length; i < len; i++) ***REMOVED***
      if (this.joinObserverArray[i].queue.length === 0) ***REMOVED***
        hasValues = false;
        break;
      ***REMOVED***
    ***REMOVED***
    if (hasValues) ***REMOVED***
      var firstValues = [],
          isCompleted = false;
      for (i = 0, len = this.joinObserverArray.length; i < len; i++) ***REMOVED***
        firstValues.push(this.joinObserverArray[i].queue[0]);
        this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
      ***REMOVED***
      if (isCompleted) ***REMOVED***
        this.onCompleted();
      ***REMOVED*** else ***REMOVED***
        this.dequeue();
        var values = [];
        for (i = 0, len = firstValues.length; i < firstValues.length; i++) ***REMOVED***
          values.push(firstValues[i].value);
        ***REMOVED***
        this.onNext.apply(this, values);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  var JoinObserver = (function (__super__) ***REMOVED***

    inherits(JoinObserver, __super__);

    function JoinObserver(source, onError) ***REMOVED***
      __super__.call(this);
      this.source = source;
      this.onError = onError;
      this.queue = [];
      this.activePlans = [];
      this.subscription = new SingleAssignmentDisposable();
      this.isDisposed = false;
    ***REMOVED***

    var JoinObserverPrototype = JoinObserver.prototype;

    JoinObserverPrototype.next = function (notification) ***REMOVED***
      if (!this.isDisposed) ***REMOVED***
        if (notification.kind === 'E') ***REMOVED***
          this.onError(notification.exception);
          return;
        ***REMOVED***
        this.queue.push(notification);
        var activePlans = this.activePlans.slice(0);
        for (var i = 0, len = activePlans.length; i < len; i++) ***REMOVED***
          activePlans[i].match();
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;

    JoinObserverPrototype.error = noop;
    JoinObserverPrototype.completed = noop;

    JoinObserverPrototype.addActivePlan = function (activePlan) ***REMOVED***
      this.activePlans.push(activePlan);
    ***REMOVED***;

    JoinObserverPrototype.subscribe = function () ***REMOVED***
      this.subscription.setDisposable(this.source.materialize().subscribe(this));
    ***REMOVED***;

    JoinObserverPrototype.removeActivePlan = function (activePlan) ***REMOVED***
      this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
      this.activePlans.length === 0 && this.dispose();
    ***REMOVED***;

    JoinObserverPrototype.dispose = function () ***REMOVED***
      __super__.prototype.dispose.call(this);
      if (!this.isDisposed) ***REMOVED***
        this.isDisposed = true;
        this.subscription.dispose();
      ***REMOVED***
    ***REMOVED***;

    return JoinObserver;
  ***REMOVED*** (AbstractObserver));

  /**
   *  Creates a pattern that matches when both observable sequences have an available value.
   *
   *  @param right Observable sequence to match with the current sequence.
   *  @return ***REMOVED***Pattern***REMOVED*** Pattern object that matches when both observable sequences have an available value.
   */
  observableProto.and = function (right) ***REMOVED***
    return new Pattern([this, right]);
  ***REMOVED***;

  /**
   *  Matches when the observable sequence has an available value and projects the value.
   *
   *  @param selector Selector that will be invoked for values in the source sequence.
   *  @returns ***REMOVED***Plan***REMOVED*** Plan that produces the projected values, to be fed (with other plans) to the when operator.
   */
  observableProto.thenDo = function (selector) ***REMOVED***
    return new Pattern([this]).thenDo(selector);
  ***REMOVED***;

  /**
   *  Joins together the results from several patterns.
   *
   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.
   *  @returns ***REMOVED***Observable***REMOVED*** Observable sequence with the results form matching several patterns.
   */
  Observable.when = function () ***REMOVED***
    var plans = argsOrArray(arguments, 0);
    return new AnonymousObservable(function (observer) ***REMOVED***
      var activePlans = [],
          externalSubscriptions = new Map();
      var outObserver = observerCreate(
        observer.onNext.bind(observer),
        function (err) ***REMOVED***
          externalSubscriptions.forEach(function (v) ***REMOVED*** v.onError(err); ***REMOVED***);
          observer.onError(err);
        ***REMOVED***,
        observer.onCompleted.bind(observer)
      );
      try ***REMOVED***
        for (var i = 0, len = plans.length; i < len; i++) ***REMOVED***
          activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) ***REMOVED***
            var idx = activePlans.indexOf(activePlan);
            activePlans.splice(idx, 1);
            activePlans.length === 0 && observer.onCompleted();
          ***REMOVED***));
        ***REMOVED***
      ***REMOVED*** catch (e) ***REMOVED***
        observableThrow(e).subscribe(observer);
      ***REMOVED***
      var group = new CompositeDisposable();
      externalSubscriptions.forEach(function (joinObserver) ***REMOVED***
        joinObserver.subscribe();
        group.add(joinObserver);
      ***REMOVED***);

      return group;
    ***REMOVED***);
  ***REMOVED***;

    return Rx;
***REMOVED***));
