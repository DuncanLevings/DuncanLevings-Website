// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

;(function (factory) ***REMOVED***
    var objectTypes = ***REMOVED***
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    ***REMOVED***;

    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;

    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) ***REMOVED***
        root = freeGlobal;
    ***REMOVED***

    // Because of build optimizers
    if (typeof define === 'function' && define.amd) ***REMOVED***
        define(['rx.virtualtime', 'exports'], function (Rx, exports) ***REMOVED***
            root.Rx = factory(root, exports, Rx);
            return root.Rx;
        ***REMOVED***);
    ***REMOVED*** else if (typeof module === 'object' && module && module.exports === freeExports) ***REMOVED***
        module.exports = factory(root, module.exports, require('./rx.all'));
    ***REMOVED*** else ***REMOVED***
        root.Rx = factory(root, ***REMOVED******REMOVED***, root.Rx);
    ***REMOVED***
***REMOVED***.call(this, function (root, exp, Rx, undefined) ***REMOVED***

    // Defaults
    var Observer = Rx.Observer,
        Observable = Rx.Observable,
        Notification = Rx.Notification,
        VirtualTimeScheduler = Rx.VirtualTimeScheduler,
        Disposable = Rx.Disposable,
        disposableEmpty = Disposable.empty,
        disposableCreate = Disposable.create,
        CompositeDisposable = Rx.CompositeDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        slice = Array.prototype.slice,
        inherits = Rx.internals.inherits,
        defaultComparer = Rx.internals.isEqual;

    function argsOrArray(args, idx) ***REMOVED***
        return args.length === 1 && Array.isArray(args[idx]) ?
            args[idx] :
            slice.call(args);
    ***REMOVED***

function OnNextPredicate(predicate) ***REMOVED***
    this.predicate = predicate;
***REMOVED***;

OnNextPredicate.prototype.equals = function (other) ***REMOVED***
  if (other === this) ***REMOVED*** return true; ***REMOVED***
  if (other == null) ***REMOVED*** return false; ***REMOVED***
  if (other.kind !== 'N') ***REMOVED*** return false; ***REMOVED***
  return this.predicate(other.value);
***REMOVED***;

function OnErrorPredicate(predicate) ***REMOVED***
  this.predicate = predicate;
***REMOVED***;

OnErrorPredicate.prototype.equals = function (other) ***REMOVED***
  if (other === this) ***REMOVED*** return true; ***REMOVED***
  if (other == null) ***REMOVED*** return false; ***REMOVED***
  if (other.kind !== 'E') ***REMOVED*** return false; ***REMOVED***
  return this.predicate(other.exception);
***REMOVED***;

var ReactiveTest = Rx.ReactiveTest = ***REMOVED***
  /** Default virtual time used for creation of observable sequences in unit tests. */
  created: 100,
  /** Default virtual time used to subscribe to observable sequences in unit tests. */
  subscribed: 200,
  /** Default virtual time used to dispose subscriptions in unit tests. */
  disposed: 1000,

  /**
   * Factory method for an OnNext notification record at a given time with a given value or a predicate function.
   *
   * 1 - ReactiveTest.onNext(200, 42);
   * 2 - ReactiveTest.onNext(200, function (x) ***REMOVED*** return x.length == 2; ***REMOVED***);
   *
   * @param ticks Recorded virtual time the OnNext notification occurs.
   * @param value Recorded value stored in the OnNext notification or a predicate.
   * @return Recorded OnNext notification.
   */
  onNext: function (ticks, value) ***REMOVED***
    return typeof value === 'function' ?
      new Recorded(ticks, new OnNextPredicate(value)) :
      new Recorded(ticks, Notification.createOnNext(value));
  ***REMOVED***,
  /**
   * Factory method for an OnError notification record at a given time with a given error.
   *
   * 1 - ReactiveTest.onNext(200, new Error('error'));
   * 2 - ReactiveTest.onNext(200, function (e) ***REMOVED*** return e.message === 'error'; ***REMOVED***);
   *
   * @param ticks Recorded virtual time the OnError notification occurs.
   * @param exception Recorded exception stored in the OnError notification.
   * @return Recorded OnError notification.
   */
  onError: function (ticks, error) ***REMOVED***
    return typeof error === 'function' ?
      new Recorded(ticks, new OnErrorPredicate(error)) :
      new Recorded(ticks, Notification.createOnError(error));
  ***REMOVED***,
  /**
   * Factory method for an OnCompleted notification record at a given time.
   *
   * @param ticks Recorded virtual time the OnCompleted notification occurs.
   * @return Recorded OnCompleted notification.
   */
  onCompleted: function (ticks) ***REMOVED***
    return new Recorded(ticks, Notification.createOnCompleted());
  ***REMOVED***,
  /**
   * Factory method for a subscription record based on a given subscription and disposal time.
   *
   * @param start Virtual time indicating when the subscription was created.
   * @param end Virtual time indicating when the subscription was disposed.
   * @return Subscription object.
   */
  subscribe: function (start, end) ***REMOVED***
    return new Subscription(start, end);
  ***REMOVED***
***REMOVED***;

  /**
   * Creates a new object recording the production of the specified value at the given virtual time.
   *
   * @constructor
   * @param ***REMOVED***Number***REMOVED*** time Virtual time the value was produced on.
   * @param ***REMOVED***Mixed***REMOVED*** value Value that was produced.
   * @param ***REMOVED***Function***REMOVED*** comparer An optional comparer.
   */
  var Recorded = Rx.Recorded = function (time, value, comparer) ***REMOVED***
    this.time = time;
    this.value = value;
    this.comparer = comparer || defaultComparer;
  ***REMOVED***;

  /**
   * Checks whether the given recorded object is equal to the current instance.
   *
   * @param ***REMOVED***Recorded***REMOVED*** other Recorded object to check for equality.
   * @returns ***REMOVED***Boolean***REMOVED*** true if both objects are equal; false otherwise.
   */
  Recorded.prototype.equals = function (other) ***REMOVED***
    return this.time === other.time && this.comparer(this.value, other.value);
  ***REMOVED***;

  /**
   * Returns a string representation of the current Recorded value.
   *
   * @returns ***REMOVED***String***REMOVED*** String representation of the current Recorded value.
   */
  Recorded.prototype.toString = function () ***REMOVED***
    return this.value.toString() + '@' + this.time;
  ***REMOVED***;

  /**
   * Creates a new subscription object with the given virtual subscription and unsubscription time.
   *
   * @constructor
   * @param ***REMOVED***Number***REMOVED*** subscribe Virtual time at which the subscription occurred.
   * @param ***REMOVED***Number***REMOVED*** unsubscribe Virtual time at which the unsubscription occurred.
   */
  var Subscription = Rx.Subscription = function (start, end) ***REMOVED***
    this.subscribe = start;
    this.unsubscribe = end || Number.MAX_VALUE;
  ***REMOVED***;

  /**
   * Checks whether the given subscription is equal to the current instance.
   * @param other Subscription object to check for equality.
   * @returns ***REMOVED***Boolean***REMOVED*** true if both objects are equal; false otherwise.
   */
  Subscription.prototype.equals = function (other) ***REMOVED***
    return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;
  ***REMOVED***;

  /**
   * Returns a string representation of the current Subscription value.
   * @returns ***REMOVED***String***REMOVED*** String representation of the current Subscription value.
   */
  Subscription.prototype.toString = function () ***REMOVED***
    return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
  ***REMOVED***;

    /** @private */
    var MockDisposable = Rx.MockDisposable = function (scheduler) ***REMOVED***
        this.scheduler = scheduler;
        this.disposes = [];
        this.disposes.push(this.scheduler.clock);
    ***REMOVED***;

    /*
     * @memberOf MockDisposable#
     * @prviate
     */
    MockDisposable.prototype.dispose = function () ***REMOVED***
        this.disposes.push(this.scheduler.clock);
    ***REMOVED***;

  var MockObserver = (function (__super__) ***REMOVED***
    inherits(MockObserver, __super__);

    function MockObserver(scheduler) ***REMOVED***
      __super__.call(this);
      this.scheduler = scheduler;
      this.messages = [];
    ***REMOVED***

    var MockObserverPrototype = MockObserver.prototype;

    MockObserverPrototype.onNext = function (value) ***REMOVED***
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));
    ***REMOVED***;

    MockObserverPrototype.onError = function (exception) ***REMOVED***
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(exception)));
    ***REMOVED***;

    MockObserverPrototype.onCompleted = function () ***REMOVED***
      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));
    ***REMOVED***;

    return MockObserver;
  ***REMOVED***)(Observer);

  function MockPromise(scheduler, messages) ***REMOVED***
    var self = this;
    this.scheduler = scheduler;
    this.messages = messages;
    this.subscriptions = [];
    this.observers = [];
    for (var i = 0, len = this.messages.length; i < len; i++) ***REMOVED***
      var message = this.messages[i],
          notification = message.value;
      (function (innerNotification) ***REMOVED***
        scheduler.scheduleAbsoluteWithState(null, message.time, function () ***REMOVED***
          var obs = self.observers.slice(0);

          for (var j = 0, jLen = obs.length; j < jLen; j++) ***REMOVED***
            innerNotification.accept(obs[j]);
          ***REMOVED***
          return disposableEmpty;
        ***REMOVED***);
      ***REMOVED***)(notification);
    ***REMOVED***
  ***REMOVED***

  MockPromise.prototype.then = function (onResolved, onRejected) ***REMOVED***
    var self = this;

    this.subscriptions.push(new Subscription(this.scheduler.clock));
    var index = this.subscriptions.length - 1;

    var newPromise;

    var observer = Rx.Observer.create(
      function (x) ***REMOVED***
        var retValue = onResolved(x);
        if (retValue && typeof retValue.then === 'function') ***REMOVED***
          newPromise = retValue;
        ***REMOVED*** else ***REMOVED***
          var ticks = self.scheduler.clock;
          newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);
        ***REMOVED***
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      ***REMOVED***,
      function (err) ***REMOVED***
        onRejected(err);
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      ***REMOVED***
    );
    this.observers.push(observer);

    return newPromise || new MockPromise(this.scheduler, this.messages);
  ***REMOVED***;

  var HotObservable = (function (__super__) ***REMOVED***

    function subscribe(observer) ***REMOVED***
      var observable = this;
      this.observers.push(observer);
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      return disposableCreate(function () ***REMOVED***
        var idx = observable.observers.indexOf(observer);
        observable.observers.splice(idx, 1);
        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
      ***REMOVED***);
    ***REMOVED***

    inherits(HotObservable, __super__);

    function HotObservable(scheduler, messages) ***REMOVED***
      __super__.call(this, subscribe);
      var message, notification, observable = this;
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
      this.observers = [];
      for (var i = 0, len = this.messages.length; i < len; i++) ***REMOVED***
        message = this.messages[i];
        notification = message.value;
        (function (innerNotification) ***REMOVED***
          scheduler.scheduleAbsoluteWithState(null, message.time, function () ***REMOVED***
            var obs = observable.observers.slice(0);

            for (var j = 0, jLen = obs.length; j < jLen; j++) ***REMOVED***
              innerNotification.accept(obs[j]);
            ***REMOVED***
            return disposableEmpty;
          ***REMOVED***);
        ***REMOVED***)(notification);
      ***REMOVED***
    ***REMOVED***

    return HotObservable;
  ***REMOVED***)(Observable);

  var ColdObservable = (function (__super__) ***REMOVED***

    function subscribe(observer) ***REMOVED***
      var message, notification, observable = this;
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      var d = new CompositeDisposable();
      for (var i = 0, len = this.messages.length; i < len; i++) ***REMOVED***
        message = this.messages[i];
        notification = message.value;
        (function (innerNotification) ***REMOVED***
          d.add(observable.scheduler.scheduleRelativeWithState(null, message.time, function () ***REMOVED***
            innerNotification.accept(observer);
            return disposableEmpty;
          ***REMOVED***));
        ***REMOVED***)(notification);
      ***REMOVED***
      return disposableCreate(function () ***REMOVED***
        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
        d.dispose();
      ***REMOVED***);
    ***REMOVED***

    inherits(ColdObservable, __super__);

    function ColdObservable(scheduler, messages) ***REMOVED***
      __super__.call(this, subscribe);
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
    ***REMOVED***

    return ColdObservable;
  ***REMOVED***)(Observable);

  /** Virtual time scheduler used for testing applications and libraries built using Reactive Extensions. */
  Rx.TestScheduler = (function (__super__) ***REMOVED***
    inherits(TestScheduler, __super__);

    function baseComparer(x, y) ***REMOVED***
      return x > y ? 1 : (x < y ? -1 : 0);
    ***REMOVED***

    function TestScheduler() ***REMOVED***
      __super__.call(this, 0, baseComparer);
    ***REMOVED***

    /**
     * Schedules an action to be executed at the specified virtual time.
     *
     * @param state State passed to the action to be executed.
     * @param dueTime Absolute virtual time at which to execute the action.
     * @param action Action to be executed.
     * @return Disposable object used to cancel the scheduled action (best effort).
     */
    TestScheduler.prototype.scheduleAbsoluteWithState = function (state, dueTime, action) ***REMOVED***
      dueTime <= this.clock && (dueTime = this.clock + 1);
        return __super__.prototype.scheduleAbsoluteWithState.call(this, state, dueTime, action);
    ***REMOVED***;
    /**
     * Adds a relative virtual time to an absolute virtual time value.
     *
     * @param absolute Absolute virtual time value.
     * @param relative Relative virtual time value to add.
     * @return Resulting absolute virtual time sum value.
     */
    TestScheduler.prototype.add = function (absolute, relative) ***REMOVED***
      return absolute + relative;
    ***REMOVED***;
    /**
     * Converts the absolute virtual time value to a DateTimeOffset value.
     *
     * @param absolute Absolute virtual time value to convert.
     * @return Corresponding DateTimeOffset value.
     */
    TestScheduler.prototype.toDateTimeOffset = function (absolute) ***REMOVED***
      return new Date(absolute).getTime();
    ***REMOVED***;
    /**
     * Converts the TimeSpan value to a relative virtual time value.
     *
     * @param timeSpan TimeSpan value to convert.
     * @return Corresponding relative virtual time value.
     */
    TestScheduler.prototype.toRelative = function (timeSpan) ***REMOVED***
      return timeSpan;
    ***REMOVED***;
    /**
     * Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.
     *
     * @param create Factory method to create an observable sequence.
     * @param created Virtual time at which to invoke the factory to create an observable sequence.
     * @param subscribed Virtual time at which to subscribe to the created observable sequence.
     * @param disposed Virtual time at which to dispose the subscription.
     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.
     */
    TestScheduler.prototype.startWithTiming = function (create, created, subscribed, disposed) ***REMOVED***
      var observer = this.createObserver(), source, subscription;

      this.scheduleAbsoluteWithState(null, created, function () ***REMOVED***
        source = create();
        return disposableEmpty;
      ***REMOVED***);

      this.scheduleAbsoluteWithState(null, subscribed, function () ***REMOVED***
        subscription = source.subscribe(observer);
        return disposableEmpty;
      ***REMOVED***);

      this.scheduleAbsoluteWithState(null, disposed, function () ***REMOVED***
        subscription.dispose();
        return disposableEmpty;
      ***REMOVED***);

      this.start();

      return observer;
    ***REMOVED***;

    /**
     * Starts the test scheduler and uses the specified virtual time to dispose the subscription to the sequence obtained through the factory function.
     * Default virtual times are used for factory invocation and sequence subscription.
     *
     * @param create Factory method to create an observable sequence.
     * @param disposed Virtual time at which to dispose the subscription.
     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.
     */
    TestScheduler.prototype.startWithDispose = function (create, disposed) ***REMOVED***
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, disposed);
    ***REMOVED***;

    /**
     * Starts the test scheduler and uses default virtual times to invoke the factory function, to subscribe to the resulting sequence, and to dispose the subscription.
     *
     * @param create Factory method to create an observable sequence.
     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.
     */
    TestScheduler.prototype.startWithCreate = function (create) ***REMOVED***
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, ReactiveTest.disposed);
    ***REMOVED***;

    /**
     * Creates a hot observable using the specified timestamped notification messages either as an array or arguments.
     * @param messages Notifications to surface through the created sequence at their specified absolute virtual times.
     * @return Hot observable sequence that can be used to assert the timing of subscriptions and notifications.
     */
    TestScheduler.prototype.createHotObservable = function () ***REMOVED***
        var messages = argsOrArray(arguments, 0);
        return new HotObservable(this, messages);
    ***REMOVED***;

    /**
     * Creates a cold observable using the specified timestamped notification messages either as an array or arguments.
     * @param messages Notifications to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.
     * @return Cold observable sequence that can be used to assert the timing of subscriptions and notifications.
     */
    TestScheduler.prototype.createColdObservable = function () ***REMOVED***
        var messages = argsOrArray(arguments, 0);
        return new ColdObservable(this, messages);
    ***REMOVED***;

    /**
     * Creates a resolved promise with the given value and ticks
     * @param ***REMOVED***Number***REMOVED*** ticks The absolute time of the resolution.
     * @param ***REMOVED***Any***REMOVED*** value The value to yield at the given tick.
     * @returns ***REMOVED***MockPromise***REMOVED*** A mock Promise which fulfills with the given value.
     */
    TestScheduler.prototype.createResolvedPromise = function (ticks, value) ***REMOVED***
      return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
    ***REMOVED***;

    /**
     * Creates a rejected promise with the given reason and ticks
     * @param ***REMOVED***Number***REMOVED*** ticks The absolute time of the resolution.
     * @param ***REMOVED***Any***REMOVED*** reason The reason for rejection to yield at the given tick.
     * @returns ***REMOVED***MockPromise***REMOVED*** A mock Promise which rejects with the given reason.
     */
    TestScheduler.prototype.createRejectedPromise = function (ticks, reason) ***REMOVED***
      return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
    ***REMOVED***;

    /**
     * Creates an observer that records received notification messages and timestamps those.
     * @return Observer that can be used to assert the timing of received notifications.
     */
    TestScheduler.prototype.createObserver = function () ***REMOVED***
      return new MockObserver(this);
    ***REMOVED***;

    return TestScheduler;
  ***REMOVED***)(VirtualTimeScheduler);

    return Rx;
***REMOVED***));
