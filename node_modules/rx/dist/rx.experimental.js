// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

;(function (factory) ***REMOVED***
    var objectTypes = ***REMOVED***
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    ***REMOVED***;

    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;

    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) ***REMOVED***
        root = freeGlobal;
    ***REMOVED***

    // Because of build optimizers
    if (typeof define === 'function' && define.amd) ***REMOVED***
        define(['rx'], function (Rx, exports) ***REMOVED***
            return factory(root, exports, Rx);
        ***REMOVED***);
    ***REMOVED*** else if (typeof module === 'object' && module && module.exports === freeExports) ***REMOVED***
        module.exports = factory(root, module.exports, require('./rx'));
    ***REMOVED*** else ***REMOVED***
        root.Rx = factory(root, ***REMOVED******REMOVED***, root.Rx);
    ***REMOVED***
***REMOVED***.call(this, function (root, exp, Rx, undefined) ***REMOVED***

  // Aliases
  var Observable = Rx.Observable,
    observableProto = Observable.prototype,
    AnonymousObservable = Rx.AnonymousObservable,
    observableConcat = Observable.concat,
    observableDefer = Observable.defer,
    observableEmpty = Observable.empty,
    disposableEmpty = Rx.Disposable.empty,
    CompositeDisposable = Rx.CompositeDisposable,
    SerialDisposable = Rx.SerialDisposable,
    SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
    Enumerator = Rx.internals.Enumerator,
    Enumerable = Rx.internals.Enumerable,
    enumerableOf = Enumerable.of,
    immediateScheduler = Rx.Scheduler.immediate,
    currentThreadScheduler = Rx.Scheduler.currentThread,
    slice = Array.prototype.slice,
    AsyncSubject = Rx.AsyncSubject,
    Observer = Rx.Observer,
    inherits = Rx.internals.inherits,
    bindCallback = Rx.internals.bindCallback,
    addProperties = Rx.internals.addProperties,
    helpers = Rx.helpers,
    noop = helpers.noop,
    isPromise = helpers.isPromise,
    isScheduler = helpers.isScheduler,
    observableFromPromise = Observable.fromPromise;

  // Utilities
  function argsOrArray(args, idx) ***REMOVED***
    return args.length === 1 && Array.isArray(args[idx]) ?
      args[idx] :
      slice.call(args);
  ***REMOVED***

  // Shim in iterator support
  var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) ||
    '_es6shim_iterator_';
  // Bug for mozilla version
  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') ***REMOVED***
    $iterator$ = '@@iterator';
  ***REMOVED***

  var doneEnumerator = Rx.doneEnumerator = ***REMOVED*** done: true, value: undefined ***REMOVED***;

  var isIterable = Rx.helpers.isIterable = function (o) ***REMOVED***
    return o[$iterator$] !== undefined;
  ***REMOVED***

  var isArrayLike = Rx.helpers.isArrayLike = function (o) ***REMOVED***
    return o && o.length !== undefined;
  ***REMOVED***

  Rx.helpers.iterator = $iterator$;

  function enumerableWhile(condition, source) ***REMOVED***
    return new Enumerable(function () ***REMOVED***
      return new Enumerator(function () ***REMOVED***
        return condition() ?
          ***REMOVED*** done: false, value: source ***REMOVED*** :
          ***REMOVED*** done: true, value: undefined ***REMOVED***;
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

   /**
   *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.
   *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.
   *
   * @param ***REMOVED***Function***REMOVED*** selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   */
  observableProto.letBind = observableProto['let'] = function (func) ***REMOVED***
    return func(this);
  ***REMOVED***;

   /**
   *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9
   *
   * @example
   *  1 - res = Rx.Observable.if(condition, obs1);
   *  2 - res = Rx.Observable.if(condition, obs1, obs2);
   *  3 - res = Rx.Observable.if(condition, obs1, scheduler);
   * @param ***REMOVED***Function***REMOVED*** condition The condition which determines if the thenSource or elseSource will be run.
   * @param ***REMOVED***Observable***REMOVED*** thenSource The observable sequence or Promise that will be run if the condition function returns true.
   * @param ***REMOVED***Observable***REMOVED*** [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which is either the thenSource or elseSource.
   */
  Observable['if'] = Observable.ifThen = function (condition, thenSource, elseSourceOrScheduler) ***REMOVED***
    return observableDefer(function () ***REMOVED***
      elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());

      isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
      isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));

      // Assume a scheduler for empty only
      typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
      return condition() ? thenSource : elseSourceOrScheduler;
    ***REMOVED***);
  ***REMOVED***;

   /**
   *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.
   * There is an alias for this method called 'forIn' for browsers <IE9
   * @param ***REMOVED***Array***REMOVED*** sources An array of values to turn into an observable sequence.
   * @param ***REMOVED***Function***REMOVED*** resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence from the concatenated observable sequences.
   */
  Observable['for'] = Observable.forIn = function (sources, resultSelector, thisArg) ***REMOVED***
    return enumerableOf(sources, resultSelector, thisArg).concat();
  ***REMOVED***;

   /**
   *  Repeats source as long as condition holds emulating a while loop.
   * There is an alias for this method called 'whileDo' for browsers <IE9
   *
   * @param ***REMOVED***Function***REMOVED*** condition The condition which determines if the source will be repeated.
   * @param ***REMOVED***Observable***REMOVED*** source The observable sequence that will be run if the condition function returns true.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which is repeated as long as the condition holds.
   */
  var observableWhileDo = Observable['while'] = Observable.whileDo = function (condition, source) ***REMOVED***
    isPromise(source) && (source = observableFromPromise(source));
    return enumerableWhile(condition, source).concat();
  ***REMOVED***;

   /**
   *  Repeats source as long as condition holds emulating a do while loop.
   *
   * @param ***REMOVED***Function***REMOVED*** condition The condition which determines if the source will be repeated.
   * @param ***REMOVED***Observable***REMOVED*** source The observable sequence that will be run if the condition function returns true.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which is repeated as long as the condition holds.
   */
  observableProto.doWhile = function (condition) ***REMOVED***
    return observableConcat([this, observableWhileDo(condition, this)]);
  ***REMOVED***;

   /**
   *  Uses selector to determine which source in sources to use.
   *  There is an alias 'switchCase' for browsers <IE9.
   *
   * @example
   *  1 - res = Rx.Observable.case(selector, ***REMOVED*** '1': obs1, '2': obs2 ***REMOVED***);
   *  1 - res = Rx.Observable.case(selector, ***REMOVED*** '1': obs1, '2': obs2 ***REMOVED***, obs0);
   *  1 - res = Rx.Observable.case(selector, ***REMOVED*** '1': obs1, '2': obs2 ***REMOVED***, scheduler);
   *
   * @param ***REMOVED***Function***REMOVED*** selector The function which extracts the value for to test in a case statement.
   * @param ***REMOVED***Array***REMOVED*** sources A object which has keys which correspond to the case statement labels.
   * @param ***REMOVED***Observable***REMOVED*** [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.
   *
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which is determined by a case statement.
   */
  Observable['case'] = Observable.switchCase = function (selector, sources, defaultSourceOrScheduler) ***REMOVED***
    return observableDefer(function () ***REMOVED***
      isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
      defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());

      typeof defaultSourceOrScheduler.now === 'function' && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));

      var result = sources[selector()];
      isPromise(result) && (result = observableFromPromise(result));

      return result || defaultSourceOrScheduler;
    ***REMOVED***);
  ***REMOVED***;

   /**
   *  Expands an observable sequence by recursively invoking selector.
   *
   * @param ***REMOVED***Function***REMOVED*** selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.
   * @param ***REMOVED***Scheduler***REMOVED*** [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence containing all the elements produced by the recursive expansion.
   */
  observableProto.expand = function (selector, scheduler) ***REMOVED***
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    var source = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var q = [],
        m = new SerialDisposable(),
        d = new CompositeDisposable(m),
        activeCount = 0,
        isAcquired = false;

      var ensureActive = function () ***REMOVED***
        var isOwner = false;
        if (q.length > 0) ***REMOVED***
          isOwner = !isAcquired;
          isAcquired = true;
        ***REMOVED***
        if (isOwner) ***REMOVED***
          m.setDisposable(scheduler.scheduleRecursive(function (self) ***REMOVED***
            var work;
            if (q.length > 0) ***REMOVED***
              work = q.shift();
            ***REMOVED*** else ***REMOVED***
              isAcquired = false;
              return;
            ***REMOVED***
            var m1 = new SingleAssignmentDisposable();
            d.add(m1);
            m1.setDisposable(work.subscribe(function (x) ***REMOVED***
              observer.onNext(x);
              var result = null;
              try ***REMOVED***
                result = selector(x);
              ***REMOVED*** catch (e) ***REMOVED***
                observer.onError(e);
              ***REMOVED***
              q.push(result);
              activeCount++;
              ensureActive();
            ***REMOVED***, observer.onError.bind(observer), function () ***REMOVED***
              d.remove(m1);
              activeCount--;
              if (activeCount === 0) ***REMOVED***
                observer.onCompleted();
              ***REMOVED***
            ***REMOVED***));
            self();
          ***REMOVED***));
        ***REMOVED***
      ***REMOVED***;

      q.push(source);
      activeCount++;
      ensureActive();
      return d;
    ***REMOVED***, this);
  ***REMOVED***;

   /**
   *  Runs all observable sequences in parallel and collect their last elements.
   *
   * @example
   *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);
   *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence with an array collecting the last elements of all the input sequences.
   */
  Observable.forkJoin = function () ***REMOVED***
    var allSources = argsOrArray(arguments, 0);
    return new AnonymousObservable(function (subscriber) ***REMOVED***
      var count = allSources.length;
      if (count === 0) ***REMOVED***
        subscriber.onCompleted();
        return disposableEmpty;
      ***REMOVED***
      var group = new CompositeDisposable(),
        finished = false,
        hasResults = new Array(count),
        hasCompleted = new Array(count),
        results = new Array(count);

      for (var idx = 0; idx < count; idx++) ***REMOVED***
        (function (i) ***REMOVED***
          var source = allSources[i];
          isPromise(source) && (source = observableFromPromise(source));
          group.add(
            source.subscribe(
              function (value) ***REMOVED***
              if (!finished) ***REMOVED***
                hasResults[i] = true;
                results[i] = value;
              ***REMOVED***
            ***REMOVED***,
            function (e) ***REMOVED***
              finished = true;
              subscriber.onError(e);
              group.dispose();
            ***REMOVED***,
            function () ***REMOVED***
              if (!finished) ***REMOVED***
                if (!hasResults[i]) ***REMOVED***
                    subscriber.onCompleted();
                    return;
                ***REMOVED***
                hasCompleted[i] = true;
                for (var ix = 0; ix < count; ix++) ***REMOVED***
                  if (!hasCompleted[ix]) ***REMOVED*** return; ***REMOVED***
                ***REMOVED***
                finished = true;
                subscriber.onNext(results);
                subscriber.onCompleted();
              ***REMOVED***
            ***REMOVED***));
        ***REMOVED***)(idx);
      ***REMOVED***

      return group;
    ***REMOVED***);
  ***REMOVED***;

   /**
   *  Runs two observable sequences in parallel and combines their last elemenets.
   *
   * @param ***REMOVED***Observable***REMOVED*** second Second observable sequence.
   * @param ***REMOVED***Function***REMOVED*** resultSelector Result selector function to invoke with the last elements of both sequences.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence with the result of calling the selector function with the last elements of both input sequences.
   */
  observableProto.forkJoin = function (second, resultSelector) ***REMOVED***
    var first = this;

    return new AnonymousObservable(function (observer) ***REMOVED***
      var leftStopped = false, rightStopped = false,
        hasLeft = false, hasRight = false,
        lastLeft, lastRight,
        leftSubscription = new SingleAssignmentDisposable(), rightSubscription = new SingleAssignmentDisposable();

      isPromise(second) && (second = observableFromPromise(second));

      leftSubscription.setDisposable(
          first.subscribe(function (left) ***REMOVED***
            hasLeft = true;
            lastLeft = left;
          ***REMOVED***, function (err) ***REMOVED***
            rightSubscription.dispose();
            observer.onError(err);
          ***REMOVED***, function () ***REMOVED***
            leftStopped = true;
            if (rightStopped) ***REMOVED***
              if (!hasLeft) ***REMOVED***
                  observer.onCompleted();
              ***REMOVED*** else if (!hasRight) ***REMOVED***
                  observer.onCompleted();
              ***REMOVED*** else ***REMOVED***
                var result;
                try ***REMOVED***
                  result = resultSelector(lastLeft, lastRight);
                ***REMOVED*** catch (e) ***REMOVED***
                  observer.onError(e);
                  return;
                ***REMOVED***
                observer.onNext(result);
                observer.onCompleted();
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***)
      );

      rightSubscription.setDisposable(
        second.subscribe(function (right) ***REMOVED***
          hasRight = true;
          lastRight = right;
        ***REMOVED***, function (err) ***REMOVED***
          leftSubscription.dispose();
          observer.onError(err);
        ***REMOVED***, function () ***REMOVED***
          rightStopped = true;
          if (leftStopped) ***REMOVED***
            if (!hasLeft) ***REMOVED***
              observer.onCompleted();
            ***REMOVED*** else if (!hasRight) ***REMOVED***
              observer.onCompleted();
            ***REMOVED*** else ***REMOVED***
              var result;
              try ***REMOVED***
                result = resultSelector(lastLeft, lastRight);
              ***REMOVED*** catch (e) ***REMOVED***
                observer.onError(e);
                return;
              ***REMOVED***
              observer.onNext(result);
              observer.onCompleted();
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***)
      );

      return new CompositeDisposable(leftSubscription, rightSubscription);
    ***REMOVED***, first);
  ***REMOVED***;

  /**
   * Comonadic bind operator.
   * @param ***REMOVED***Function***REMOVED*** selector A transform function to apply to each element.
   * @param ***REMOVED***Object***REMOVED*** scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which results from the comonadic bind operation.
   */
  observableProto.manySelect = function (selector, scheduler) ***REMOVED***
    isScheduler(scheduler) || (scheduler = immediateScheduler);
    var source = this;
    return observableDefer(function () ***REMOVED***
      var chain;

      return source
        .map(function (x) ***REMOVED***
          var curr = new ChainObservable(x);

          chain && chain.onNext(x);
          chain = curr;

          return curr;
        ***REMOVED***)
        .tap(
          noop,
          function (e) ***REMOVED*** chain && chain.onError(e); ***REMOVED***,
          function () ***REMOVED*** chain && chain.onCompleted(); ***REMOVED***
        )
        .observeOn(scheduler)
        .map(selector);
    ***REMOVED***, source);
  ***REMOVED***;

  var ChainObservable = (function (__super__) ***REMOVED***

    function subscribe (observer) ***REMOVED***
      var self = this, g = new CompositeDisposable();
      g.add(currentThreadScheduler.schedule(function () ***REMOVED***
        observer.onNext(self.head);
        g.add(self.tail.mergeAll().subscribe(observer));
      ***REMOVED***));

      return g;
    ***REMOVED***

    inherits(ChainObservable, __super__);

    function ChainObservable(head) ***REMOVED***
      __super__.call(this, subscribe);
      this.head = head;
      this.tail = new AsyncSubject();
    ***REMOVED***

    addProperties(ChainObservable.prototype, Observer, ***REMOVED***
      onCompleted: function () ***REMOVED***
        this.onNext(Observable.empty());
      ***REMOVED***,
      onError: function (e) ***REMOVED***
        this.onNext(Observable.throwException(e));
      ***REMOVED***,
      onNext: function (v) ***REMOVED***
        this.tail.onNext(v);
        this.tail.onCompleted();
      ***REMOVED***
    ***REMOVED***);

    return ChainObservable;

  ***REMOVED***(Observable));

  /*
   * Performs a exclusive waiting for the first to finish before subscribing to another observable.
   * Observables that come in between subscriptions will be dropped on the floor.
   * @returns ***REMOVED***Observable***REMOVED*** A exclusive observable with only the results that happen when subscribed.
   */
  observableProto.exclusive = function () ***REMOVED***
    var sources = this;
    return new AnonymousObservable(function (observer) ***REMOVED***
      var hasCurrent = false,
        isStopped = false,
        m = new SingleAssignmentDisposable(),
        g = new CompositeDisposable();

      g.add(m);

      m.setDisposable(sources.subscribe(
        function (innerSource) ***REMOVED***
          if (!hasCurrent) ***REMOVED***
            hasCurrent = true;

            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));

            var innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);

            innerSubscription.setDisposable(innerSource.subscribe(
              observer.onNext.bind(observer),
              observer.onError.bind(observer),
              function () ***REMOVED***
                g.remove(innerSubscription);
                hasCurrent = false;
                if (isStopped && g.length === 1) ***REMOVED***
                  observer.onCompleted();
                ***REMOVED***
            ***REMOVED***));
          ***REMOVED***
        ***REMOVED***,
        observer.onError.bind(observer),
        function () ***REMOVED***
          isStopped = true;
          if (!hasCurrent && g.length === 1) ***REMOVED***
            observer.onCompleted();
          ***REMOVED***
        ***REMOVED***));

      return g;
    ***REMOVED***, this);
  ***REMOVED***;

  /*
   * Performs a exclusive map waiting for the first to finish before subscribing to another observable.
   * Observables that come in between subscriptions will be dropped on the floor.
   * @param ***REMOVED***Function***REMOVED*** selector Selector to invoke for every item in the current subscription.
   * @param ***REMOVED***Any***REMOVED*** [thisArg] An optional context to invoke with the selector parameter.
   * @returns ***REMOVED***Observable***REMOVED*** An exclusive observable with only the results that happen when subscribed.
   */
  observableProto.exclusiveMap = function (selector, thisArg) ***REMOVED***
    var sources = this,
        selectorFunc = bindCallback(selector, thisArg, 3);
    return new AnonymousObservable(function (observer) ***REMOVED***
      var index = 0,
        hasCurrent = false,
        isStopped = true,
        m = new SingleAssignmentDisposable(),
        g = new CompositeDisposable();

      g.add(m);

      m.setDisposable(sources.subscribe(
        function (innerSource) ***REMOVED***

          if (!hasCurrent) ***REMOVED***
            hasCurrent = true;

            innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);

            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));

            innerSubscription.setDisposable(innerSource.subscribe(
              function (x) ***REMOVED***
                var result;
                try ***REMOVED***
                  result = selectorFunc(x, index++, innerSource);
                ***REMOVED*** catch (e) ***REMOVED***
                  observer.onError(e);
                  return;
                ***REMOVED***

                observer.onNext(result);
              ***REMOVED***,
              function (e) ***REMOVED*** observer.onError(e); ***REMOVED***,
              function () ***REMOVED***
                g.remove(innerSubscription);
                hasCurrent = false;

                if (isStopped && g.length === 1) ***REMOVED***
                  observer.onCompleted();
                ***REMOVED***
              ***REMOVED***));
          ***REMOVED***
        ***REMOVED***,
        function (e) ***REMOVED*** observer.onError(e); ***REMOVED***,
        function () ***REMOVED***
          isStopped = true;
          if (g.length === 1 && !hasCurrent) ***REMOVED***
            observer.onCompleted();
          ***REMOVED***
        ***REMOVED***));
      return g;
    ***REMOVED***, this);
  ***REMOVED***;

    return Rx;
***REMOVED***));
