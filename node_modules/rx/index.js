var Rx = require('./dist/rx.all');
require('./dist/rx.sorting');
require('./dist/rx.testing');

// Add specific Node functions
var EventEmitter = require('events').EventEmitter,
  Observable = Rx.Observable;

Rx.Node = ***REMOVED***
  /**
   * @deprecated Use Rx.Observable.fromCallback from rx.async.js instead.
   *
   * Converts a callback function to an observable sequence.
   *
   * @param ***REMOVED***Function***REMOVED*** func Function to convert to an asynchronous function.
   * @param ***REMOVED***Mixed***REMOVED*** [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param ***REMOVED***Function***REMOVED*** [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns ***REMOVED***Function***REMOVED*** Asynchronous function.
   */
  fromCallback: function (func, context, selector) ***REMOVED***
    return Observable.fromCallback(func, context, selector);
  ***REMOVED***,

  /**
   * @deprecated Use Rx.Observable.fromNodeCallback from rx.async.js instead.
   *
   * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.
   *
   * @param ***REMOVED***Function***REMOVED*** func The function to call
   * @param ***REMOVED***Mixed***REMOVED*** [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
   * @param ***REMOVED***Function***REMOVED*** [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns ***REMOVED***Function***REMOVED*** An async function which when applied, returns an observable sequence with the callback arguments as an array.
   */
  fromNodeCallback: function (func, context, selector) ***REMOVED***
    return Observable.fromNodeCallback(func, context, selector);
  ***REMOVED***,

  /**
   * @deprecated Use Rx.Observable.fromNodeCallback from rx.async.js instead.
   *
   * Handles an event from the given EventEmitter as an observable sequence.
   *
   * @param ***REMOVED***EventEmitter***REMOVED*** eventEmitter The EventEmitter to subscribe to the given event.
   * @param ***REMOVED***String***REMOVED*** eventName The event name to subscribe
   * @param ***REMOVED***Function***REMOVED*** [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence generated from the named event from the given EventEmitter.  The data will be returned as an array of arguments to the handler.
   */
  fromEvent: function (eventEmitter, eventName, selector) ***REMOVED***
    return Observable.fromEvent(eventEmitter, eventName, selector);
  ***REMOVED***,

  /**
   * Converts the given observable sequence to an event emitter with the given event name.
   * The errors are handled on the 'error' event and completion on the 'end' event.
   * @param ***REMOVED***Observable***REMOVED*** observable The observable sequence to convert to an EventEmitter.
   * @param ***REMOVED***String***REMOVED*** eventName The event name to emit onNext calls.
   * @returns ***REMOVED***EventEmitter***REMOVED*** An EventEmitter which emits the given eventName for each onNext call in addition to 'error' and 'end' events.
   *   You must call publish in order to invoke the subscription on the Observable sequuence.
   */
  toEventEmitter: function (observable, eventName, selector) ***REMOVED***
    var e = new EventEmitter();

    // Used to publish the events from the observable
    e.publish = function () ***REMOVED***
      e.subscription = observable.subscribe(
        function (x) ***REMOVED***
          var result = x;
          if (selector) ***REMOVED***
            try ***REMOVED***
              result = selector(x);
            ***REMOVED*** catch (e) ***REMOVED***
              e.emit('error', e);
              return;
            ***REMOVED***
          ***REMOVED***

          e.emit(eventName, result);
        ***REMOVED***,
        function (err) ***REMOVED***
          e.emit('error', err);
        ***REMOVED***,
        function () ***REMOVED***
          e.emit('end');
        ***REMOVED***);
    ***REMOVED***;

    return e;
  ***REMOVED***,

  /**
   * Converts a flowing stream to an Observable sequence.
   * @param ***REMOVED***Stream***REMOVED*** stream A stream to convert to a observable sequence.
   * @param ***REMOVED***String***REMOVED*** [finishEventName] Event that notifies about closed stream. ("end" by default)
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which fires on each 'data' event as well as handling 'error' and finish events like `end` or `finish`.
   */
  fromStream: function (stream, finishEventName) ***REMOVED***
    stream.pause();

    finishEventName || (finishEventName = 'end');

    return Observable.create(function (observer) ***REMOVED***
      function dataHandler (data) ***REMOVED***
        observer.onNext(data);
      ***REMOVED***

      function errorHandler (err) ***REMOVED***
        observer.onError(err);
      ***REMOVED***

      function endHandler () ***REMOVED***
        observer.onCompleted();
      ***REMOVED***

      stream.addListener('data', dataHandler);
      stream.addListener('error', errorHandler);
      stream.addListener(finishEventName, endHandler);

      stream.resume();

      return function () ***REMOVED***
        stream.removeListener('data', dataHandler);
        stream.removeListener('error', errorHandler);
        stream.removeListener(finishEventName, endHandler);
      ***REMOVED***;
    ***REMOVED***).publish().refCount();
  ***REMOVED***,

  /**
   * Converts a flowing readable stream to an Observable sequence.
   * @param ***REMOVED***Stream***REMOVED*** stream A stream to convert to a observable sequence.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which fires on each 'data' event as well as handling 'error' and 'end' events.
   */
  fromReadableStream: function (stream) ***REMOVED***
    return this.fromStream(stream, 'end');
  ***REMOVED***,

  /**
   * Converts a flowing writeable stream to an Observable sequence.
   * @param ***REMOVED***Stream***REMOVED*** stream A stream to convert to a observable sequence.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which fires on each 'data' event as well as handling 'error' and 'finish' events.
   */
  fromWritableStream: function (stream) ***REMOVED***
    return this.fromStream(stream, 'finish');
  ***REMOVED***,

  /**
   * Converts a flowing transform stream to an Observable sequence.
   * @param ***REMOVED***Stream***REMOVED*** stream A stream to convert to a observable sequence.
   * @returns ***REMOVED***Observable***REMOVED*** An observable sequence which fires on each 'data' event as well as handling 'error' and 'finish' events.
   */
  fromTransformStream: function (stream) ***REMOVED***
    return this.fromStream(stream, 'finish');
  ***REMOVED***,

  /**
   * Writes an observable sequence to a stream
   * @param ***REMOVED***Observable***REMOVED*** observable Observable sequence to write to a stream.
   * @param ***REMOVED***Stream***REMOVED*** stream The stream to write to.
   * @param ***REMOVED***String***REMOVED*** [encoding] The encoding of the item to write.
   * @returns ***REMOVED***Disposable***REMOVED*** The subscription handle.
   */
  writeToStream: function (observable, stream, encoding) ***REMOVED***
    var source = observable.pausableBuffered();

    function onDrain() ***REMOVED***
      source.resume();
    ***REMOVED***

    stream.addListener('drain', onDrain);

    return source.subscribe(
      function (x) ***REMOVED***
        !stream.write(String(x), encoding) && source.pause();
      ***REMOVED***,
      function (err) ***REMOVED***
        stream.emit('error', err);
      ***REMOVED***,
      function () ***REMOVED***
        // Hack check because STDIO is not closable
        !stream._isStdio && stream.end();
        stream.removeListener('drain', onDrain);
      ***REMOVED***);

    source.resume();
  ***REMOVED***
***REMOVED***;

/**
 * Pipes the existing Observable sequence into a Node.js Stream.
 * @param ***REMOVED***Stream***REMOVED*** dest The destination Node.js stream.
 * @returns ***REMOVED***Stream***REMOVED*** The destination stream.
 */
Rx.Observable.prototype.pipe = function (dest) ***REMOVED***
  var source = this.pausableBuffered();

  function onDrain() ***REMOVED***
    source.resume();
  ***REMOVED***

  dest.addListener('drain', onDrain);

  source.subscribe(
    function (x) ***REMOVED***
      !dest.write(String(x)) && source.pause();
    ***REMOVED***,
    function (err) ***REMOVED***
      dest.emit('error', err);
    ***REMOVED***,
    function () ***REMOVED***
      // Hack check because STDIO is not closable
      !dest._isStdio && dest.end();
      dest.removeListener('drain', onDrain);
    ***REMOVED***);

  source.resume();

  return dest;
***REMOVED***;

module.exports = Rx;
