#!/usr/bin/env node

var Rx = require('rx');
var path = require('path');
var formatDate = require('date-fns/format');
var program = require('commander');
var _ = require('lodash');
var treeKill = require('tree-kill');
var chalk = require('chalk');
var spawn = require('spawn-command');
var supportsColor = require('supports-color');
var IS_WINDOWS = /^win/.test(process.platform);

var config = ***REMOVED***
    // Kill other processes if one dies
    killOthers: false,

    // Kill other processes if one exits with non zero status code
    killOthersOnFail: false,

    // Return success or failure of the 'first' child to terminate, the 'last' child,
    // or succeed only if 'all' children succeed
    success: 'all',

    // Prefix logging with pid
    // Possible values: 'pid', 'none', 'time', 'command', 'index', 'name'
    prefix: '',

    // List of custom names to be used in prefix template
    names: '',

    // What to split the list of custom names on
    nameSeparator: ',',

    // Comma-separated list of chalk color paths to use on prefixes.
    prefixColors: 'gray.dim',

    // moment/date-fns format
    timestampFormat: 'YYYY-MM-DD HH:mm:ss.SSS',

    // How many characters to display from start of command in prefix if
    // command is defined. Note that also '..' will be added in the middle
    prefixLength: 10,

    // By default, color output
    color: true,

    // If true, the output will only be raw output of processes, nothing more
    raw: false,

    // If true, the process restart when it exited with status code non-zero
    allowRestart: false,

    // By default, restart instantly
    restartAfter: 0,

    // By default, restart once
    restartTries: 1
***REMOVED***;

function main() ***REMOVED***
    var firstBase = path.basename(process.argv[0]);
    var secondBase = path.basename(process.argv[1]);
    if (firstBase === 'concurrent' || secondBase === 'concurrent') ***REMOVED***
        console.error('Warning: "concurrent" command is deprecated, use "concurrently" instead.\n');
    ***REMOVED***

    parseArgs();
    config = mergeDefaultsWithArgs(config);
    applyDynamicDefaults(config)

    run(program.args);
***REMOVED***

function parseArgs() ***REMOVED***
    program
        .version(require('../package.json').version)
        .usage('[options] <command ...>')
        .option(
            '-k, --kill-others',
            'kill other processes if one exits or dies'
        )
        .option(
            '--kill-others-on-fail',
            'kill other processes if one exits with non zero status code'
        )
        .option(
            '--no-color',
            'disable colors from logging'
        )
        .option(
            '-p, --prefix <prefix>',
            'prefix used in logging for each process.\n' +
            'Possible values: index, pid, time, command, name, none, or a template. Default: ' +
            'index or name (when --names is set). Example template: "***REMOVED***time***REMOVED***-***REMOVED***pid***REMOVED***"\n'
        )
        .option(
            '-n, --names <names>',
            'List of custom names to be used in prefix template.\n' +
            'Example names: "main,browser,server"\n'
        )
        .option(
            '--name-separator <char>',
            'The character to split <names> on.\n' +
            'Default: "' + config.nameSeparator + '". Example usage: ' +
            'concurrently -n "styles,scripts|server" --name-separator "|" <command ...>\n'
        )
        .option(
            '-c, --prefix-colors <colors>',
            'Comma-separated list of chalk colors to use on prefixes. If there are more commands than colors, the last color will be repeated.\n' +
            'Available modifiers: reset, bold, dim, italic, underline, inverse, hidden, strikethrough\n' +
            'Available colors: black, red, green, yellow, blue, magenta, cyan, white, gray\n' +
            'Available background colors: bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite\n' +
            'See https://www.npmjs.com/package/chalk for more information.\n' +
            'Default: "' + config.prefixColors + '". Example: "black.bgWhite,cyan,gray.dim"\n'
        )
        .option(
            '-t, --timestamp-format <format>',
            'specify the timestamp in moment/date-fns format. Default: ' +
            config.timestampFormat + '\n'
        )
        .option(
            '-r, --raw',
            'output only raw output of processes,' +
            ' disables prettifying and concurrently coloring'
        )
        .option(
            '-s, --success <first|last|all>',
            'Return exit code of zero or one based on the success or failure ' +
            'of the "first" child to terminate, the "last" child, or succeed ' +
            ' only if "all" child processes succeed. Default: ' +
            config.success + '\n'
        )
        .option(
            '-l, --prefix-length <length>',
            'limit how many characters of the command is displayed in prefix.\n' +
            'The option can be used to shorten long commands.\n' +
            'Works only if prefix is set to "command". Default: ' +
            config.prefixLength + '\n'
        )
        .option(
            '--allow-restart',
            'Restart a process which died. Default: ' +
            config.allowRestart + '\n'
        )
        .option(
            '--restart-after <miliseconds>',
            'delay time to respawn the process. Default: ' +
            config.restartAfter + '\n'
        )
        .option(
            '--restart-tries <times>',
            'limit the number of respawn tries. Default: ' +
            config.restartTries + '\n'
        );

    program.on('--help', function() ***REMOVED***
        var help = [
            '  Examples:',
            '',
            '   - Kill other processes if one exits or dies',
            '',
            '       $ concurrently --kill-others "grunt watch" "http-server"',
            '',
            '   - Kill other processes if one exits with non zero status code',
            '',
            '       $ concurrently --kill-others-on-fail "npm run build:client" "npm run build:server"',
            '',
            '   - Output nothing more than stdout+stderr of child processes',
            '',
            '       $ concurrently --raw "npm run watch-less" "npm run watch-js"',
            '',
            '   - Normal output but without colors e.g. when logging to file',
            '',
            '       $ concurrently --no-color "grunt watch" "http-server" > log',
            '',
            '   - Custom prefix',
            '',
            '       $ concurrently --prefix "***REMOVED***time***REMOVED***-***REMOVED***pid***REMOVED***" "npm run watch" "http-server"',
            '',
            '   - Custom names and colored prefixes',
            '',
            '       $ concurrently --names "HTTP,WATCH" -c "bgBlue.bold,bgMagenta.bold" "http-server" "npm run watch"',
            ''
        ];
        console.log(help.join('\n'));

        var url = 'https://github.com/kimmobrunfeldt/concurrently';
        console.log('  For more details, visit ' + url);
        console.log('');
    ***REMOVED***);

    program.parse(process.argv);
***REMOVED***

function mergeDefaultsWithArgs(config) ***REMOVED***
    // This will pollute config object with other attributes from program too
    return _.merge(config, program);
***REMOVED***

function applyDynamicDefaults(config) ***REMOVED***
    if (!config.prefix) ***REMOVED***
        config.prefix = config.names ? 'name' : 'index';
    ***REMOVED***
***REMOVED***

function stripCmdQuotes(cmd) ***REMOVED***
    // Removes the quotes surrounding a command.
    if (cmd[0] === '"' || cmd[0] === '\'') ***REMOVED***
        return cmd.substr(1, cmd.length - 2);
    ***REMOVED*** else ***REMOVED***
        return cmd;
    ***REMOVED***
***REMOVED***

function run(commands) ***REMOVED***
    var childrenInfo = ***REMOVED******REMOVED***;
    var lastPrefixColor = _.get(chalk, chalk.gray.dim);
    var prefixColors = config.prefixColors.split(',');
    var names = config.names.split(config.nameSeparator);
    var children = _.map(commands, function(cmd, index) ***REMOVED***
        // Remove quotes.
        cmd = stripCmdQuotes(cmd);

        var spawnOpts = config.raw ? ***REMOVED***stdio: 'inherit'***REMOVED*** : ***REMOVED******REMOVED***;
        if (IS_WINDOWS) ***REMOVED***
            spawnOpts.detached = false;
        ***REMOVED***
        if (supportsColor) ***REMOVED***
          spawnOpts.env = Object.assign(***REMOVED***FORCE_COLOR: supportsColor.level***REMOVED***, process.env)
        ***REMOVED***

        var child = spawnChild(cmd, spawnOpts);

        if (index < prefixColors.length) ***REMOVED***
            var prefixColorPath = prefixColors[index];
            lastPrefixColor = _.get(chalk, prefixColorPath, chalk.gray.dim);
        ***REMOVED***

        var name = index < names.length ? names[index] : '';
        childrenInfo[child.pid] = ***REMOVED***
            command: cmd,
            index: index,
            name: name,
            options: spawnOpts,
            restartTries: config.restartTries,
            prefixColor: lastPrefixColor
        ***REMOVED***;
        return child;
    ***REMOVED***);

    var streams = toStreams(children);

    handleChildEvents(streams, children, childrenInfo);

    ['SIGINT', 'SIGTERM'].forEach(function(signal) ***REMOVED***
      process.on(signal, function() ***REMOVED***
        children.forEach(function(child) ***REMOVED***
          treeKill(child.pid, signal);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
***REMOVED***

function spawnChild(cmd, options) ***REMOVED***
    var child;
    try ***REMOVED***
        child = spawn(cmd, options);
    ***REMOVED*** catch (e) ***REMOVED***
        logError('', chalk.gray.dim, 'Error occured when executing command: ' + cmd);
        logError('', chalk.gray.dim, e.stack);
        process.exit(1);
    ***REMOVED***
    return child;
***REMOVED***

function toStreams(children) ***REMOVED***
    // Transform all process events to rx streams
    return _.map(children, function(child) ***REMOVED***
        var childStreams = ***REMOVED***
            error: Rx.Node.fromEvent(child, 'error'),
            close: Rx.Node.fromEvent(child, 'close')
        ***REMOVED***;
        if (!config.raw) ***REMOVED***
            childStreams.stdout = Rx.Node.fromReadableStream(child.stdout);
            childStreams.stderr = Rx.Node.fromReadableStream(child.stderr);
        ***REMOVED***

        return _.reduce(childStreams, function(memo, stream, key) ***REMOVED***
            memo[key] = stream.map(function(data) ***REMOVED***
                return ***REMOVED***child: child, data: data***REMOVED***;
            ***REMOVED***);

            return memo;
        ***REMOVED***, ***REMOVED******REMOVED***);
    ***REMOVED***);
***REMOVED***

function handleChildEvents(streams, children, childrenInfo) ***REMOVED***
    handleClose(streams, children, childrenInfo);
    handleError(streams, childrenInfo);
    if (!config.raw) ***REMOVED***
        handleOutput(streams, childrenInfo, 'stdout');
        handleOutput(streams, childrenInfo, 'stderr');
    ***REMOVED***
***REMOVED***

function handleOutput(streams, childrenInfo, source) ***REMOVED***
    var sourceStreams = _.map(streams, source);
    var combinedSourceStream = Rx.Observable.merge.apply(this, sourceStreams);

    combinedSourceStream.subscribe(function(event) ***REMOVED***
        var prefix = getPrefix(childrenInfo, event.child);
        var prefixColor = childrenInfo[event.child.pid].prefixColor;
        log(prefix, prefixColor, event.data.toString());
    ***REMOVED***);
***REMOVED***

function handleClose(streams, children, childrenInfo) ***REMOVED***
    var aliveChildren = _.clone(children);
    var exitCodes = [];
    var closeStreams = _.map(streams, 'close');
    var closeStream = Rx.Observable.merge.apply(this, closeStreams);
    var othersKilled = false

    // TODO: Is it possible that amount of close events !== count of spawned?
    closeStream.subscribe(function(event) ***REMOVED***
        var exitCode = event.data;
        var nonSuccess = exitCode !== 0;
        exitCodes.push(exitCode);

        var prefix = getPrefix(childrenInfo, event.child);
        var childInfo = childrenInfo[event.child.pid];
        var prefixColor = childInfo.prefixColor;
        var command = childInfo.command;
        logEvent(prefix, prefixColor, command + ' exited with code ' + exitCode);

        aliveChildren = _.filter(aliveChildren, function(child) ***REMOVED***
            return child.pid !== event.child.pid;
        ***REMOVED***);

        if (nonSuccess && config.allowRestart && childInfo.restartTries--) ***REMOVED***
            respawnChild(event, childrenInfo);
            return;
        ***REMOVED***

        if (aliveChildren.length === 0) ***REMOVED***
            exit(exitCodes);
        ***REMOVED***
        if (!othersKilled) ***REMOVED***
          if (config.killOthers) ***REMOVED***
            killOtherProcesses(aliveChildren);
            othersKilled = true;
          ***REMOVED*** else if (config.killOthersOnFail && nonSuccess) ***REMOVED***
            killOtherProcesses(aliveChildren);
            othersKilled = true;
          ***REMOVED***
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

function respawnChild(event, childrenInfo) ***REMOVED***
    setTimeout(function() ***REMOVED***
        var childInfo = childrenInfo[event.child.pid];
        var prefix = getPrefix(childrenInfo, event.child);
        var prefixColor = childInfo.prefixColor;
        logEvent(prefix, prefixColor, childInfo.command + ' restarted');
        var newChild = spawnChild(childInfo.command, childInfo.options);

        childrenInfo[newChild.pid] = childrenInfo[event.child.pid];
        delete childrenInfo[event.child.pid];

        var children = [newChild];
        var streams = toStreams(children);
        handleChildEvents(streams, children, childrenInfo);
    ***REMOVED***, config.restartAfter);
***REMOVED***

function killOtherProcesses(processes) ***REMOVED***
    logEvent('--> ', chalk.gray.dim, 'Sending SIGTERM to other processes..');

    // Send SIGTERM to alive children
    _.each(processes, function(child) ***REMOVED***
        treeKill(child.pid, 'SIGTERM');
    ***REMOVED***);
***REMOVED***

function exit(childExitCodes) ***REMOVED***
    var success;
    switch (config.success) ***REMOVED***
        case 'first':
            success = _.first(childExitCodes) === 0;
            break;
        case 'last':
            success = _.last(childExitCodes) === 0;
            break;
        default:
            success = _.every(childExitCodes, function(code) ***REMOVED***
                return code === 0;
            ***REMOVED***);
    ***REMOVED***
    process.exit(success ? 0 : 1);
***REMOVED***

function handleError(streams, childrenInfo) ***REMOVED***
    // Output emitted errors from child process
    var errorStreams = _.map(streams, 'error');
    var processErrorStream = Rx.Observable.merge.apply(this, errorStreams);

    processErrorStream.subscribe(function(event) ***REMOVED***
        var command = childrenInfo[event.child.pid].command;
        logError('', chalk.gray.dim, 'Error occured when executing command: ' + command);
        logError('', chalk.gray.dim, event.data.stack);
    ***REMOVED***);
***REMOVED***

function colorText(text, color) ***REMOVED***
    if (!config.color) ***REMOVED***
        return text;
    ***REMOVED*** else ***REMOVED***
        return color(text);
    ***REMOVED***
***REMOVED***

function getPrefix(childrenInfo, child) ***REMOVED***
    var prefixes = getPrefixes(childrenInfo, child);
    if (_.includes(_.keys(prefixes), config.prefix)) ***REMOVED***
        return '[' + prefixes[config.prefix] + '] ';
    ***REMOVED***

    return _.reduce(prefixes, function(memo, val, key) ***REMOVED***
        var re = new RegExp('***REMOVED***' + key + '***REMOVED***', 'g');
        return memo.replace(re, val);
    ***REMOVED***, config.prefix) + ' ';
***REMOVED***

function getPrefixes(childrenInfo, child) ***REMOVED***
    var prefixes = ***REMOVED******REMOVED***;

    prefixes.none = '';
    prefixes.pid = child.pid;
    prefixes.index = childrenInfo[child.pid].index;
    prefixes.name = childrenInfo[child.pid].name;
    prefixes.time = formatDate(Date.now(), config.timestampFormat);

    var command = childrenInfo[child.pid].command;
    prefixes.command = shortenText(command, config.prefixLength);
    return prefixes;
***REMOVED***

function shortenText(text, length, cut) ***REMOVED***
    if (text.length <= length) ***REMOVED***
        return text;
    ***REMOVED***
    cut = _.isString(cut) ? cut : '..';

    var endLength = Math.floor(length / 2);
    var startLength = length - endLength;

    var first = text.substring(0, startLength);
    var last = text.substring(text.length - endLength, text.length);
    return first + cut + last;
***REMOVED***

function log(prefix, prefixColor, text) ***REMOVED***
    logWithPrefix(prefix, prefixColor, text);
***REMOVED***

function logEvent(prefix, prefixColor, text) ***REMOVED***
    if (config.raw) return;

    logWithPrefix(prefix, prefixColor, text + '\n', chalk.gray.dim);
***REMOVED***

function logError(prefix, prefixColor, text) ***REMOVED***
    // This is for now same as log, there might be separate colors for stderr
    // and stdout
    logWithPrefix(prefix, prefixColor, text, chalk.red.bold);
***REMOVED***

var lastChar;

function logWithPrefix(prefix, prefixColor, text, color) ***REMOVED***

     if (config.raw) ***REMOVED***
        process.stdout.write(text);
        return;
    ***REMOVED***

    text = text.replace(/\u2026/g,'...'); // Ellipsis

    var lines = text.split('\n');
    // Do not bgColor trailing space
    var coloredPrefix = colorText(prefix.replace(/ $/, ''), prefixColor) + ' ';
    var paddedLines = _.map(lines, function(line, index) ***REMOVED***
        var coloredLine = color ? colorText(line, color) : line;
        if (index !== 0 && index !== (lines.length - 1)) ***REMOVED***
            coloredLine = coloredPrefix + coloredLine;
        ***REMOVED***
        return coloredLine;
    ***REMOVED***);

    if (!lastChar || lastChar == '\n' )***REMOVED***
        process.stdout.write(coloredPrefix);
    ***REMOVED***

    lastChar = text[text.length - 1];

    process.stdout.write(paddedLines.join('\n'));
***REMOVED***

main();
