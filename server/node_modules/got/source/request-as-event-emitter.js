'use strict';
const ***REMOVED***URL***REMOVED*** = require('url'); // TODO: Use the `URL` global when targeting Node.js 10
const util = require('util');
const EventEmitter = require('events');
const http = require('http');
const https = require('https');
const urlLib = require('url');
const CacheableRequest = require('cacheable-request');
const toReadableStream = require('to-readable-stream');
const is = require('@sindresorhus/is');
const timer = require('@szmarczak/http-timer');
const timedOut = require('./utils/timed-out');
const getBodySize = require('./utils/get-body-size');
const getResponse = require('./get-response');
const progress = require('./progress');
const ***REMOVED***CacheError, UnsupportedProtocolError, MaxRedirectsError, RequestError, TimeoutError***REMOVED*** = require('./errors');
const urlToOptions = require('./utils/url-to-options');

const getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);
const allMethodRedirectCodes = new Set([300, 303, 307, 308]);

module.exports = (options, input) => ***REMOVED***
	const emitter = new EventEmitter();
	const redirects = [];
	let currentRequest;
	let requestUrl;
	let redirectString;
	let uploadBodySize;
	let retryCount = 0;
	let shouldAbort = false;

	const setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;
	const getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;
	const agents = is.object(options.agent) ? options.agent : null;

	const emitError = async error => ***REMOVED***
		try ***REMOVED***
			for (const hook of options.hooks.beforeError) ***REMOVED***
				// eslint-disable-next-line no-await-in-loop
				error = await hook(error);
			***REMOVED***

			emitter.emit('error', error);
		***REMOVED*** catch (error2) ***REMOVED***
			emitter.emit('error', error2);
		***REMOVED***
	***REMOVED***;

	const get = async options => ***REMOVED***
		const currentUrl = redirectString || requestUrl;

		if (options.protocol !== 'http:' && options.protocol !== 'https:') ***REMOVED***
			throw new UnsupportedProtocolError(options);
		***REMOVED***

		decodeURI(currentUrl);

		let fn;
		if (is.function(options.request)) ***REMOVED***
			fn = ***REMOVED***request: options.request***REMOVED***;
		***REMOVED*** else ***REMOVED***
			fn = options.protocol === 'https:' ? https : http;
		***REMOVED***

		if (agents) ***REMOVED***
			const protocolName = options.protocol === 'https:' ? 'https' : 'http';
			options.agent = agents[protocolName] || options.agent;
		***REMOVED***

		/* istanbul ignore next: electron.net is broken */
		if (options.useElectronNet && process.versions.electron) ***REMOVED***
			const r = (***REMOVED***x: require***REMOVED***)['yx'.slice(1)]; // Trick webpack
			const electron = r('electron');
			fn = electron.net || electron.remote.net;
		***REMOVED***

		if (options.cookieJar) ***REMOVED***
			const cookieString = await getCookieString(currentUrl, ***REMOVED******REMOVED***);

			if (is.nonEmptyString(cookieString)) ***REMOVED***
				options.headers.cookie = cookieString;
			***REMOVED***
		***REMOVED***

		let timings;
		const handleResponse = async response => ***REMOVED***
			try ***REMOVED***
				/* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */
				if (options.useElectronNet) ***REMOVED***
					response = new Proxy(response, ***REMOVED***
						get: (target, name) => ***REMOVED***
							if (name === 'trailers' || name === 'rawTrailers') ***REMOVED***
								return [];
							***REMOVED***

							const value = target[name];
							return is.function(value) ? value.bind(target) : value;
						***REMOVED***
					***REMOVED***);
				***REMOVED***

				const ***REMOVED***statusCode***REMOVED*** = response;
				response.url = currentUrl;
				response.requestUrl = requestUrl;
				response.retryCount = retryCount;
				response.timings = timings;
				response.redirectUrls = redirects;
				response.request = ***REMOVED***
					gotOptions: options
				***REMOVED***;

				const rawCookies = response.headers['set-cookie'];
				if (options.cookieJar && rawCookies) ***REMOVED***
					await Promise.all(rawCookies.map(rawCookie => setCookie(rawCookie, response.url)));
				***REMOVED***

				if (options.followRedirect && 'location' in response.headers) ***REMOVED***
					if (allMethodRedirectCodes.has(statusCode) || (getMethodRedirectCodes.has(statusCode) && (options.method === 'GET' || options.method === 'HEAD'))) ***REMOVED***
						response.resume(); // We're being redirected, we don't care about the response.

						if (statusCode === 303) ***REMOVED***
							// Server responded with "see other", indicating that the resource exists at another location,
							// and the client should request it from that location via GET or HEAD.
							options.method = 'GET';
						***REMOVED***

						if (redirects.length >= 10) ***REMOVED***
							throw new MaxRedirectsError(statusCode, redirects, options);
						***REMOVED***

						// Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
						const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();
						const redirectURL = new URL(redirectBuffer, currentUrl);
						redirectString = redirectURL.toString();

						redirects.push(redirectString);

						const redirectOptions = ***REMOVED***
							...options,
							...urlToOptions(redirectURL)
						***REMOVED***;

						for (const hook of options.hooks.beforeRedirect) ***REMOVED***
							// eslint-disable-next-line no-await-in-loop
							await hook(redirectOptions);
						***REMOVED***

						emitter.emit('redirect', response, redirectOptions);

						await get(redirectOptions);
						return;
					***REMOVED***
				***REMOVED***

				getResponse(response, options, emitter);
			***REMOVED*** catch (error) ***REMOVED***
				emitError(error);
			***REMOVED***
		***REMOVED***;

		const handleRequest = request => ***REMOVED***
			if (shouldAbort) ***REMOVED***
				request.once('error', () => ***REMOVED******REMOVED***);
				request.abort();
				return;
			***REMOVED***

			currentRequest = request;

			request.once('error', error => ***REMOVED***
				if (request.aborted) ***REMOVED***
					return;
				***REMOVED***

				if (error instanceof timedOut.TimeoutError) ***REMOVED***
					error = new TimeoutError(error, options);
				***REMOVED*** else ***REMOVED***
					error = new RequestError(error, options);
				***REMOVED***

				if (emitter.retry(error) === false) ***REMOVED***
					emitError(error);
				***REMOVED***
			***REMOVED***);

			timings = timer(request);

			progress.upload(request, emitter, uploadBodySize);

			if (options.gotTimeout) ***REMOVED***
				timedOut(request, options.gotTimeout, options);
			***REMOVED***

			emitter.emit('request', request);

			const uploadComplete = () => ***REMOVED***
				request.emit('upload-complete');
			***REMOVED***;

			try ***REMOVED***
				if (is.nodeStream(options.body)) ***REMOVED***
					options.body.once('end', uploadComplete);
					options.body.pipe(request);
					options.body = undefined;
				***REMOVED*** else if (options.body) ***REMOVED***
					request.end(options.body, uploadComplete);
				***REMOVED*** else if (input && (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH')) ***REMOVED***
					input.once('end', uploadComplete);
					input.pipe(request);
				***REMOVED*** else ***REMOVED***
					request.end(uploadComplete);
				***REMOVED***
			***REMOVED*** catch (error) ***REMOVED***
				emitError(new RequestError(error, options));
			***REMOVED***
		***REMOVED***;

		if (options.cache) ***REMOVED***
			const cacheableRequest = new CacheableRequest(fn.request, options.cache);
			const cacheRequest = cacheableRequest(options, handleResponse);

			cacheRequest.once('error', error => ***REMOVED***
				if (error instanceof CacheableRequest.RequestError) ***REMOVED***
					emitError(new RequestError(error, options));
				***REMOVED*** else ***REMOVED***
					emitError(new CacheError(error, options));
				***REMOVED***
			***REMOVED***);

			cacheRequest.once('request', handleRequest);
		***REMOVED*** else ***REMOVED***
			// Catches errors thrown by calling fn.request(...)
			try ***REMOVED***
				handleRequest(fn.request(options, handleResponse));
			***REMOVED*** catch (error) ***REMOVED***
				emitError(new RequestError(error, options));
			***REMOVED***
		***REMOVED***
	***REMOVED***;

	emitter.retry = error => ***REMOVED***
		let backoff;

		try ***REMOVED***
			backoff = options.retry.retries(++retryCount, error);
		***REMOVED*** catch (error2) ***REMOVED***
			emitError(error2);
			return;
		***REMOVED***

		if (backoff) ***REMOVED***
			const retry = async options => ***REMOVED***
				try ***REMOVED***
					for (const hook of options.hooks.beforeRetry) ***REMOVED***
						// eslint-disable-next-line no-await-in-loop
						await hook(options, error, retryCount);
					***REMOVED***

					await get(options);
				***REMOVED*** catch (error) ***REMOVED***
					emitError(error);
				***REMOVED***
			***REMOVED***;

			setTimeout(retry, backoff, ***REMOVED***...options, forceRefresh: true***REMOVED***);
			return true;
		***REMOVED***

		return false;
	***REMOVED***;

	emitter.abort = () => ***REMOVED***
		if (currentRequest) ***REMOVED***
			currentRequest.once('error', () => ***REMOVED******REMOVED***);
			currentRequest.abort();
		***REMOVED*** else ***REMOVED***
			shouldAbort = true;
		***REMOVED***
	***REMOVED***;

	setImmediate(async () => ***REMOVED***
		try ***REMOVED***
			// Convert buffer to stream to receive upload progress events (#322)
			const ***REMOVED***body***REMOVED*** = options;
			if (is.buffer(body)) ***REMOVED***
				options.body = toReadableStream(body);
				uploadBodySize = body.length;
			***REMOVED*** else ***REMOVED***
				uploadBodySize = await getBodySize(options);
			***REMOVED***

			if (is.undefined(options.headers['content-length']) && is.undefined(options.headers['transfer-encoding'])) ***REMOVED***
				if ((uploadBodySize > 0 || options.method === 'PUT') && !is.null(uploadBodySize)) ***REMOVED***
					options.headers['content-length'] = uploadBodySize;
				***REMOVED***
			***REMOVED***

			for (const hook of options.hooks.beforeRequest) ***REMOVED***
				// eslint-disable-next-line no-await-in-loop
				await hook(options);
			***REMOVED***

			requestUrl = options.href || (new URL(options.path, urlLib.format(options))).toString();

			await get(options);
		***REMOVED*** catch (error) ***REMOVED***
			emitError(error);
		***REMOVED***
	***REMOVED***);

	return emitter;
***REMOVED***;
