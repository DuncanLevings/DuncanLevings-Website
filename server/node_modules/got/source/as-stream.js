'use strict';
const ***REMOVED***PassThrough***REMOVED*** = require('stream');
const duplexer3 = require('duplexer3');
const requestAsEventEmitter = require('./request-as-event-emitter');
const ***REMOVED***HTTPError, ReadError***REMOVED*** = require('./errors');

module.exports = options => ***REMOVED***
	const input = new PassThrough();
	const output = new PassThrough();
	const proxy = duplexer3(input, output);
	const piped = new Set();
	let isFinished = false;

	options.retry.retries = () => 0;

	if (options.body) ***REMOVED***
		proxy.write = () => ***REMOVED***
			throw new Error('Got\'s stream is not writable when the `body` option is used');
		***REMOVED***;
	***REMOVED***

	const emitter = requestAsEventEmitter(options, input);

	// Cancels the request
	proxy._destroy = emitter.abort;

	emitter.on('response', response => ***REMOVED***
		const ***REMOVED***statusCode***REMOVED*** = response;

		response.on('error', error => ***REMOVED***
			proxy.emit('error', new ReadError(error, options));
		***REMOVED***);

		if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) ***REMOVED***
			proxy.emit('error', new HTTPError(response, options), null, response);
			return;
		***REMOVED***

		isFinished = true;

		response.pipe(output);

		for (const destination of piped) ***REMOVED***
			if (destination.headersSent) ***REMOVED***
				continue;
			***REMOVED***

			for (const [key, value] of Object.entries(response.headers)) ***REMOVED***
				// Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.
				// It's not possible to decompress already decompressed data, is it?
				const allowed = options.decompress ? key !== 'content-encoding' : true;
				if (allowed) ***REMOVED***
					destination.setHeader(key, value);
				***REMOVED***
			***REMOVED***

			destination.statusCode = response.statusCode;
		***REMOVED***

		proxy.emit('response', response);
	***REMOVED***);

	[
		'error',
		'request',
		'redirect',
		'uploadProgress',
		'downloadProgress'
	].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));

	const pipe = proxy.pipe.bind(proxy);
	const unpipe = proxy.unpipe.bind(proxy);
	proxy.pipe = (destination, options) => ***REMOVED***
		if (isFinished) ***REMOVED***
			throw new Error('Failed to pipe. The response has been emitted already.');
		***REMOVED***

		const result = pipe(destination, options);

		if (Reflect.has(destination, 'setHeader')) ***REMOVED***
			piped.add(destination);
		***REMOVED***

		return result;
	***REMOVED***;

	proxy.unpipe = stream => ***REMOVED***
		piped.delete(stream);
		return unpipe(stream);
	***REMOVED***;

	return proxy;
***REMOVED***;
