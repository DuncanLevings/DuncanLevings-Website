'use strict';
const ***REMOVED***URL, URLSearchParams***REMOVED*** = require('url'); // TODO: Use the `URL` global when targeting Node.js 10
const urlLib = require('url');
const is = require('@sindresorhus/is');
const urlParseLax = require('url-parse-lax');
const lowercaseKeys = require('lowercase-keys');
const urlToOptions = require('./utils/url-to-options');
const isFormData = require('./utils/is-form-data');
const merge = require('./merge');
const knownHookEvents = require('./known-hook-events');

const retryAfterStatusCodes = new Set([413, 429, 503]);

// `preNormalize` handles static options (e.g. headers).
// For example, when you create a custom instance and make a request
// with no static changes, they won't be normalized again.
//
// `normalize` operates on dynamic options - they cannot be saved.
// For example, `body` is everytime different per request.
// When it's done normalizing the new options, it performs merge()
// on the prenormalized options and the normalized ones.

const preNormalize = (options, defaults) => ***REMOVED***
	if (is.nullOrUndefined(options.headers)) ***REMOVED***
		options.headers = ***REMOVED******REMOVED***;
	***REMOVED*** else ***REMOVED***
		options.headers = lowercaseKeys(options.headers);
	***REMOVED***

	if (options.baseUrl && !options.baseUrl.toString().endsWith('/')) ***REMOVED***
		options.baseUrl += '/';
	***REMOVED***

	if (options.stream) ***REMOVED***
		options.json = false;
	***REMOVED***

	if (is.nullOrUndefined(options.hooks)) ***REMOVED***
		options.hooks = ***REMOVED******REMOVED***;
	***REMOVED*** else if (!is.object(options.hooks)) ***REMOVED***
		throw new TypeError(`Parameter \`hooks\` must be an object, not $***REMOVED***is(options.hooks)***REMOVED***`);
	***REMOVED***

	for (const event of knownHookEvents) ***REMOVED***
		if (is.nullOrUndefined(options.hooks[event])) ***REMOVED***
			if (defaults) ***REMOVED***
				options.hooks[event] = [...defaults.hooks[event]];
			***REMOVED*** else ***REMOVED***
				options.hooks[event] = [];
			***REMOVED***
		***REMOVED***
	***REMOVED***

	if (is.number(options.timeout)) ***REMOVED***
		options.gotTimeout = ***REMOVED***request: options.timeout***REMOVED***;
	***REMOVED*** else if (is.object(options.timeout)) ***REMOVED***
		options.gotTimeout = options.timeout;
	***REMOVED***

	delete options.timeout;

	const ***REMOVED***retry***REMOVED*** = options;
	options.retry = ***REMOVED***
		retries: 0,
		methods: [],
		statusCodes: [],
		errorCodes: []
	***REMOVED***;

	if (is.nonEmptyObject(defaults) && retry !== false) ***REMOVED***
		options.retry = ***REMOVED***...defaults.retry***REMOVED***;
	***REMOVED***

	if (retry !== false) ***REMOVED***
		if (is.number(retry)) ***REMOVED***
			options.retry.retries = retry;
		***REMOVED*** else ***REMOVED***
			options.retry = ***REMOVED***...options.retry, ...retry***REMOVED***;
		***REMOVED***
	***REMOVED***

	if (options.gotTimeout) ***REMOVED***
		options.retry.maxRetryAfter = Math.min(...[options.gotTimeout.request, options.gotTimeout.connection].filter(n => !is.nullOrUndefined(n)));
	***REMOVED***

	if (is.array(options.retry.methods)) ***REMOVED***
		options.retry.methods = new Set(options.retry.methods.map(method => method.toUpperCase()));
	***REMOVED***

	if (is.array(options.retry.statusCodes)) ***REMOVED***
		options.retry.statusCodes = new Set(options.retry.statusCodes);
	***REMOVED***

	if (is.array(options.retry.errorCodes)) ***REMOVED***
		options.retry.errorCodes = new Set(options.retry.errorCodes);
	***REMOVED***

	return options;
***REMOVED***;

const normalize = (url, options, defaults) => ***REMOVED***
	if (is.plainObject(url)) ***REMOVED***
		options = ***REMOVED***...url, ...options***REMOVED***;
		url = options.url || ***REMOVED******REMOVED***;
		delete options.url;
	***REMOVED***

	if (defaults) ***REMOVED***
		options = merge(***REMOVED******REMOVED***, defaults.options, options ? preNormalize(options, defaults.options) : ***REMOVED******REMOVED***);
	***REMOVED*** else ***REMOVED***
		options = merge(***REMOVED******REMOVED***, preNormalize(options));
	***REMOVED***

	if (!is.string(url) && !is.object(url)) ***REMOVED***
		throw new TypeError(`Parameter \`url\` must be a string or object, not $***REMOVED***is(url)***REMOVED***`);
	***REMOVED***

	if (is.string(url)) ***REMOVED***
		if (options.baseUrl) ***REMOVED***
			if (url.toString().startsWith('/')) ***REMOVED***
				url = url.toString().slice(1);
			***REMOVED***

			url = urlToOptions(new URL(url, options.baseUrl));
		***REMOVED*** else ***REMOVED***
			url = url.replace(/^unix:/, 'http://$&');
			url = urlParseLax(url);
		***REMOVED***
	***REMOVED*** else if (is(url) === 'URL') ***REMOVED***
		url = urlToOptions(url);
	***REMOVED***

	// Override both null/undefined with default protocol
	options = merge(***REMOVED***path: ''***REMOVED***, url, ***REMOVED***protocol: url.protocol || 'https:'***REMOVED***, options);

	for (const hook of options.hooks.init) ***REMOVED***
		const called = hook(options);

		if (is.promise(called)) ***REMOVED***
			throw new TypeError('The `init` hook must be a synchronous function');
		***REMOVED***
	***REMOVED***

	const ***REMOVED***baseUrl***REMOVED*** = options;
	Object.defineProperty(options, 'baseUrl', ***REMOVED***
		set: () => ***REMOVED***
			throw new Error('Failed to set baseUrl. Options are normalized already.');
		***REMOVED***,
		get: () => baseUrl
	***REMOVED***);

	const ***REMOVED***query***REMOVED*** = options;
	if (is.nonEmptyString(query) || is.nonEmptyObject(query) || query instanceof URLSearchParams) ***REMOVED***
		if (!is.string(query)) ***REMOVED***
			options.query = (new URLSearchParams(query)).toString();
		***REMOVED***

		options.path = `$***REMOVED***options.path.split('?')[0]***REMOVED***?$***REMOVED***options.query***REMOVED***`;
		delete options.query;
	***REMOVED***

	if (options.hostname === 'unix') ***REMOVED***
		const matches = /(.+?):(.+)/.exec(options.path);

		if (matches) ***REMOVED***
			const [, socketPath, path] = matches;
			options = ***REMOVED***
				...options,
				socketPath,
				path,
				host: null
			***REMOVED***;
		***REMOVED***
	***REMOVED***

	const ***REMOVED***headers***REMOVED*** = options;
	for (const [key, value] of Object.entries(headers)) ***REMOVED***
		if (is.nullOrUndefined(value)) ***REMOVED***
			delete headers[key];
		***REMOVED***
	***REMOVED***

	if (options.json && is.undefined(headers.accept)) ***REMOVED***
		headers.accept = 'application/json';
	***REMOVED***

	if (options.decompress && is.undefined(headers['accept-encoding'])) ***REMOVED***
		headers['accept-encoding'] = 'gzip, deflate';
	***REMOVED***

	const ***REMOVED***body***REMOVED*** = options;
	if (is.nullOrUndefined(body)) ***REMOVED***
		options.method = options.method ? options.method.toUpperCase() : 'GET';
	***REMOVED*** else ***REMOVED***
		const isObject = is.object(body) && !is.buffer(body) && !is.nodeStream(body);
		if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(options.form || options.json)) ***REMOVED***
			throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');
		***REMOVED***

		if (options.json && !(isObject || is.array(body))) ***REMOVED***
			throw new TypeError('The `body` option must be an Object or Array when the `json` option is used');
		***REMOVED***

		if (options.form && !isObject) ***REMOVED***
			throw new TypeError('The `body` option must be an Object when the `form` option is used');
		***REMOVED***

		if (isFormData(body)) ***REMOVED***
			// Special case for https://github.com/form-data/form-data
			headers['content-type'] = headers['content-type'] || `multipart/form-data; boundary=$***REMOVED***body.getBoundary()***REMOVED***`;
		***REMOVED*** else if (options.form) ***REMOVED***
			headers['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded';
			options.body = (new URLSearchParams(body)).toString();
		***REMOVED*** else if (options.json) ***REMOVED***
			headers['content-type'] = headers['content-type'] || 'application/json';
			options.body = JSON.stringify(body);
		***REMOVED***

		options.method = options.method ? options.method.toUpperCase() : 'POST';
	***REMOVED***

	if (!is.function(options.retry.retries)) ***REMOVED***
		const ***REMOVED***retries***REMOVED*** = options.retry;

		options.retry.retries = (iteration, error) => ***REMOVED***
			if (iteration > retries) ***REMOVED***
				return 0;
			***REMOVED***

			if ((!error || !options.retry.errorCodes.has(error.code)) && (!options.retry.methods.has(error.method) || !options.retry.statusCodes.has(error.statusCode))) ***REMOVED***
				return 0;
			***REMOVED***

			if (Reflect.has(error, 'headers') && Reflect.has(error.headers, 'retry-after') && retryAfterStatusCodes.has(error.statusCode)) ***REMOVED***
				let after = Number(error.headers['retry-after']);
				if (is.nan(after)) ***REMOVED***
					after = Date.parse(error.headers['retry-after']) - Date.now();
				***REMOVED*** else ***REMOVED***
					after *= 1000;
				***REMOVED***

				if (after > options.retry.maxRetryAfter) ***REMOVED***
					return 0;
				***REMOVED***

				return after;
			***REMOVED***

			if (error.statusCode === 413) ***REMOVED***
				return 0;
			***REMOVED***

			const noise = Math.random() * 100;
			return ((2 ** (iteration - 1)) * 1000) + noise;
		***REMOVED***;
	***REMOVED***

	return options;
***REMOVED***;

const reNormalize = options => normalize(urlLib.format(options), options);

module.exports = normalize;
module.exports.preNormalize = preNormalize;
module.exports.reNormalize = reNormalize;
