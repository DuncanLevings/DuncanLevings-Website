'use strict';
const EventEmitter = require('events');
const getStream = require('get-stream');
const is = require('@sindresorhus/is');
const PCancelable = require('p-cancelable');
const requestAsEventEmitter = require('./request-as-event-emitter');
const ***REMOVED***HTTPError, ParseError, ReadError***REMOVED*** = require('./errors');
const ***REMOVED***options: mergeOptions***REMOVED*** = require('./merge');
const ***REMOVED***reNormalize***REMOVED*** = require('./normalize-arguments');

const asPromise = options => ***REMOVED***
	const proxy = new EventEmitter();

	const promise = new PCancelable((resolve, reject, onCancel) => ***REMOVED***
		const emitter = requestAsEventEmitter(options);

		onCancel(emitter.abort);

		emitter.on('response', async response => ***REMOVED***
			proxy.emit('response', response);

			const stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);

			let data;
			try ***REMOVED***
				data = await stream;
			***REMOVED*** catch (error) ***REMOVED***
				reject(new ReadError(error, options));
				return;
			***REMOVED***

			const limitStatusCode = options.followRedirect ? 299 : 399;

			response.body = data;

			try ***REMOVED***
				for (const [index, hook] of Object.entries(options.hooks.afterResponse)) ***REMOVED***
					// eslint-disable-next-line no-await-in-loop
					response = await hook(response, updatedOptions => ***REMOVED***
						updatedOptions = reNormalize(mergeOptions(options, ***REMOVED***
							...updatedOptions,
							retry: 0,
							throwHttpErrors: false
						***REMOVED***));

						// Remove any further hooks for that request, because we we'll call them anyway.
						// The loop continues. We don't want duplicates (asPromise recursion).
						updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);

						return asPromise(updatedOptions);
					***REMOVED***);
				***REMOVED***
			***REMOVED*** catch (error) ***REMOVED***
				reject(error);
				return;
			***REMOVED***

			const ***REMOVED***statusCode***REMOVED*** = response;

			if (options.json && response.body) ***REMOVED***
				try ***REMOVED***
					response.body = JSON.parse(response.body);
				***REMOVED*** catch (error) ***REMOVED***
					if (statusCode >= 200 && statusCode < 300) ***REMOVED***
						const parseError = new ParseError(error, statusCode, options, data);
						Object.defineProperty(parseError, 'response', ***REMOVED***value: response***REMOVED***);
						reject(parseError);
						return;
					***REMOVED***
				***REMOVED***
			***REMOVED***

			if (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) ***REMOVED***
				const error = new HTTPError(response, options);
				Object.defineProperty(error, 'response', ***REMOVED***value: response***REMOVED***);
				if (emitter.retry(error) === false) ***REMOVED***
					if (options.throwHttpErrors) ***REMOVED***
						reject(error);
						return;
					***REMOVED***

					resolve(response);
				***REMOVED***

				return;
			***REMOVED***

			resolve(response);
		***REMOVED***);

		emitter.once('error', reject);
		[
			'request',
			'redirect',
			'uploadProgress',
			'downloadProgress'
		].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));
	***REMOVED***);

	promise.on = (name, fn) => ***REMOVED***
		proxy.on(name, fn);
		return promise;
	***REMOVED***;

	return promise;
***REMOVED***;

module.exports = asPromise;
