'use strict';
const net = require('net');

class TimeoutError extends Error ***REMOVED***
	constructor(threshold, event) ***REMOVED***
		super(`Timeout awaiting '$***REMOVED***event***REMOVED***' for $***REMOVED***threshold***REMOVED***ms`);
		this.name = 'TimeoutError';
		this.code = 'ETIMEDOUT';
		this.event = event;
	***REMOVED***
***REMOVED***

const reentry = Symbol('reentry');

const noop = () => ***REMOVED******REMOVED***;

module.exports = (request, delays, options) => ***REMOVED***
	/* istanbul ignore next: this makes sure timed-out isn't called twice */
	if (request[reentry]) ***REMOVED***
		return;
	***REMOVED***

	request[reentry] = true;

	let stopNewTimeouts = false;

	const addTimeout = (delay, callback, ...args) => ***REMOVED***
		// An error had been thrown before. Going further would result in uncaught errors.
		// See https://github.com/sindresorhus/got/issues/631#issuecomment-435675051
		if (stopNewTimeouts) ***REMOVED***
			return noop;
		***REMOVED***

		// Event loop order is timers, poll, immediates.
		// The timed event may emit during the current tick poll phase, so
		// defer calling the handler until the poll phase completes.
		let immediate;
		const timeout = setTimeout(() => ***REMOVED***
			immediate = setImmediate(callback, delay, ...args);
			/* istanbul ignore next: added in node v9.7.0 */
			if (immediate.unref) ***REMOVED***
				immediate.unref();
			***REMOVED***
		***REMOVED***, delay);

		/* istanbul ignore next: in order to support electron renderer */
		if (timeout.unref) ***REMOVED***
			timeout.unref();
		***REMOVED***

		const cancel = () => ***REMOVED***
			clearTimeout(timeout);
			clearImmediate(immediate);
		***REMOVED***;

		cancelers.push(cancel);

		return cancel;
	***REMOVED***;

	const ***REMOVED***host, hostname***REMOVED*** = options;
	const timeoutHandler = (delay, event) => ***REMOVED***
		request.emit('error', new TimeoutError(delay, event));
		request.once('error', () => ***REMOVED******REMOVED***); // Ignore the `socket hung up` error made by request.abort()

		request.abort();
	***REMOVED***;

	const cancelers = [];
	const cancelTimeouts = () => ***REMOVED***
		stopNewTimeouts = true;
		cancelers.forEach(cancelTimeout => cancelTimeout());
	***REMOVED***;

	request.once('error', cancelTimeouts);
	request.once('response', response => ***REMOVED***
		response.once('end', cancelTimeouts);
	***REMOVED***);

	if (delays.request !== undefined) ***REMOVED***
		addTimeout(delays.request, timeoutHandler, 'request');
	***REMOVED***

	if (delays.socket !== undefined) ***REMOVED***
		const socketTimeoutHandler = () => ***REMOVED***
			timeoutHandler(delays.socket, 'socket');
		***REMOVED***;

		request.setTimeout(delays.socket, socketTimeoutHandler);

		// `request.setTimeout(0)` causes a memory leak.
		// We can just remove the listener and forget about the timer - it's unreffed.
		// See https://github.com/sindresorhus/got/issues/690
		cancelers.push(() => request.removeListener('timeout', socketTimeoutHandler));
	***REMOVED***

	if (delays.lookup !== undefined && !request.socketPath && !net.isIP(hostname || host)) ***REMOVED***
		request.once('socket', socket => ***REMOVED***
			/* istanbul ignore next: hard to test */
			if (socket.connecting) ***REMOVED***
				const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
				socket.once('lookup', cancelTimeout);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	if (delays.connect !== undefined) ***REMOVED***
		request.once('socket', socket => ***REMOVED***
			/* istanbul ignore next: hard to test */
			if (socket.connecting) ***REMOVED***
				const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');

				if (request.socketPath || net.isIP(hostname || host)) ***REMOVED***
					socket.once('connect', timeConnect());
				***REMOVED*** else ***REMOVED***
					socket.once('lookup', error => ***REMOVED***
						if (error === null) ***REMOVED***
							socket.once('connect', timeConnect());
						***REMOVED***
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	if (delays.secureConnect !== undefined && options.protocol === 'https:') ***REMOVED***
		request.once('socket', socket => ***REMOVED***
			/* istanbul ignore next: hard to test */
			if (socket.connecting) ***REMOVED***
				socket.once('connect', () => ***REMOVED***
					const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
					socket.once('secureConnect', cancelTimeout);
				***REMOVED***);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	if (delays.send !== undefined) ***REMOVED***
		request.once('socket', socket => ***REMOVED***
			const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');
			/* istanbul ignore next: hard to test */
			if (socket.connecting) ***REMOVED***
				socket.once('connect', () => ***REMOVED***
					request.once('upload-complete', timeRequest());
				***REMOVED***);
			***REMOVED*** else ***REMOVED***
				request.once('upload-complete', timeRequest());
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	if (delays.response !== undefined) ***REMOVED***
		request.once('upload-complete', () => ***REMOVED***
			const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
			request.once('response', cancelTimeout);
		***REMOVED***);
	***REMOVED***
***REMOVED***;

module.exports.TimeoutError = TimeoutError;
