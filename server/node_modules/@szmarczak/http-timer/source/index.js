'use strict';
const deferToConnect = require('defer-to-connect');

module.exports = request => ***REMOVED***
	const timings = ***REMOVED***
		start: Date.now(),
		socket: null,
		lookup: null,
		connect: null,
		upload: null,
		response: null,
		end: null,
		error: null,
		phases: ***REMOVED***
			wait: null,
			dns: null,
			tcp: null,
			request: null,
			firstByte: null,
			download: null,
			total: null
		***REMOVED***
	***REMOVED***;

	const handleError = origin => ***REMOVED***
		const emit = origin.emit.bind(origin);
		origin.emit = (event, ...args) => ***REMOVED***
			// Catches the `error` event
			if (event === 'error') ***REMOVED***
				timings.error = Date.now();
				timings.phases.total = timings.error - timings.start;

				origin.emit = emit;
			***REMOVED***

			// Saves the original behavior
			return emit(event, ...args);
		***REMOVED***;
	***REMOVED***;

	let uploadFinished = false;
	const onUpload = () => ***REMOVED***
		timings.upload = Date.now();
		timings.phases.request = timings.upload - timings.connect;
	***REMOVED***;

	handleError(request);

	request.once('socket', socket => ***REMOVED***
		timings.socket = Date.now();
		timings.phases.wait = timings.socket - timings.start;

		const lookupListener = () => ***REMOVED***
			timings.lookup = Date.now();
			timings.phases.dns = timings.lookup - timings.socket;
		***REMOVED***;

		socket.once('lookup', lookupListener);

		deferToConnect(socket, () => ***REMOVED***
			timings.connect = Date.now();

			if (timings.lookup === null) ***REMOVED***
				socket.removeListener('lookup', lookupListener);
				timings.lookup = timings.connect;
				timings.phases.dns = timings.lookup - timings.socket;
			***REMOVED***

			timings.phases.tcp = timings.connect - timings.lookup;

			if (uploadFinished && !timings.upload) ***REMOVED***
				onUpload();
			***REMOVED***
		***REMOVED***);
	***REMOVED***);

	request.once('finish', () => ***REMOVED***
		uploadFinished = true;

		if (timings.connect) ***REMOVED***
			onUpload();
		***REMOVED***
	***REMOVED***);

	request.once('response', response => ***REMOVED***
		timings.response = Date.now();
		timings.phases.firstByte = timings.response - timings.upload;

		handleError(response);

		response.once('end', () => ***REMOVED***
			timings.end = Date.now();
			timings.phases.download = timings.end - timings.response;
			timings.phases.total = timings.end - timings.start;
		***REMOVED***);
	***REMOVED***);

	return timings;
***REMOVED***;
