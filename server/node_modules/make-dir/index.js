'use strict';
const fs = require('fs');
const path = require('path');
const ***REMOVED***promisify***REMOVED*** = require('util');
const semver = require('semver');

const useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0');

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const checkPath = pth => ***REMOVED***
	if (process.platform === 'win32') ***REMOVED***
		const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

		if (pathHasInvalidWinCharacters) ***REMOVED***
			const error = new Error(`Path contains invalid characters: $***REMOVED***pth***REMOVED***`);
			error.code = 'EINVAL';
			throw error;
		***REMOVED***
	***REMOVED***
***REMOVED***;

const processOptions = options => ***REMOVED***
	// https://github.com/sindresorhus/make-dir/issues/18
	const defaults = ***REMOVED***
		mode: 0o777,
		fs
	***REMOVED***;

	return ***REMOVED***
		...defaults,
		...options
	***REMOVED***;
***REMOVED***;

const permissionError = pth => ***REMOVED***
	// This replicates the exception of `fs.mkdir` with native the
	// `recusive` option when run on an invalid drive under Windows.
	const error = new Error(`operation not permitted, mkdir '$***REMOVED***pth***REMOVED***'`);
	error.code = 'EPERM';
	error.errno = -4048;
	error.path = pth;
	error.syscall = 'mkdir';
	return error;
***REMOVED***;

const makeDir = async (input, options) => ***REMOVED***
	checkPath(input);
	options = processOptions(options);

	const mkdir = promisify(options.fs.mkdir);
	const stat = promisify(options.fs.stat);

	if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) ***REMOVED***
		const pth = path.resolve(input);

		await mkdir(pth, ***REMOVED***
			mode: options.mode,
			recursive: true
		***REMOVED***);

		return pth;
	***REMOVED***

	const make = async pth => ***REMOVED***
		try ***REMOVED***
			await mkdir(pth, options.mode);

			return pth;
		***REMOVED*** catch (error) ***REMOVED***
			if (error.code === 'EPERM') ***REMOVED***
				throw error;
			***REMOVED***

			if (error.code === 'ENOENT') ***REMOVED***
				if (path.dirname(pth) === pth) ***REMOVED***
					throw permissionError(pth);
				***REMOVED***

				if (error.message.includes('null bytes')) ***REMOVED***
					throw error;
				***REMOVED***

				await make(path.dirname(pth));

				return make(pth);
			***REMOVED***

			try ***REMOVED***
				const stats = await stat(pth);
				if (!stats.isDirectory()) ***REMOVED***
					throw new Error('The path is not a directory');
				***REMOVED***
			***REMOVED*** catch (_) ***REMOVED***
				throw error;
			***REMOVED***

			return pth;
		***REMOVED***
	***REMOVED***;

	return make(path.resolve(input));
***REMOVED***;

module.exports = makeDir;

module.exports.sync = (input, options) => ***REMOVED***
	checkPath(input);
	options = processOptions(options);

	if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) ***REMOVED***
		const pth = path.resolve(input);

		fs.mkdirSync(pth, ***REMOVED***
			mode: options.mode,
			recursive: true
		***REMOVED***);

		return pth;
	***REMOVED***

	const make = pth => ***REMOVED***
		try ***REMOVED***
			options.fs.mkdirSync(pth, options.mode);
		***REMOVED*** catch (error) ***REMOVED***
			if (error.code === 'EPERM') ***REMOVED***
				throw error;
			***REMOVED***

			if (error.code === 'ENOENT') ***REMOVED***
				if (path.dirname(pth) === pth) ***REMOVED***
					throw permissionError(pth);
				***REMOVED***

				if (error.message.includes('null bytes')) ***REMOVED***
					throw error;
				***REMOVED***

				make(path.dirname(pth));
				return make(pth);
			***REMOVED***

			try ***REMOVED***
				if (!options.fs.statSync(pth).isDirectory()) ***REMOVED***
					throw new Error('The path is not a directory');
				***REMOVED***
			***REMOVED*** catch (_) ***REMOVED***
				throw error;
			***REMOVED***
		***REMOVED***

		return pth;
	***REMOVED***;

	return make(path.resolve(input));
***REMOVED***;
