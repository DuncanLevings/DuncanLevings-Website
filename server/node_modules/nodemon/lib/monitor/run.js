var debug = require('debug')('nodemon:run');
const statSync = require('fs').statSync;
var utils = require('../utils');
var bus = utils.bus;
var childProcess = require('child_process');
var spawn = childProcess.spawn;
var exec = childProcess.exec;
var fork = childProcess.fork;
var watch = require('./watch').watch;
var config = require('../config');
var child = null; // the actual child process we spawn
var killedAfterChange = false;
var noop = () => ***REMOVED******REMOVED***;
var restart = null;
var psTree = require('pstree.remy');
var path = require('path');
var signals = require('./signals');

function run(options) ***REMOVED***
  var cmd = config.command.raw;

  var runCmd = !options.runOnChangeOnly || config.lastStarted !== 0;
  if (runCmd) ***REMOVED***
    utils.log.status('starting `' + config.command.string + '`');
  ***REMOVED***

  /*jshint validthis:true*/
  restart = run.bind(this, options);
  run.restart = restart;

  config.lastStarted = Date.now();

  var stdio = ['pipe', 'pipe', 'pipe'];

  if (config.options.stdout) ***REMOVED***
    stdio = ['pipe', process.stdout, process.stderr];
  ***REMOVED***

  if (config.options.stdin === false) ***REMOVED***
    stdio = [process.stdin, process.stdout, process.stderr];
  ***REMOVED***

  var sh = 'sh';
  var shFlag = '-c';

  const binPath = process.cwd() + '/node_modules/.bin';

  const spawnOptions = ***REMOVED***
    env: Object.assign(***REMOVED******REMOVED***, process.env, options.execOptions.env, ***REMOVED***
      PATH: binPath + ':' + process.env.PATH,
    ***REMOVED***),
    stdio: stdio,
  ***REMOVED***

  var executable = cmd.executable;

  if (utils.isWindows) ***REMOVED***
    // if the exec includes a forward slash, reverse it for windows compat
    // but *only* apply to the first command, and none of the arguments.
    // ref #1251 and #1236
    if (executable.indexOf('/') !== -1) ***REMOVED***
      executable = executable.split(' ').map((e, i) => ***REMOVED***
        if (i === 0) ***REMOVED***
          return path.normalize(e);
        ***REMOVED***
        return e;
      ***REMOVED***).join(' ');
    ***REMOVED***
    // taken from npm's cli: https://git.io/vNFD4
    sh = process.env.comspec || 'cmd';
    shFlag = '/d /s /c';
    spawnOptions.windowsVerbatimArguments = true;
  ***REMOVED***

  var args = runCmd ? utils.stringify(executable, cmd.args) : ':';
  var spawnArgs = [sh, [shFlag, args], spawnOptions];

  const firstArg = cmd.args[0] || '';

  var inBinPath = false;
  try ***REMOVED***
    inBinPath = statSync(`$***REMOVED***binPath***REMOVED***/$***REMOVED***executable***REMOVED***`).isFile();
  ***REMOVED*** catch (e) ***REMOVED******REMOVED***

  // hasStdio allows us to correctly handle stdin piping
  // see: https://git.io/vNtX3
  const hasStdio = utils.satisfies('>= 6.4.0 || < 5');

  // forking helps with sub-process handling and tends to clean up better
  // than spawning, but it should only be used under specific conditions
  const shouldFork =
    !config.options.spawn &&
    !inBinPath &&
    !(firstArg.indexOf('-') === 0) && // don't fork if there's a node exec arg
    firstArg !== 'inspect' && // don't fork it's `inspect` debugger
    executable === 'node' && // only fork if node
    utils.version.major > 4 // only fork if node version > 4

  if (shouldFork) ***REMOVED***
    var forkArgs = cmd.args.slice(1);
    var env = utils.merge(options.execOptions.env, process.env);
    stdio.push('ipc');
    child = fork(options.execOptions.script, forkArgs, ***REMOVED***
      env: env,
      stdio: stdio,
      silent: !hasStdio,
    ***REMOVED***);
    utils.log.detail('forking');
    debug('fork', sh, shFlag, args)
  ***REMOVED*** else ***REMOVED***
    utils.log.detail('spawning');
    child = spawn.apply(null, spawnArgs);
    debug('spawn', sh, shFlag, args);
  ***REMOVED***

  if (config.required) ***REMOVED***
    var emit = ***REMOVED***
      stdout: function (data) ***REMOVED***
        bus.emit('stdout', data);
      ***REMOVED***,
      stderr: function (data) ***REMOVED***
        bus.emit('stderr', data);
      ***REMOVED***,
    ***REMOVED***;

    // now work out what to bind to...
    if (config.options.stdout) ***REMOVED***
      child.on('stdout', emit.stdout).on('stderr', emit.stderr);
    ***REMOVED*** else ***REMOVED***
      child.stdout.on('data', emit.stdout);
      child.stderr.on('data', emit.stderr);

      bus.stdout = child.stdout;
      bus.stderr = child.stderr;
    ***REMOVED***

    if (shouldFork) ***REMOVED***
      child.on('message', function (message, sendHandle) ***REMOVED***
        bus.emit('message', message, sendHandle);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  bus.emit('start');

  utils.log.detail('child pid: ' + child.pid);

  child.on('error', function (error) ***REMOVED***
    bus.emit('error', error);
    if (error.code === 'ENOENT') ***REMOVED***
      utils.log.error('unable to run executable: "' + cmd.executable + '"');
      process.exit(1);
    ***REMOVED*** else ***REMOVED***
      utils.log.error('failed to start child process: ' + error.code);
      throw error;
    ***REMOVED***
  ***REMOVED***);

  child.on('exit', function (code, signal) ***REMOVED***
    if (child && child.stdin) ***REMOVED***
      process.stdin.unpipe(child.stdin);
    ***REMOVED***

    if (code === 127) ***REMOVED***
      utils.log.error('failed to start process, "' + cmd.executable +
        '" exec not found');
      bus.emit('error', code);
      process.exit();
    ***REMOVED***

    // If the command failed with code 2, it may or may not be a syntax error
    // See: http://git.io/fNOAR
    // We will only assume a parse error, if the child failed quickly
    if (code === 2 && Date.now() < config.lastStarted + 500) ***REMOVED***
      utils.log.error('process failed, unhandled exit code (2)');
      utils.log.error('');
      utils.log.error('Either the command has a syntax error,');
      utils.log.error('or it is exiting with reserved code 2.');
      utils.log.error('');
      utils.log.error('To keep nodemon running even after a code 2,');
      utils.log.error('add this to the end of your command: || exit 1');
      utils.log.error('');
      utils.log.error('Read more here: https://git.io/fNOAG');
      utils.log.error('');
      utils.log.error('nodemon will stop now so that you can fix the command.');
      utils.log.error('');
      bus.emit('error', code);
      process.exit();
    ***REMOVED***

    // In case we killed the app ourselves, set the signal thusly
    if (killedAfterChange) ***REMOVED***
      killedAfterChange = false;
      signal = config.signal;
    ***REMOVED***
    // this is nasty, but it gives it windows support
    if (utils.isWindows && signal === 'SIGTERM') ***REMOVED***
      signal = config.signal;
    ***REMOVED***

    if (signal === config.signal || code === 0) ***REMOVED***
      // this was a clean exit, so emit exit, rather than crash
      debug('bus.emit(exit) via ' + config.signal);
      bus.emit('exit', signal);

      // exit the monitor, but do it gracefully
      if (signal === config.signal) ***REMOVED***
        return restart();
      ***REMOVED***

      if (code === 0) ***REMOVED*** // clean exit - wait until file change to restart
        if (runCmd) ***REMOVED***
          utils.log.status('clean exit - waiting for changes before restart');
        ***REMOVED***
        child = null;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      bus.emit('crash');
      if (options.exitcrash) ***REMOVED***
        utils.log.fail('app crashed');
        if (!config.required) ***REMOVED***
          process.exit(1);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        utils.log.fail('app crashed - waiting for file changes before' +
          ' starting...');
        child = null;
      ***REMOVED***
    ***REMOVED***

    if (config.options.restartable) ***REMOVED***
      // stdin needs to kick in again to be able to listen to the
      // restart command
      process.stdin.resume();
    ***REMOVED***
  ***REMOVED***);

  run.kill = function (noRestart, callback) ***REMOVED***
    // I hate code like this :(  - Remy (author of said code)
    if (typeof noRestart === 'function') ***REMOVED***
      callback = noRestart;
      noRestart = false;
    ***REMOVED***

    if (!callback) ***REMOVED***
      callback = noop;
    ***REMOVED***

    if (child !== null) ***REMOVED***
      // if the stdin piping is on, we need to unpipe, but also close stdin on
      // the child, otherwise linux can throw EPIPE or ECONNRESET errors.
      if (options.stdin) ***REMOVED***
        process.stdin.unpipe(child.stdin);
      ***REMOVED***

      // For the on('exit', ...) handler above the following looks like a
      // crash, so we set the killedAfterChange flag if a restart is planned
      if (!noRestart) ***REMOVED***
        killedAfterChange = true;
      ***REMOVED***

      /* Now kill the entire subtree of processes belonging to nodemon */
      var oldPid = child.pid;
      if (child) ***REMOVED***
        kill(child, config.signal, function () ***REMOVED***
          // this seems to fix the 0.11.x issue with the "rs" restart command,
          // though I'm unsure why. it seems like more data is streamed in to
          // stdin after we close.
          if (child && options.stdin && child.stdin && oldPid === child.pid) ***REMOVED***
            child.stdin.end();
          ***REMOVED***
          callback();
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else if (!noRestart) ***REMOVED***
      // if there's no child, then we need to manually start the process
      // this is because as there was no child, the child.on('exit') event
      // handler doesn't exist which would normally trigger the restart.
      bus.once('start', callback);
      restart();
    ***REMOVED*** else ***REMOVED***
      callback();
    ***REMOVED***
  ***REMOVED***;

  // connect stdin to the child process (options.stdin is on by default)
  if (options.stdin) ***REMOVED***
    process.stdin.resume();
    // FIXME decide whether or not we need to decide the encoding
    // process.stdin.setEncoding('utf8');

    // swallow the stdin error if it happens
    // ref: https://github.com/remy/nodemon/issues/1195
    if (hasStdio) ***REMOVED***
      child.stdin.on('error', () => ***REMOVED*** ***REMOVED***);
      process.stdin.pipe(child.stdin);
    ***REMOVED*** else ***REMOVED***
      if (child.stdout) ***REMOVED***
        child.stdout.pipe(process.stdout);
      ***REMOVED*** else ***REMOVED***
        utils.log.error('running an unsupported version of node ' +
          process.version);
        utils.log.error('nodemon may not work as expected - ' +
          'please consider upgrading to LTS');
      ***REMOVED***
    ***REMOVED***

    bus.once('exit', function () ***REMOVED***
      if (child && process.stdin.unpipe) ***REMOVED*** // node > 0.8
        process.stdin.unpipe(child.stdin);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  debug('start watch on: %s', config.options.watch);
  if (config.options.watch !== false) ***REMOVED***
    watch();
  ***REMOVED***
***REMOVED***

function waitForSubProcesses(pid, callback) ***REMOVED***
  debug('checking ps tree for pids of ' + pid);
  psTree(pid, (err, pids) => ***REMOVED***
    if (!pids.length) ***REMOVED***
      return callback();
    ***REMOVED***

    utils.log.status(`still waiting for $***REMOVED***pids.length***REMOVED*** sub-process$***REMOVED***
      pids.length > 2 ? 'es' : ''***REMOVED*** to finish...`);
    setTimeout(() => waitForSubProcesses(pid, callback), 1000);
  ***REMOVED***);
***REMOVED***

function kill(child, signal, callback) ***REMOVED***
  if (!callback) ***REMOVED***
    callback = function () ***REMOVED*** ***REMOVED***;
  ***REMOVED***

  if (utils.isWindows) ***REMOVED***
    // When using CoffeeScript under Windows, child's process is not node.exe
    // Instead coffee.cmd is launched, which launches cmd.exe, which starts
    // node.exe as a child process child.kill() would only kill cmd.exe, not
    // node.exe
    // Therefore we use the Windows taskkill utility to kill the process and all
    // its children (/T for tree).
    // Force kill (/F) the whole child tree (/T) by PID (/PID 123)
    exec('taskkill /pid ' + child.pid + ' /T /F');
    callback();
  ***REMOVED*** else ***REMOVED***
    // we use psTree to kill the full subtree of nodemon, because when
    // spawning processes like `coffee` under the `--debug` flag, it'll spawn
    // it's own child, and that can't be killed by nodemon, so psTree gives us
    // an array of PIDs that have spawned under nodemon, and we send each the
    // configured signal (default: SIGUSR2) signal, which fixes #335
    // note that psTree also works if `ps` is missing by looking in /proc
    let sig = signal.replace('SIG', '');

    psTree(child.pid, function (err, pids) ***REMOVED***
      // if ps isn't native to the OS, then we need to send the numeric value
      // for the signal during the kill, `signals` is a lookup table for that.
      if (!psTree.hasPS) ***REMOVED***
        sig = signals[signal];
      ***REMOVED***

      // the sub processes need to be killed from smallest to largest
      debug('sending kill signal to ' + pids.join(', '));

      child.kill(signal);

      pids.sort().forEach(pid => exec(`kill -$***REMOVED***sig***REMOVED*** $***REMOVED***pid***REMOVED***`, noop));

      waitForSubProcesses(child.pid, () => ***REMOVED***
        // finally kill the main user process
        exec(`kill -$***REMOVED***sig***REMOVED*** $***REMOVED***child.pid***REMOVED***`, callback);
      ***REMOVED***);

    ***REMOVED***);

  ***REMOVED***
***REMOVED***

// stubbed out for now, filled in during run
run.kill = function (flag, callback) ***REMOVED***
  if (callback) ***REMOVED***
    callback();
  ***REMOVED***
***REMOVED***;
run.restart = noop;

bus.on('quit', function onQuit(code) ***REMOVED***
  if (code === undefined) ***REMOVED***
    code = 0;
  ***REMOVED***

  // remove event listener
  var exitTimer = null;
  var exit = function () ***REMOVED***
    clearTimeout(exitTimer);
    exit = noop; // null out in case of race condition
    child = null;
    if (!config.required) ***REMOVED***
      // Execute all other quit listeners.
      bus.listeners('quit').forEach(function (listener) ***REMOVED***
        if (listener !== onQuit) ***REMOVED***
          listener();
        ***REMOVED***
      ***REMOVED***);
      process.exit(code);
    ***REMOVED*** else ***REMOVED***
      bus.emit('exit');
    ***REMOVED***
  ***REMOVED***;

  // if we're not running already, don't bother with trying to kill
  if (config.run === false) ***REMOVED***
    return exit();
  ***REMOVED***

  // immediately try to stop any polling
  config.run = false;

  if (child) ***REMOVED***
    // give up waiting for the kids after 10 seconds
    exitTimer = setTimeout(exit, 10 * 1000);
    child.removeAllListeners('exit');
    child.once('exit', exit);

    kill(child, 'SIGINT');
  ***REMOVED*** else ***REMOVED***
    exit();
  ***REMOVED***
***REMOVED***);

bus.on('restart', function () ***REMOVED***
  // run.kill will send a SIGINT to the child process, which will cause it
  // to terminate, which in turn uses the 'exit' event handler to restart
  run.kill();
***REMOVED***);

// remove the child file on exit
process.on('exit', function () ***REMOVED***
  utils.log.detail('exiting');
  if (child) ***REMOVED*** child.kill(); ***REMOVED***
***REMOVED***);

// because windows borks when listening for the SIG* events
if (!utils.isWindows) ***REMOVED***
  bus.once('boot', () => ***REMOVED***
    // usual suspect: ctrl+c exit
    process.once('SIGINT', () => bus.emit('quit', 130));
    process.once('SIGTERM', () => ***REMOVED***
      bus.emit('quit', 143);
      if (child) ***REMOVED*** child.kill('SIGTERM'); ***REMOVED***
    ***REMOVED***);
  ***REMOVED***)
***REMOVED***


module.exports = run;
