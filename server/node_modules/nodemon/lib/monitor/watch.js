module.exports.watch = watch;
module.exports.resetWatchers = resetWatchers;

var debug = require('debug')('nodemon:watch');
var debugRoot = require('debug')('nodemon');
var chokidar = require('chokidar');
var undefsafe = require('undefsafe');
var config = require('../config');
var path = require('path');
var utils = require('../utils');
var bus = utils.bus;
var match = require('./match');
var watchers = [];
var debouncedBus;

bus.on('reset', resetWatchers);

function resetWatchers() ***REMOVED***
  debugRoot('resetting watchers');
  watchers.forEach(function (watcher) ***REMOVED***
    watcher.close();
  ***REMOVED***);
  watchers = [];
***REMOVED***

function watch() ***REMOVED***
  if (watchers.length) ***REMOVED***
    debug('early exit on watch, still watching (%s)', watchers.length);
    return;
  ***REMOVED***

  var dirs = [].slice.call(config.dirs);

  debugRoot('start watch on: %s', dirs.join(', '));
  const rootIgnored = config.options.ignore;
  debugRoot('ignored', rootIgnored);

  var watchedFiles = [];

  const promise = new Promise(function (resolve) ***REMOVED***
    const dotFilePattern = /[/\\]\./;
    var ignored = match.rulesToMonitor(
      [], // not needed
      Array.from(rootIgnored),
      config
    ).map(pattern => pattern.slice(1));

    const addDotFile = dirs.filter(dir => dir.match(dotFilePattern));

    // don't ignore dotfiles if explicitly watched.
    if (addDotFile.length === 0) ***REMOVED***
      ignored.push(dotFilePattern);
    ***REMOVED***

    var watchOptions = ***REMOVED***
      ignorePermissionErrors: true,
      ignored: ignored,
      persistent: true,
      usePolling: config.options.legacyWatch || false,
      interval: config.options.pollingInterval,
      // note to future developer: I've gone back and forth on adding `cwd`
      // to the props and in some cases it fixes bugs but typically it causes
      // bugs elsewhere (since nodemon is used is so many ways). the final
      // decision is to *not* use it at all and work around it
      // cwd: ...
    ***REMOVED***;

    if (utils.isWindows) ***REMOVED***
      watchOptions.disableGlobbing = true;
    ***REMOVED***

    if (process.env.TEST) ***REMOVED***
      watchOptions.useFsEvents = false;
    ***REMOVED***

    var watcher = chokidar.watch(
      dirs,
      Object.assign(***REMOVED******REMOVED***, watchOptions, config.options.watchOptions || ***REMOVED******REMOVED***)
    );

    watcher.ready = false;

    var total = 0;

    watcher.on('change', filterAndRestart);
    watcher.on('add', function (file) ***REMOVED***
      if (watcher.ready) ***REMOVED***
        return filterAndRestart(file);
      ***REMOVED***

      watchedFiles.push(file);
      bus.emit('watching', file);
      debug('chokidar watching: %s', file);
    ***REMOVED***);
    watcher.on('ready', function () ***REMOVED***
      watchedFiles = Array.from(new Set(watchedFiles)); // ensure no dupes
      total = watchedFiles.length;
      watcher.ready = true;
      resolve(total);
      debugRoot('watch is complete');
    ***REMOVED***);

    watcher.on('error', function (error) ***REMOVED***
      if (error.code === 'EINVAL') ***REMOVED***
        utils.log.error(
          'Internal watch failed. Likely cause: too many ' +
          'files being watched (perhaps from the root of a drive?\n' +
          'See https://github.com/paulmillr/chokidar/issues/229 for details'
        );
      ***REMOVED*** else ***REMOVED***
        utils.log.error('Internal watch failed: ' + error.message);
        process.exit(1);
      ***REMOVED***
    ***REMOVED***);

    watchers.push(watcher);
  ***REMOVED***);

  return promise.catch(e => ***REMOVED***
    // this is a core error and it should break nodemon - so I have to break
    // out of a promise using the setTimeout
    setTimeout(() => ***REMOVED***
      throw e;
    ***REMOVED***);
  ***REMOVED***).then(function () ***REMOVED***
    utils.log.detail(`watching $***REMOVED***watchedFiles.length***REMOVED*** file$***REMOVED***
      watchedFiles.length === 1 ? '' : 's'***REMOVED***`);
    return watchedFiles;
  ***REMOVED***);
***REMOVED***

function filterAndRestart(files) ***REMOVED***
  if (!Array.isArray(files)) ***REMOVED***
    files = [files];
  ***REMOVED***

  if (files.length) ***REMOVED***
    var cwd = process.cwd();
    if (this.options && this.options.cwd) ***REMOVED***
      cwd = this.options.cwd;
    ***REMOVED***

    utils.log.detail(
      'files triggering change check: ' +
      files
        .map(file => ***REMOVED***
          const res = path.relative(cwd, file);
          return res;
        ***REMOVED***)
        .join(', ')
    );

    // make sure the path is right and drop an empty
    // filenames (sometimes on windows)
    files = files.filter(Boolean).map(file => ***REMOVED***
      return path.relative(process.cwd(), path.relative(cwd, file));
    ***REMOVED***);

    if (utils.isWindows) ***REMOVED***
      // ensure the drive letter is in uppercase (c:\foo -> C:\foo)
      files = files.map(f => ***REMOVED***
        if (f.indexOf(':') === -1) ***REMOVED*** return f; ***REMOVED***
        return f[0].toUpperCase() + f.slice(1);
      ***REMOVED***);
    ***REMOVED***


    debug('filterAndRestart on', files);

    var matched = match(
      files,
      config.options.monitor,
      undefsafe(config, 'options.execOptions.ext')
    );

    debug('matched?', JSON.stringify(matched));

    // if there's no matches, then test to see if the changed file is the
    // running script, if so, let's allow a restart
    if (config.options.execOptions.script) ***REMOVED***
      const script = path.resolve(config.options.execOptions.script);
      if (matched.result.length === 0 && script) ***REMOVED***
        const length = script.length;
        files.find(file => ***REMOVED***
          if (file.substr(-length, length) === script) ***REMOVED***
            matched = ***REMOVED***
              result: [file],
              total: 1,
            ***REMOVED***;
            return true;
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    utils.log.detail(
      'changes after filters (before/after): ' +
      [files.length, matched.result.length].join('/')
    );

    // reset the last check so we're only looking at recently modified files
    config.lastStarted = Date.now();

    if (matched.result.length) ***REMOVED***
      if (config.options.delay > 0) ***REMOVED***
        utils.log.detail('delaying restart for ' + config.options.delay + 'ms');
        if (debouncedBus === undefined) ***REMOVED***
          debouncedBus = debounce(restartBus, config.options.delay);
        ***REMOVED***
        debouncedBus(matched);
      ***REMOVED*** else ***REMOVED***
        return restartBus(matched);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function restartBus(matched) ***REMOVED***
  utils.log.status('restarting due to changes...');
  matched.result.map(file => ***REMOVED***
    utils.log.detail(path.relative(process.cwd(), file));
  ***REMOVED***);

  if (config.options.verbose) ***REMOVED***
    utils.log._log('');
  ***REMOVED***

  bus.emit('restart', matched.result);
***REMOVED***

function debounce(fn, delay) ***REMOVED***
  var timer = null;
  return function () ***REMOVED***
    const context = this;
    const args = arguments;
    clearTimeout(timer);
    timer = setTimeout(() =>fn.apply(context, args), delay);
  ***REMOVED***;
***REMOVED***
