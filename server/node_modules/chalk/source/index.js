'use strict';
const ansiStyles = require('ansi-styles');
const ***REMOVED***stdout: stdoutColor, stderr: stderrColor***REMOVED*** = require('supports-color');
const ***REMOVED***
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
***REMOVED*** = require('./util');

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = ***REMOVED******REMOVED***) => ***REMOVED***
	if (options.level > 3 || options.level < 0) ***REMOVED***
		throw new Error('The `level` option should be an integer from 0 to 3');
	***REMOVED***

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
***REMOVED***;

class ChalkClass ***REMOVED***
	constructor(options) ***REMOVED***
		return chalkFactory(options);
	***REMOVED***
***REMOVED***

const chalkFactory = options => ***REMOVED***
	const chalk = ***REMOVED******REMOVED***;
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => ***REMOVED***
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	***REMOVED***;

	chalk.template.Instance = ChalkClass;

	return chalk.template;
***REMOVED***;

function Chalk(options) ***REMOVED***
	return chalkFactory(options);
***REMOVED***

for (const [styleName, style] of Object.entries(ansiStyles)) ***REMOVED***
	styles[styleName] = ***REMOVED***
		get() ***REMOVED***
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, ***REMOVED***value: builder***REMOVED***);
			return builder;
		***REMOVED***
	***REMOVED***;
***REMOVED***

styles.visible = ***REMOVED***
	get() ***REMOVED***
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', ***REMOVED***value: builder***REMOVED***);
		return builder;
	***REMOVED***
***REMOVED***;

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) ***REMOVED***
	styles[model] = ***REMOVED***
		get() ***REMOVED***
			const ***REMOVED***level***REMOVED*** = this;
			return function (...arguments_) ***REMOVED***
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			***REMOVED***;
		***REMOVED***
	***REMOVED***;
***REMOVED***

for (const model of usedModels) ***REMOVED***
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = ***REMOVED***
		get() ***REMOVED***
			const ***REMOVED***level***REMOVED*** = this;
			return function (...arguments_) ***REMOVED***
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			***REMOVED***;
		***REMOVED***
	***REMOVED***;
***REMOVED***

const proto = Object.defineProperties(() => ***REMOVED******REMOVED***, ***REMOVED***
	...styles,
	level: ***REMOVED***
		enumerable: true,
		get() ***REMOVED***
			return this._generator.level;
		***REMOVED***,
		set(level) ***REMOVED***
			this._generator.level = level;
		***REMOVED***
	***REMOVED***
***REMOVED***);

const createStyler = (open, close, parent) => ***REMOVED***
	let openAll;
	let closeAll;
	if (parent === undefined) ***REMOVED***
		openAll = open;
		closeAll = close;
	***REMOVED*** else ***REMOVED***
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	***REMOVED***

	return ***REMOVED***
		open,
		close,
		openAll,
		closeAll,
		parent
	***REMOVED***;
***REMOVED***;

const createBuilder = (self, _styler, _isEmpty) => ***REMOVED***
	const builder = (...arguments_) => ***REMOVED***
		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	***REMOVED***;

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
***REMOVED***;

const applyStyle = (self, string) => ***REMOVED***
	if (self.level <= 0 || !string) ***REMOVED***
		return self._isEmpty ? '' : string;
	***REMOVED***

	let styler = self._styler;

	if (styler === undefined) ***REMOVED***
		return string;
	***REMOVED***

	const ***REMOVED***openAll, closeAll***REMOVED*** = styler;
	if (string.indexOf('\u001B') !== -1) ***REMOVED***
		while (styler !== undefined) ***REMOVED***
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		***REMOVED***
	***REMOVED***

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) ***REMOVED***
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	***REMOVED***

	return openAll + string + closeAll;
***REMOVED***;

let template;
const chalkTag = (chalk, ...strings) => ***REMOVED***
	const [firstString] = strings;

	if (!Array.isArray(firstString)) ***REMOVED***
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	***REMOVED***

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) ***REMOVED***
		parts.push(
			String(arguments_[i - 1]).replace(/[***REMOVED******REMOVED***\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	***REMOVED***

	if (template === undefined) ***REMOVED***
		template = require('./templates');
	***REMOVED***

	return template(chalk, parts.join(''));
***REMOVED***;

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk(***REMOVED***level: stderrColor ? stderrColor.level : 0***REMOVED***); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

// For TypeScript
chalk.Level = ***REMOVED***
	None: 0,
	Basic: 1,
	Ansi256: 2,
	TrueColor: 3,
	0: 'None',
	1: 'Basic',
	2: 'Ansi256',
	3: 'TrueColor'
***REMOVED***;

module.exports = chalk;
