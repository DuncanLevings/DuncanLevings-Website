'use strict';
const isObj = require('is-obj');

const disallowedKeys = [
	'__proto__',
	'prototype',
	'constructor'
];

const isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.includes(segment));

function getPathSegments(path) ***REMOVED***
	const pathArray = path.split('.');
	const parts = [];

	for (let i = 0; i < pathArray.length; i++) ***REMOVED***
		let p = pathArray[i];

		while (p[p.length - 1] === '\\' && pathArray[i + 1] !== undefined) ***REMOVED***
			p = p.slice(0, -1) + '.';
			p += pathArray[++i];
		***REMOVED***

		parts.push(p);
	***REMOVED***

	if (!isValidPath(parts)) ***REMOVED***
		return [];
	***REMOVED***

	return parts;
***REMOVED***

module.exports = ***REMOVED***
	get(object, path, value) ***REMOVED***
		if (!isObj(object) || typeof path !== 'string') ***REMOVED***
			return value === undefined ? object : value;
		***REMOVED***

		const pathArray = getPathSegments(path);
		if (pathArray.length === 0) ***REMOVED***
			return;
		***REMOVED***

		for (let i = 0; i < pathArray.length; i++) ***REMOVED***
			if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) ***REMOVED***
				return value;
			***REMOVED***

			object = object[pathArray[i]];

			if (object === undefined || object === null) ***REMOVED***
				// `object` is either `undefined` or `null` so we want to stop the loop, and
				// if this is not the last bit of the path, and
				// if it did't return `undefined`
				// it would return `null` if `object` is `null`
				// but we want `get(***REMOVED***foo: null***REMOVED***, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
				if (i !== pathArray.length - 1) ***REMOVED***
					return value;
				***REMOVED***

				break;
			***REMOVED***
		***REMOVED***

		return object;
	***REMOVED***,

	set(object, path, value) ***REMOVED***
		if (!isObj(object) || typeof path !== 'string') ***REMOVED***
			return object;
		***REMOVED***

		const root = object;
		const pathArray = getPathSegments(path);

		for (let i = 0; i < pathArray.length; i++) ***REMOVED***
			const p = pathArray[i];

			if (!isObj(object[p])) ***REMOVED***
				object[p] = ***REMOVED******REMOVED***;
			***REMOVED***

			if (i === pathArray.length - 1) ***REMOVED***
				object[p] = value;
			***REMOVED***

			object = object[p];
		***REMOVED***

		return root;
	***REMOVED***,

	delete(object, path) ***REMOVED***
		if (!isObj(object) || typeof path !== 'string') ***REMOVED***
			return;
		***REMOVED***

		const pathArray = getPathSegments(path);

		for (let i = 0; i < pathArray.length; i++) ***REMOVED***
			const p = pathArray[i];

			if (i === pathArray.length - 1) ***REMOVED***
				delete object[p];
				return;
			***REMOVED***

			object = object[p];

			if (!isObj(object)) ***REMOVED***
				return;
			***REMOVED***
		***REMOVED***
	***REMOVED***,

	has(object, path) ***REMOVED***
		if (!isObj(object) || typeof path !== 'string') ***REMOVED***
			return false;
		***REMOVED***

		const pathArray = getPathSegments(path);
		if (pathArray.length === 0) ***REMOVED***
			return false;
		***REMOVED***

		// eslint-disable-next-line unicorn/no-for-loop
		for (let i = 0; i < pathArray.length; i++) ***REMOVED***
			if (isObj(object)) ***REMOVED***
				if (!(pathArray[i] in object)) ***REMOVED***
					return false;
				***REMOVED***

				object = object[pathArray[i]];
			***REMOVED*** else ***REMOVED***
				return false;
			***REMOVED***
		***REMOVED***

		return true;
	***REMOVED***
***REMOVED***;
