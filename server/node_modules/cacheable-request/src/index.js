'use strict';

const EventEmitter = require('events');
const urlLib = require('url');
const normalizeUrl = require('normalize-url');
const getStream = require('get-stream');
const CachePolicy = require('http-cache-semantics');
const Response = require('responselike');
const lowercaseKeys = require('lowercase-keys');
const cloneResponse = require('clone-response');
const Keyv = require('keyv');

class CacheableRequest ***REMOVED***
	constructor(request, cacheAdapter) ***REMOVED***
		if (typeof request !== 'function') ***REMOVED***
			throw new TypeError('Parameter `request` must be a function');
		***REMOVED***

		this.cache = new Keyv(***REMOVED***
			uri: typeof cacheAdapter === 'string' && cacheAdapter,
			store: typeof cacheAdapter !== 'string' && cacheAdapter,
			namespace: 'cacheable-request'
		***REMOVED***);

		return this.createCacheableRequest(request);
	***REMOVED***

	createCacheableRequest(request) ***REMOVED***
		return (opts, cb) => ***REMOVED***
			let url;
			if (typeof opts === 'string') ***REMOVED***
				url = normalizeUrlObject(urlLib.parse(opts));
				opts = ***REMOVED******REMOVED***;
			***REMOVED*** else if (opts instanceof urlLib.URL) ***REMOVED***
				url = normalizeUrlObject(urlLib.parse(opts.toString()));
				opts = ***REMOVED******REMOVED***;
			***REMOVED*** else ***REMOVED***
				const [pathname, ...searchParts] = (opts.path || '').split('?');
				const search = searchParts.length > 0 ?
					`?$***REMOVED***searchParts.join('?')***REMOVED***` :
					'';
				url = normalizeUrlObject(***REMOVED*** ...opts, pathname, search ***REMOVED***);
			***REMOVED***

			opts = ***REMOVED***
				headers: ***REMOVED******REMOVED***,
				method: 'GET',
				cache: true,
				strictTtl: false,
				automaticFailover: false,
				...opts,
				...urlObjectToRequestOptions(url)
			***REMOVED***;
			opts.headers = lowercaseKeys(opts.headers);

			const ee = new EventEmitter();
			const normalizedUrlString = normalizeUrl(
				urlLib.format(url),
				***REMOVED***
					stripWWW: false,
					removeTrailingSlash: false,
					stripAuthentication: false
				***REMOVED***
			);
			const key = `$***REMOVED***opts.method***REMOVED***:$***REMOVED***normalizedUrlString***REMOVED***`;
			let revalidate = false;
			let madeRequest = false;

			const makeRequest = opts => ***REMOVED***
				madeRequest = true;
				let requestErrored = false;
				let requestErrorCallback;

				const requestErrorPromise = new Promise(resolve => ***REMOVED***
					requestErrorCallback = () => ***REMOVED***
						if (!requestErrored) ***REMOVED***
							requestErrored = true;
							resolve();
						***REMOVED***
					***REMOVED***;
				***REMOVED***);

				const handler = response => ***REMOVED***
					if (revalidate && !opts.forceRefresh) ***REMOVED***
						response.status = response.statusCode;
						const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);
						if (!revalidatedPolicy.modified) ***REMOVED***
							const headers = revalidatedPolicy.policy.responseHeaders();
							response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
							response.cachePolicy = revalidatedPolicy.policy;
							response.fromCache = true;
						***REMOVED***
					***REMOVED***

					if (!response.fromCache) ***REMOVED***
						response.cachePolicy = new CachePolicy(opts, response, opts);
						response.fromCache = false;
					***REMOVED***

					let clonedResponse;
					if (opts.cache && response.cachePolicy.storable()) ***REMOVED***
						clonedResponse = cloneResponse(response);

						(async () => ***REMOVED***
							try ***REMOVED***
								const bodyPromise = getStream.buffer(response);

								await Promise.race([
									requestErrorPromise,
									new Promise(resolve => response.once('end', resolve))
								]);

								if (requestErrored) ***REMOVED***
									return;
								***REMOVED***

								const body = await bodyPromise;

								const value = ***REMOVED***
									cachePolicy: response.cachePolicy.toObject(),
									url: response.url,
									statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
									body
								***REMOVED***;

								let ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;
								if (opts.maxTtl) ***REMOVED***
									ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;
								***REMOVED***

								await this.cache.set(key, value, ttl);
							***REMOVED*** catch (error) ***REMOVED***
								ee.emit('error', new CacheableRequest.CacheError(error));
							***REMOVED***
						***REMOVED***)();
					***REMOVED*** else if (opts.cache && revalidate) ***REMOVED***
						(async () => ***REMOVED***
							try ***REMOVED***
								await this.cache.delete(key);
							***REMOVED*** catch (error) ***REMOVED***
								ee.emit('error', new CacheableRequest.CacheError(error));
							***REMOVED***
						***REMOVED***)();
					***REMOVED***

					ee.emit('response', clonedResponse || response);
					if (typeof cb === 'function') ***REMOVED***
						cb(clonedResponse || response);
					***REMOVED***
				***REMOVED***;

				try ***REMOVED***
					const req = request(opts, handler);
					req.once('error', requestErrorCallback);
					req.once('abort', requestErrorCallback);
					ee.emit('request', req);
				***REMOVED*** catch (error) ***REMOVED***
					ee.emit('error', new CacheableRequest.RequestError(error));
				***REMOVED***
			***REMOVED***;

			(async () => ***REMOVED***
				const get = async opts => ***REMOVED***
					await Promise.resolve();

					const cacheEntry = opts.cache ? await this.cache.get(key) : undefined;
					if (typeof cacheEntry === 'undefined') ***REMOVED***
						return makeRequest(opts);
					***REMOVED***

					const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
					if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) ***REMOVED***
						const headers = policy.responseHeaders();
						const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
						response.cachePolicy = policy;
						response.fromCache = true;

						ee.emit('response', response);
						if (typeof cb === 'function') ***REMOVED***
							cb(response);
						***REMOVED***
					***REMOVED*** else ***REMOVED***
						revalidate = cacheEntry;
						opts.headers = policy.revalidationHeaders(opts);
						makeRequest(opts);
					***REMOVED***
				***REMOVED***;

				const errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));
				this.cache.once('error', errorHandler);
				ee.on('response', () => this.cache.removeListener('error', errorHandler));

				try ***REMOVED***
					await get(opts);
				***REMOVED*** catch (error) ***REMOVED***
					if (opts.automaticFailover && !madeRequest) ***REMOVED***
						makeRequest(opts);
					***REMOVED***

					ee.emit('error', new CacheableRequest.CacheError(error));
				***REMOVED***
			***REMOVED***)();

			return ee;
		***REMOVED***;
	***REMOVED***
***REMOVED***

function urlObjectToRequestOptions(url) ***REMOVED***
	const options = ***REMOVED*** ...url ***REMOVED***;
	options.path = `$***REMOVED***url.pathname || '/'***REMOVED***$***REMOVED***url.search || ''***REMOVED***`;
	delete options.pathname;
	delete options.search;
	return options;
***REMOVED***

function normalizeUrlObject(url) ***REMOVED***
	// If url was parsed by url.parse or new URL:
	// - hostname will be set
	// - host will be hostname[:port]
	// - port will be set if it was explicit in the parsed string
	// Otherwise, url was from request options:
	// - hostname or host may be set
	// - host shall not have port encoded
	return ***REMOVED***
		protocol: url.protocol,
		auth: url.auth,
		hostname: url.hostname || url.host || 'localhost',
		port: url.port,
		pathname: url.pathname,
		search: url.search
	***REMOVED***;
***REMOVED***

CacheableRequest.RequestError = class extends Error ***REMOVED***
	constructor(error) ***REMOVED***
		super(error.message);
		this.name = 'RequestError';
		Object.assign(this, error);
	***REMOVED***
***REMOVED***;

CacheableRequest.CacheError = class extends Error ***REMOVED***
	constructor(error) ***REMOVED***
		super(error.message);
		this.name = 'CacheError';
		Object.assign(this, error);
	***REMOVED***
***REMOVED***;

module.exports = CacheableRequest;
