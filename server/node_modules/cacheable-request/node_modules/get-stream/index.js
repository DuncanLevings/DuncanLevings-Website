'use strict';
const pump = require('pump');
const bufferStream = require('./buffer-stream');

class MaxBufferError extends Error ***REMOVED***
	constructor() ***REMOVED***
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	***REMOVED***
***REMOVED***

async function getStream(inputStream, options) ***REMOVED***
	if (!inputStream) ***REMOVED***
		return Promise.reject(new Error('Expected a stream'));
	***REMOVED***

	options = ***REMOVED***
		maxBuffer: Infinity,
		...options
	***REMOVED***;

	const ***REMOVED***maxBuffer***REMOVED*** = options;

	let stream;
	await new Promise((resolve, reject) => ***REMOVED***
		const rejectPromise = error => ***REMOVED***
			if (error) ***REMOVED*** // A null check
				error.bufferedData = stream.getBufferedValue();
			***REMOVED***

			reject(error);
		***REMOVED***;

		stream = pump(inputStream, bufferStream(options), error => ***REMOVED***
			if (error) ***REMOVED***
				rejectPromise(error);
				return;
			***REMOVED***

			resolve();
		***REMOVED***);

		stream.on('data', () => ***REMOVED***
			if (stream.getBufferedLength() > maxBuffer) ***REMOVED***
				rejectPromise(new MaxBufferError());
			***REMOVED***
		***REMOVED***);
	***REMOVED***);

	return stream.getBufferedValue();
***REMOVED***

module.exports = getStream;
// TODO: Remove this for the next major release
module.exports.default = getStream;
module.exports.buffer = (stream, options) => getStream(stream, ***REMOVED***...options, encoding: 'buffer'***REMOVED***);
module.exports.array = (stream, options) => getStream(stream, ***REMOVED***...options, array: true***REMOVED***);
module.exports.MaxBufferError = MaxBufferError;
