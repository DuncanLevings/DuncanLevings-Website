/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

'use strict';

/**
 * @file Embedded JavaScript templating engine. ***REMOVED***@link http://ejs.co***REMOVED***
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license ***REMOVED***@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0***REMOVED***
 */

/**
 * EJS internal functions.
 *
 * Technically this "module" lies in the same file as ***REMOVED***@link module:ejs***REMOVED***, for
 * the sake of organization all the private functions re grouped into this
 * module.
 *
 * @module ejs-internal
 * @private
 */

/**
 * Embedded JavaScript templating engine.
 *
 * @module ejs
 * @public
 */

var fs = require('fs');
var path = require('path');
var utils = require('./utils');

var scopeOptionWarned = false;
var _VERSION_STRING = require('../package.json').version;
var _DEFAULT_OPEN_DELIMITER = '<';
var _DEFAULT_CLOSE_DELIMITER = '>';
var _DEFAULT_DELIMITER = '%';
var _DEFAULT_LOCALS_NAME = 'locals';
var _NAME = 'ejs';
var _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';
var _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug',
  'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];
// We don't allow 'cache' option to be passed in the data obj for
// the normal `render` call, but this is where Express 2 & 3 put it
// so we make an exception for `renderFile`
var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');
var _BOM = /^\uFEFF/;

/**
 * EJS template function cache. This can be a LRU object from lru-cache NPM
 * module. By default, it is ***REMOVED***@link module:utils.cache***REMOVED***, a simple in-process
 * cache that grows continuously.
 *
 * @type ***REMOVED***Cache***REMOVED***
 */

exports.cache = utils.cache;

/**
 * Custom file loader. Useful for template preprocessing or restricting access
 * to a certain part of the filesystem.
 *
 * @type ***REMOVED***fileLoader***REMOVED***
 */

exports.fileLoader = fs.readFileSync;

/**
 * Name of the object containing the locals.
 *
 * This variable is overridden by ***REMOVED***@link Options***REMOVED***`.localsName` if it is not
 * `undefined`.
 *
 * @type ***REMOVED***String***REMOVED***
 * @public
 */

exports.localsName = _DEFAULT_LOCALS_NAME;

/**
 * Promise implementation -- defaults to the native implementation if available
 * This is mostly just for testability
 *
 * @type ***REMOVED***Function***REMOVED***
 * @public
 */

exports.promiseImpl = (new Function('return this;'))().Promise;

/**
 * Get the path to the included file from the parent file path and the
 * specified path.
 *
 * @param ***REMOVED***String***REMOVED***  name     specified path
 * @param ***REMOVED***String***REMOVED***  filename parent file path
 * @param ***REMOVED***Boolean***REMOVED*** isDir    parent file path whether is directory
 * @return ***REMOVED***String***REMOVED***
 */
exports.resolveInclude = function(name, filename, isDir) ***REMOVED***
  var dirname = path.dirname;
  var extname = path.extname;
  var resolve = path.resolve;
  var includePath = resolve(isDir ? filename : dirname(filename), name);
  var ext = extname(name);
  if (!ext) ***REMOVED***
    includePath += '.ejs';
  ***REMOVED***
  return includePath;
***REMOVED***;

/**
 * Get the path to the included file by Options
 *
 * @param  ***REMOVED***String***REMOVED***  path    specified path
 * @param  ***REMOVED***Options***REMOVED*** options compilation options
 * @return ***REMOVED***String***REMOVED***
 */
function getIncludePath(path, options) ***REMOVED***
  var includePath;
  var filePath;
  var views = options.views;
  var match = /^[A-Za-z]+:\\|^\//.exec(path);

  // Abs path
  if (match && match.length) ***REMOVED***
    includePath = exports.resolveInclude(path.replace(/^\/*/,''), options.root || '/', true);
  ***REMOVED***
  // Relative paths
  else ***REMOVED***
    // Look relative to a passed filename first
    if (options.filename) ***REMOVED***
      filePath = exports.resolveInclude(path, options.filename);
      if (fs.existsSync(filePath)) ***REMOVED***
        includePath = filePath;
      ***REMOVED***
    ***REMOVED***
    // Then look in any views directories
    if (!includePath) ***REMOVED***
      if (Array.isArray(views) && views.some(function (v) ***REMOVED***
        filePath = exports.resolveInclude(path, v, true);
        return fs.existsSync(filePath);
      ***REMOVED***)) ***REMOVED***
        includePath = filePath;
      ***REMOVED***
    ***REMOVED***
    if (!includePath) ***REMOVED***
      throw new Error('Could not find the include file "' +
          options.escapeFunction(path) + '"');
    ***REMOVED***
  ***REMOVED***
  return includePath;
***REMOVED***

/**
 * Get the template from a string or a file, either compiled on-the-fly or
 * read from cache (if enabled), and cache the template if needed.
 *
 * If `template` is not set, the file specified in `options.filename` will be
 * read.
 *
 * If `options.cache` is true, this function reads the file from
 * `options.filename` so it must be set prior to calling this function.
 *
 * @memberof module:ejs-internal
 * @param ***REMOVED***Options***REMOVED*** options   compilation options
 * @param ***REMOVED***String***REMOVED*** [template] template source
 * @return ***REMOVED***(TemplateFunction|ClientFunction)***REMOVED***
 * Depending on the value of `options.client`, either type might be returned.
 * @static
 */

function handleCache(options, template) ***REMOVED***
  var func;
  var filename = options.filename;
  var hasTemplate = arguments.length > 1;

  if (options.cache) ***REMOVED***
    if (!filename) ***REMOVED***
      throw new Error('cache option requires a filename');
    ***REMOVED***
    func = exports.cache.get(filename);
    if (func) ***REMOVED***
      return func;
    ***REMOVED***
    if (!hasTemplate) ***REMOVED***
      template = fileLoader(filename).toString().replace(_BOM, '');
    ***REMOVED***
  ***REMOVED***
  else if (!hasTemplate) ***REMOVED***
    // istanbul ignore if: should not happen at all
    if (!filename) ***REMOVED***
      throw new Error('Internal EJS error: no file name or template '
                    + 'provided');
    ***REMOVED***
    template = fileLoader(filename).toString().replace(_BOM, '');
  ***REMOVED***
  func = exports.compile(template, options);
  if (options.cache) ***REMOVED***
    exports.cache.set(filename, func);
  ***REMOVED***
  return func;
***REMOVED***

/**
 * Try calling handleCache with the given options and data and call the
 * callback with the result. If an error occurs, call the callback with
 * the error. Used by renderFile().
 *
 * @memberof module:ejs-internal
 * @param ***REMOVED***Options***REMOVED*** options    compilation options
 * @param ***REMOVED***Object***REMOVED*** data        template data
 * @param ***REMOVED***RenderFileCallback***REMOVED*** cb callback
 * @static
 */

function tryHandleCache(options, data, cb) ***REMOVED***
  var result;
  if (!cb) ***REMOVED***
    if (typeof exports.promiseImpl == 'function') ***REMOVED***
      return new exports.promiseImpl(function (resolve, reject) ***REMOVED***
        try ***REMOVED***
          result = handleCache(options)(data);
          resolve(result);
        ***REMOVED***
        catch (err) ***REMOVED***
          reject(err);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
    else ***REMOVED***
      throw new Error('Please provide a callback function');
    ***REMOVED***
  ***REMOVED***
  else ***REMOVED***
    try ***REMOVED***
      result = handleCache(options)(data);
    ***REMOVED***
    catch (err) ***REMOVED***
      return cb(err);
    ***REMOVED***

    cb(null, result);
  ***REMOVED***
***REMOVED***

/**
 * fileLoader is independent
 *
 * @param ***REMOVED***String***REMOVED*** filePath ejs file path.
 * @return ***REMOVED***String***REMOVED*** The contents of the specified file.
 * @static
 */

function fileLoader(filePath)***REMOVED***
  return exports.fileLoader(filePath);
***REMOVED***

/**
 * Get the template function.
 *
 * If `options.cache` is `true`, then the template is cached.
 *
 * @memberof module:ejs-internal
 * @param ***REMOVED***String***REMOVED***  path    path for the specified file
 * @param ***REMOVED***Options***REMOVED*** options compilation options
 * @return ***REMOVED***(TemplateFunction|ClientFunction)***REMOVED***
 * Depending on the value of `options.client`, either type might be returned
 * @static
 */

function includeFile(path, options) ***REMOVED***
  var opts = utils.shallowCopy(***REMOVED******REMOVED***, options);
  opts.filename = getIncludePath(path, opts);
  return handleCache(opts);
***REMOVED***

/**
 * Get the JavaScript source of an included file.
 *
 * @memberof module:ejs-internal
 * @param ***REMOVED***String***REMOVED***  path    path for the specified file
 * @param ***REMOVED***Options***REMOVED*** options compilation options
 * @return ***REMOVED***Object***REMOVED***
 * @static
 */

function includeSource(path, options) ***REMOVED***
  var opts = utils.shallowCopy(***REMOVED******REMOVED***, options);
  var includePath;
  var template;
  includePath = getIncludePath(path, opts);
  template = fileLoader(includePath).toString().replace(_BOM, '');
  opts.filename = includePath;
  var templ = new Template(template, opts);
  templ.generateSource();
  return ***REMOVED***
    source: templ.source,
    filename: includePath,
    template: template
  ***REMOVED***;
***REMOVED***

/**
 * Re-throw the given `err` in context to the `str` of ejs, `filename`, and
 * `lineno`.
 *
 * @implements RethrowCallback
 * @memberof module:ejs-internal
 * @param ***REMOVED***Error***REMOVED***  err      Error object
 * @param ***REMOVED***String***REMOVED*** str      EJS source
 * @param ***REMOVED***String***REMOVED*** filename file name of the EJS file
 * @param ***REMOVED***String***REMOVED*** lineno   line number of the error
 * @static
 */

function rethrow(err, str, flnm, lineno, esc)***REMOVED***
  var lines = str.split('\n');
  var start = Math.max(lineno - 3, 0);
  var end = Math.min(lines.length, lineno + 3);
  var filename = esc(flnm); // eslint-disable-line
  // Error context
  var context = lines.slice(start, end).map(function (line, i)***REMOVED***
    var curr = i + start + 1;
    return (curr == lineno ? ' >> ' : '    ')
      + curr
      + '| '
      + line;
  ***REMOVED***).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'ejs') + ':'
    + lineno + '\n'
    + context + '\n\n'
    + err.message;

  throw err;
***REMOVED***

function stripSemi(str)***REMOVED***
  return str.replace(/;(\s*$)/, '$1');
***REMOVED***

/**
 * Compile the given `str` of ejs into a template function.
 *
 * @param ***REMOVED***String***REMOVED***  template EJS template
 *
 * @param ***REMOVED***Options***REMOVED*** opts     compilation options
 *
 * @return ***REMOVED***(TemplateFunction|ClientFunction)***REMOVED***
 * Depending on the value of `opts.client`, either type might be returned.
 * Note that the return type of the function also depends on the value of `opts.async`.
 * @public
 */

exports.compile = function compile(template, opts) ***REMOVED***
  var templ;

  // v1 compat
  // 'scope' is 'context'
  // FIXME: Remove this in a future version
  if (opts && opts.scope) ***REMOVED***
    if (!scopeOptionWarned)***REMOVED***
      console.warn('`scope` option is deprecated and will be removed in EJS 3');
      scopeOptionWarned = true;
    ***REMOVED***
    if (!opts.context) ***REMOVED***
      opts.context = opts.scope;
    ***REMOVED***
    delete opts.scope;
  ***REMOVED***
  templ = new Template(template, opts);
  return templ.compile();
***REMOVED***;

/**
 * Render the given `template` of ejs.
 *
 * If you would like to include options but not data, you need to explicitly
 * call this function with `data` being an empty object or `null`.
 *
 * @param ***REMOVED***String***REMOVED***   template EJS template
 * @param ***REMOVED***Object***REMOVED***  [data=***REMOVED******REMOVED***] template data
 * @param ***REMOVED***Options***REMOVED*** [opts=***REMOVED******REMOVED***] compilation and rendering options
 * @return ***REMOVED***(String|Promise<String>)***REMOVED***
 * Return value type depends on `opts.async`.
 * @public
 */

exports.render = function (template, d, o) ***REMOVED***
  var data = d || ***REMOVED******REMOVED***;
  var opts = o || ***REMOVED******REMOVED***;

  // No options object -- if there are optiony names
  // in the data, copy them to options
  if (arguments.length == 2) ***REMOVED***
    utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
  ***REMOVED***

  return handleCache(opts, template)(data);
***REMOVED***;

/**
 * Render an EJS file at the given `path` and callback `cb(err, str)`.
 *
 * If you would like to include options but not data, you need to explicitly
 * call this function with `data` being an empty object or `null`.
 *
 * @param ***REMOVED***String***REMOVED***             path     path to the EJS file
 * @param ***REMOVED***Object***REMOVED***            [data=***REMOVED******REMOVED***] template data
 * @param ***REMOVED***Options***REMOVED***           [opts=***REMOVED******REMOVED***] compilation and rendering options
 * @param ***REMOVED***RenderFileCallback***REMOVED*** cb callback
 * @public
 */

exports.renderFile = function () ***REMOVED***
  var args = Array.prototype.slice.call(arguments);
  var filename = args.shift();
  var cb;
  var opts = ***REMOVED***filename: filename***REMOVED***;
  var data;
  var viewOpts;

  // Do we have a callback?
  if (typeof arguments[arguments.length - 1] == 'function') ***REMOVED***
    cb = args.pop();
  ***REMOVED***
  // Do we have data/opts?
  if (args.length) ***REMOVED***
    // Should always have data obj
    data = args.shift();
    // Normal passed opts (data obj + opts obj)
    if (args.length) ***REMOVED***
      // Use shallowCopy so we don't pollute passed in opts obj with new vals
      utils.shallowCopy(opts, args.pop());
    ***REMOVED***
    // Special casing for Express (settings + opts-in-data)
    else ***REMOVED***
      // Express 3 and 4
      if (data.settings) ***REMOVED***
        // Pull a few things from known locations
        if (data.settings.views) ***REMOVED***
          opts.views = data.settings.views;
        ***REMOVED***
        if (data.settings['view cache']) ***REMOVED***
          opts.cache = true;
        ***REMOVED***
        // Undocumented after Express 2, but still usable, esp. for
        // items that are unsafe to be passed along with data, like `root`
        viewOpts = data.settings['view options'];
        if (viewOpts) ***REMOVED***
          utils.shallowCopy(opts, viewOpts);
        ***REMOVED***
      ***REMOVED***
      // Express 2 and lower, values set in app.locals, or people who just
      // want to pass options in their data. NOTE: These values will override
      // anything previously set in settings  or settings['view options']
      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
    ***REMOVED***
    opts.filename = filename;
  ***REMOVED***
  else ***REMOVED***
    data = ***REMOVED******REMOVED***;
  ***REMOVED***

  return tryHandleCache(opts, data, cb);
***REMOVED***;

/**
 * Clear intermediate JavaScript cache. Calls ***REMOVED***@link Cache#reset***REMOVED***.
 * @public
 */

/**
 * EJS template class
 * @public
 */
exports.Template = Template;

exports.clearCache = function () ***REMOVED***
  exports.cache.reset();
***REMOVED***;

function Template(text, opts) ***REMOVED***
  opts = opts || ***REMOVED******REMOVED***;
  var options = ***REMOVED******REMOVED***;
  this.templateText = text;
  this.mode = null;
  this.truncate = false;
  this.currentLine = 1;
  this.source = '';
  this.dependencies = [];
  options.client = opts.client || false;
  options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
  options.compileDebug = opts.compileDebug !== false;
  options.debug = !!opts.debug;
  options.filename = opts.filename;
  options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;
  options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;
  options.strict = opts.strict || false;
  options.context = opts.context;
  options.cache = opts.cache || false;
  options.rmWhitespace = opts.rmWhitespace;
  options.root = opts.root;
  options.outputFunctionName = opts.outputFunctionName;
  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;
  options.views = opts.views;
  options.async = opts.async;

  if (options.strict) ***REMOVED***
    options._with = false;
  ***REMOVED***
  else ***REMOVED***
    options._with = typeof opts._with != 'undefined' ? opts._with : true;
  ***REMOVED***

  this.opts = options;

  this.regex = this.createRegex();
***REMOVED***

Template.modes = ***REMOVED***
  EVAL: 'eval',
  ESCAPED: 'escaped',
  RAW: 'raw',
  COMMENT: 'comment',
  LITERAL: 'literal'
***REMOVED***;

Template.prototype = ***REMOVED***
  createRegex: function () ***REMOVED***
    var str = _REGEX_STRING;
    var delim = utils.escapeRegExpChars(this.opts.delimiter);
    var open = utils.escapeRegExpChars(this.opts.openDelimiter);
    var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
    str = str.replace(/%/g, delim)
      .replace(/</g, open)
      .replace(/>/g, close);
    return new RegExp(str);
  ***REMOVED***,

  compile: function () ***REMOVED***
    var src;
    var fn;
    var opts = this.opts;
    var prepended = '';
    var appended = '';
    var escapeFn = opts.escapeFunction;
    var ctor;

    if (!this.source) ***REMOVED***
      this.generateSource();
      prepended += '  var __output = [], __append = __output.push.bind(__output);' + '\n';
      if (opts.outputFunctionName) ***REMOVED***
        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\n';
      ***REMOVED***
      if (opts._with !== false) ***REMOVED***
        prepended +=  '  with (' + opts.localsName + ' || ***REMOVED******REMOVED***) ***REMOVED***' + '\n';
        appended += '  ***REMOVED***' + '\n';
      ***REMOVED***
      appended += '  return __output.join("");' + '\n';
      this.source = prepended + this.source + appended;
    ***REMOVED***

    if (opts.compileDebug) ***REMOVED***
      src = 'var __line = 1' + '\n'
        + '  , __lines = ' + JSON.stringify(this.templateText) + '\n'
        + '  , __filename = ' + (opts.filename ?
        JSON.stringify(opts.filename) : 'undefined') + ';' + '\n'
        + 'try ***REMOVED***' + '\n'
        + this.source
        + '***REMOVED*** catch (e) ***REMOVED***' + '\n'
        + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\n'
        + '***REMOVED***' + '\n';
    ***REMOVED***
    else ***REMOVED***
      src = this.source;
    ***REMOVED***

    if (opts.client) ***REMOVED***
      src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\n' + src;
      if (opts.compileDebug) ***REMOVED***
        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\n' + src;
      ***REMOVED***
    ***REMOVED***

    if (opts.strict) ***REMOVED***
      src = '"use strict";\n' + src;
    ***REMOVED***
    if (opts.debug) ***REMOVED***
      console.log(src);
    ***REMOVED***

    try ***REMOVED***
      if (opts.async) ***REMOVED***
        // Have to use generated function for this, since in envs without support,
        // it breaks in parsing
        try ***REMOVED***
          ctor = (new Function('return (async function()***REMOVED******REMOVED***).constructor;'))();
        ***REMOVED***
        catch(e) ***REMOVED***
          if (e instanceof SyntaxError) ***REMOVED***
            throw new Error('This environment does not support async/await');
          ***REMOVED***
          else ***REMOVED***
            throw e;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      else ***REMOVED***
        ctor = Function;
      ***REMOVED***
      fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);
    ***REMOVED***
    catch(e) ***REMOVED***
      // istanbul ignore else
      if (e instanceof SyntaxError) ***REMOVED***
        if (opts.filename) ***REMOVED***
          e.message += ' in ' + opts.filename;
        ***REMOVED***
        e.message += ' while compiling ejs\n\n';
        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\n';
        e.message += 'https://github.com/RyanZim/EJS-Lint';
        if (!e.async) ***REMOVED***
          e.message += '\n';
          e.message += 'Or, if you meant to create an async function, pass async: true as an option.';
        ***REMOVED***
      ***REMOVED***
      throw e;
    ***REMOVED***

    if (opts.client) ***REMOVED***
      fn.dependencies = this.dependencies;
      return fn;
    ***REMOVED***

    // Return a callable function which will execute the function
    // created by the source-code, with the passed data as locals
    // Adds a local `include` function which allows full recursive include
    var returnedFn = function (data) ***REMOVED***
      var include = function (path, includeData) ***REMOVED***
        var d = utils.shallowCopy(***REMOVED******REMOVED***, data);
        if (includeData) ***REMOVED***
          d = utils.shallowCopy(d, includeData);
        ***REMOVED***
        return includeFile(path, opts)(d);
      ***REMOVED***;
      return fn.apply(opts.context, [data || ***REMOVED******REMOVED***, escapeFn, include, rethrow]);
    ***REMOVED***;
    returnedFn.dependencies = this.dependencies;
    return returnedFn;
  ***REMOVED***,

  generateSource: function () ***REMOVED***
    var opts = this.opts;

    if (opts.rmWhitespace) ***REMOVED***
      // Have to use two separate replace here as `^` and `$` operators don't
      // work well with `\r` and empty lines don't work well with the `m` flag.
      this.templateText =
        this.templateText.replace(/[\r\n]+/g, '\n').replace(/^\s+|\s+$/gm, '');
    ***REMOVED***

    // Slurp spaces and tabs before <%_ and after _%>
    this.templateText =
      this.templateText.replace(/[ \t]*<%_/gm, '<%_').replace(/_%>[ \t]*/gm, '_%>');

    var self = this;
    var matches = this.parseTemplateText();
    var d = this.opts.delimiter;
    var o = this.opts.openDelimiter;
    var c = this.opts.closeDelimiter;

    if (matches && matches.length) ***REMOVED***
      matches.forEach(function (line, index) ***REMOVED***
        var opening;
        var closing;
        var include;
        var includeOpts;
        var includeObj;
        var includeSrc;
        // If this is an opening tag, check for closing tags
        // FIXME: May end up with some false positives here
        // Better to store modes as k/v with openDelimiter + delimiter as key
        // Then this can simply check against the map
        if ( line.indexOf(o + d) === 0        // If it is a tag
          && line.indexOf(o + d + d) !== 0) ***REMOVED*** // and is not escaped
          closing = matches[index + 2];
          if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) ***REMOVED***
            throw new Error('Could not find matching close tag for "' + line + '".');
          ***REMOVED***
        ***REMOVED***
        // HACK: backward-compat `include` preprocessor directives
        if ((include = line.match(/^\s*include\s+(\S+)/))) ***REMOVED***
          opening = matches[index - 1];
          // Must be in EVAL or RAW mode
          if (opening && (opening == o + d || opening == o + d + '-' || opening == o + d + '_')) ***REMOVED***
            includeOpts = utils.shallowCopy(***REMOVED******REMOVED***, self.opts);
            includeObj = includeSource(include[1], includeOpts);
            if (self.opts.compileDebug) ***REMOVED***
              includeSrc =
                  '    ; (function()***REMOVED***' + '\n'
                  + '      var __line = 1' + '\n'
                  + '      , __lines = ' + JSON.stringify(includeObj.template) + '\n'
                  + '      , __filename = ' + JSON.stringify(includeObj.filename) + ';' + '\n'
                  + '      try ***REMOVED***' + '\n'
                  + includeObj.source
                  + '      ***REMOVED*** catch (e) ***REMOVED***' + '\n'
                  + '        rethrow(e, __lines, __filename, __line, escapeFn);' + '\n'
                  + '      ***REMOVED***' + '\n'
                  + '    ; ***REMOVED***).call(this)' + '\n';
            ***REMOVED***else***REMOVED***
              includeSrc = '    ; (function()***REMOVED***' + '\n' + includeObj.source +
                  '    ; ***REMOVED***).call(this)' + '\n';
            ***REMOVED***
            self.source += includeSrc;
            self.dependencies.push(exports.resolveInclude(include[1],
              includeOpts.filename));
            return;
          ***REMOVED***
        ***REMOVED***
        self.scanLine(line);
      ***REMOVED***);
    ***REMOVED***

  ***REMOVED***,

  parseTemplateText: function () ***REMOVED***
    var str = this.templateText;
    var pat = this.regex;
    var result = pat.exec(str);
    var arr = [];
    var firstPos;

    while (result) ***REMOVED***
      firstPos = result.index;

      if (firstPos !== 0) ***REMOVED***
        arr.push(str.substring(0, firstPos));
        str = str.slice(firstPos);
      ***REMOVED***

      arr.push(result[0]);
      str = str.slice(result[0].length);
      result = pat.exec(str);
    ***REMOVED***

    if (str) ***REMOVED***
      arr.push(str);
    ***REMOVED***

    return arr;
  ***REMOVED***,

  _addOutput: function (line) ***REMOVED***
    if (this.truncate) ***REMOVED***
      // Only replace single leading linebreak in the line after
      // -%> tag -- this is the single, trailing linebreak
      // after the tag that the truncation mode replaces
      // Handle Win / Unix / old Mac linebreaks -- do the \r\n
      // combo first in the regex-or
      line = line.replace(/^(?:\r\n|\r|\n)/, '');
      this.truncate = false;
    ***REMOVED***
    if (!line) ***REMOVED***
      return line;
    ***REMOVED***

    // Preserve literal slashes
    line = line.replace(/\\/g, '\\\\');

    // Convert linebreaks
    line = line.replace(/\n/g, '\\n');
    line = line.replace(/\r/g, '\\r');

    // Escape double-quotes
    // - this will be the delimiter during execution
    line = line.replace(/"/g, '\\"');
    this.source += '    ; __append("' + line + '")' + '\n';
  ***REMOVED***,

  scanLine: function (line) ***REMOVED***
    var self = this;
    var d = this.opts.delimiter;
    var o = this.opts.openDelimiter;
    var c = this.opts.closeDelimiter;
    var newLineCount = 0;

    newLineCount = (line.split('\n').length - 1);

    switch (line) ***REMOVED***
    case o + d:
    case o + d + '_':
      this.mode = Template.modes.EVAL;
      break;
    case o + d + '=':
      this.mode = Template.modes.ESCAPED;
      break;
    case o + d + '-':
      this.mode = Template.modes.RAW;
      break;
    case o + d + '#':
      this.mode = Template.modes.COMMENT;
      break;
    case o + d + d:
      this.mode = Template.modes.LITERAL;
      this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")' + '\n';
      break;
    case d + d + c:
      this.mode = Template.modes.LITERAL;
      this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")' + '\n';
      break;
    case d + c:
    case '-' + d + c:
    case '_' + d + c:
      if (this.mode == Template.modes.LITERAL) ***REMOVED***
        this._addOutput(line);
      ***REMOVED***

      this.mode = null;
      this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;
      break;
    default:
      // In script mode, depends on type of tag
      if (this.mode) ***REMOVED***
        // If '//' is found without a line break, add a line break.
        switch (this.mode) ***REMOVED***
        case Template.modes.EVAL:
        case Template.modes.ESCAPED:
        case Template.modes.RAW:
          if (line.lastIndexOf('//') > line.lastIndexOf('\n')) ***REMOVED***
            line += '\n';
          ***REMOVED***
        ***REMOVED***
        switch (this.mode) ***REMOVED***
        // Just executing code
        case Template.modes.EVAL:
          this.source += '    ; ' + line + '\n';
          break;
          // Exec, esc, and output
        case Template.modes.ESCAPED:
          this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\n';
          break;
          // Exec and output
        case Template.modes.RAW:
          this.source += '    ; __append(' + stripSemi(line) + ')' + '\n';
          break;
        case Template.modes.COMMENT:
          // Do nothing
          break;
          // Literal <%% mode, append as raw output
        case Template.modes.LITERAL:
          this._addOutput(line);
          break;
        ***REMOVED***
      ***REMOVED***
      // In string mode, just add the output
      else ***REMOVED***
        this._addOutput(line);
      ***REMOVED***
    ***REMOVED***

    if (self.opts.compileDebug && newLineCount) ***REMOVED***
      this.currentLine += newLineCount;
      this.source += '    ; __line = ' + this.currentLine + '\n';
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Escape characters reserved in XML.
 *
 * This is simply an export of ***REMOVED***@link module:utils.escapeXML***REMOVED***.
 *
 * If `markup` is `undefined` or `null`, the empty string is returned.
 *
 * @param ***REMOVED***String***REMOVED*** markup Input string
 * @return ***REMOVED***String***REMOVED*** Escaped string
 * @public
 * @func
 * */
exports.escapeXML = utils.escapeXML;

/**
 * Express.js support.
 *
 * This is an alias for ***REMOVED***@link module:ejs.renderFile***REMOVED***, in order to support
 * Express.js out-of-the-box.
 *
 * @func
 */

exports.__express = exports.renderFile;

// Add require support
/* istanbul ignore else */
if (require.extensions) ***REMOVED***
  require.extensions['.ejs'] = function (module, flnm) ***REMOVED***
    var filename = flnm || /* istanbul ignore next */ module.filename;
    var options = ***REMOVED***
      filename: filename,
      client: true
    ***REMOVED***;
    var template = fileLoader(filename).toString();
    var fn = exports.compile(template, options);
    module._compile('module.exports = ' + fn.toString() + ';', filename);
  ***REMOVED***;
***REMOVED***

/**
 * Version of EJS.
 *
 * @readonly
 * @type ***REMOVED***String***REMOVED***
 * @public
 */

exports.VERSION = _VERSION_STRING;

/**
 * Name for detection of EJS.
 *
 * @readonly
 * @type ***REMOVED***String***REMOVED***
 * @public
 */

exports.name = _NAME;

/* istanbul ignore if */
if (typeof window != 'undefined') ***REMOVED***
  window.ejs = exports;
***REMOVED***
