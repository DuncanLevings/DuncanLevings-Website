(function(f)***REMOVED***if(typeof exports==="object"&&typeof module!=="undefined")***REMOVED***module.exports=f()***REMOVED***else if(typeof define==="function"&&define.amd)***REMOVED***define([],f)***REMOVED***else***REMOVED***var g;if(typeof window!=="undefined")***REMOVED***g=window***REMOVED***else if(typeof global!=="undefined")***REMOVED***g=global***REMOVED***else if(typeof self!=="undefined")***REMOVED***g=self***REMOVED***else***REMOVED***g=this***REMOVED***g.ejs = f()***REMOVED******REMOVED***)(function()***REMOVED***var define,module,exports;return (function()***REMOVED***function e(t,n,r)***REMOVED***function s(o,u)***REMOVED***if(!n[o])***REMOVED***if(!t[o])***REMOVED***var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f***REMOVED***var l=n[o]=***REMOVED***exports:***REMOVED******REMOVED******REMOVED***;t[o][0].call(l.exports,function(e)***REMOVED***var n=t[o][1][e];return s(n?n:e)***REMOVED***,l,l.exports,e,t,n,r)***REMOVED***return n[o].exports***REMOVED***var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s***REMOVED***return e***REMOVED***)()(***REMOVED***1:[function(require,module,exports)***REMOVED***
/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

'use strict';

/**
 * @file Embedded JavaScript templating engine. ***REMOVED***@link http://ejs.co***REMOVED***
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license ***REMOVED***@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0***REMOVED***
 */

/**
 * EJS internal functions.
 *
 * Technically this "module" lies in the same file as ***REMOVED***@link module:ejs***REMOVED***, for
 * the sake of organization all the private functions re grouped into this
 * module.
 *
 * @module ejs-internal
 * @private
 */

/**
 * Embedded JavaScript templating engine.
 *
 * @module ejs
 * @public
 */

var fs = require('fs');
var path = require('path');
var utils = require('./utils');

var scopeOptionWarned = false;
var _VERSION_STRING = require('../package.json').version;
var _DEFAULT_OPEN_DELIMITER = '<';
var _DEFAULT_CLOSE_DELIMITER = '>';
var _DEFAULT_DELIMITER = '%';
var _DEFAULT_LOCALS_NAME = 'locals';
var _NAME = 'ejs';
var _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';
var _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug',
  'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];
// We don't allow 'cache' option to be passed in the data obj for
// the normal `render` call, but this is where Express 2 & 3 put it
// so we make an exception for `renderFile`
var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');
var _BOM = /^\uFEFF/;

/**
 * EJS template function cache. This can be a LRU object from lru-cache NPM
 * module. By default, it is ***REMOVED***@link module:utils.cache***REMOVED***, a simple in-process
 * cache that grows continuously.
 *
 * @type ***REMOVED***Cache***REMOVED***
 */

exports.cache = utils.cache;

/**
 * Custom file loader. Useful for template preprocessing or restricting access
 * to a certain part of the filesystem.
 *
 * @type ***REMOVED***fileLoader***REMOVED***
 */

exports.fileLoader = fs.readFileSync;

/**
 * Name of the object containing the locals.
 *
 * This variable is overridden by ***REMOVED***@link Options***REMOVED***`.localsName` if it is not
 * `undefined`.
 *
 * @type ***REMOVED***String***REMOVED***
 * @public
 */

exports.localsName = _DEFAULT_LOCALS_NAME;

/**
 * Promise implementation -- defaults to the native implementation if available
 * This is mostly just for testability
 *
 * @type ***REMOVED***Function***REMOVED***
 * @public
 */

exports.promiseImpl = (new Function('return this;'))().Promise;

/**
 * Get the path to the included file from the parent file path and the
 * specified path.
 *
 * @param ***REMOVED***String***REMOVED***  name     specified path
 * @param ***REMOVED***String***REMOVED***  filename parent file path
 * @param ***REMOVED***Boolean***REMOVED*** isDir    parent file path whether is directory
 * @return ***REMOVED***String***REMOVED***
 */
exports.resolveInclude = function(name, filename, isDir) ***REMOVED***
  var dirname = path.dirname;
  var extname = path.extname;
  var resolve = path.resolve;
  var includePath = resolve(isDir ? filename : dirname(filename), name);
  var ext = extname(name);
  if (!ext) ***REMOVED***
    includePath += '.ejs';
  ***REMOVED***
  return includePath;
***REMOVED***;

/**
 * Get the path to the included file by Options
 *
 * @param  ***REMOVED***String***REMOVED***  path    specified path
 * @param  ***REMOVED***Options***REMOVED*** options compilation options
 * @return ***REMOVED***String***REMOVED***
 */
function getIncludePath(path, options) ***REMOVED***
  var includePath;
  var filePath;
  var views = options.views;
  var match = /^[A-Za-z]+:\\|^\//.exec(path);

  // Abs path
  if (match && match.length) ***REMOVED***
    includePath = exports.resolveInclude(path.replace(/^\/*/,''), options.root || '/', true);
  ***REMOVED***
  // Relative paths
  else ***REMOVED***
    // Look relative to a passed filename first
    if (options.filename) ***REMOVED***
      filePath = exports.resolveInclude(path, options.filename);
      if (fs.existsSync(filePath)) ***REMOVED***
        includePath = filePath;
      ***REMOVED***
    ***REMOVED***
    // Then look in any views directories
    if (!includePath) ***REMOVED***
      if (Array.isArray(views) && views.some(function (v) ***REMOVED***
        filePath = exports.resolveInclude(path, v, true);
        return fs.existsSync(filePath);
      ***REMOVED***)) ***REMOVED***
        includePath = filePath;
      ***REMOVED***
    ***REMOVED***
    if (!includePath) ***REMOVED***
      throw new Error('Could not find the include file "' +
          options.escapeFunction(path) + '"');
    ***REMOVED***
  ***REMOVED***
  return includePath;
***REMOVED***

/**
 * Get the template from a string or a file, either compiled on-the-fly or
 * read from cache (if enabled), and cache the template if needed.
 *
 * If `template` is not set, the file specified in `options.filename` will be
 * read.
 *
 * If `options.cache` is true, this function reads the file from
 * `options.filename` so it must be set prior to calling this function.
 *
 * @memberof module:ejs-internal
 * @param ***REMOVED***Options***REMOVED*** options   compilation options
 * @param ***REMOVED***String***REMOVED*** [template] template source
 * @return ***REMOVED***(TemplateFunction|ClientFunction)***REMOVED***
 * Depending on the value of `options.client`, either type might be returned.
 * @static
 */

function handleCache(options, template) ***REMOVED***
  var func;
  var filename = options.filename;
  var hasTemplate = arguments.length > 1;

  if (options.cache) ***REMOVED***
    if (!filename) ***REMOVED***
      throw new Error('cache option requires a filename');
    ***REMOVED***
    func = exports.cache.get(filename);
    if (func) ***REMOVED***
      return func;
    ***REMOVED***
    if (!hasTemplate) ***REMOVED***
      template = fileLoader(filename).toString().replace(_BOM, '');
    ***REMOVED***
  ***REMOVED***
  else if (!hasTemplate) ***REMOVED***
    // istanbul ignore if: should not happen at all
    if (!filename) ***REMOVED***
      throw new Error('Internal EJS error: no file name or template '
                    + 'provided');
    ***REMOVED***
    template = fileLoader(filename).toString().replace(_BOM, '');
  ***REMOVED***
  func = exports.compile(template, options);
  if (options.cache) ***REMOVED***
    exports.cache.set(filename, func);
  ***REMOVED***
  return func;
***REMOVED***

/**
 * Try calling handleCache with the given options and data and call the
 * callback with the result. If an error occurs, call the callback with
 * the error. Used by renderFile().
 *
 * @memberof module:ejs-internal
 * @param ***REMOVED***Options***REMOVED*** options    compilation options
 * @param ***REMOVED***Object***REMOVED*** data        template data
 * @param ***REMOVED***RenderFileCallback***REMOVED*** cb callback
 * @static
 */

function tryHandleCache(options, data, cb) ***REMOVED***
  var result;
  if (!cb) ***REMOVED***
    if (typeof exports.promiseImpl == 'function') ***REMOVED***
      return new exports.promiseImpl(function (resolve, reject) ***REMOVED***
        try ***REMOVED***
          result = handleCache(options)(data);
          resolve(result);
        ***REMOVED***
        catch (err) ***REMOVED***
          reject(err);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
    else ***REMOVED***
      throw new Error('Please provide a callback function');
    ***REMOVED***
  ***REMOVED***
  else ***REMOVED***
    try ***REMOVED***
      result = handleCache(options)(data);
    ***REMOVED***
    catch (err) ***REMOVED***
      return cb(err);
    ***REMOVED***

    cb(null, result);
  ***REMOVED***
***REMOVED***

/**
 * fileLoader is independent
 *
 * @param ***REMOVED***String***REMOVED*** filePath ejs file path.
 * @return ***REMOVED***String***REMOVED*** The contents of the specified file.
 * @static
 */

function fileLoader(filePath)***REMOVED***
  return exports.fileLoader(filePath);
***REMOVED***

/**
 * Get the template function.
 *
 * If `options.cache` is `true`, then the template is cached.
 *
 * @memberof module:ejs-internal
 * @param ***REMOVED***String***REMOVED***  path    path for the specified file
 * @param ***REMOVED***Options***REMOVED*** options compilation options
 * @return ***REMOVED***(TemplateFunction|ClientFunction)***REMOVED***
 * Depending on the value of `options.client`, either type might be returned
 * @static
 */

function includeFile(path, options) ***REMOVED***
  var opts = utils.shallowCopy(***REMOVED******REMOVED***, options);
  opts.filename = getIncludePath(path, opts);
  return handleCache(opts);
***REMOVED***

/**
 * Get the JavaScript source of an included file.
 *
 * @memberof module:ejs-internal
 * @param ***REMOVED***String***REMOVED***  path    path for the specified file
 * @param ***REMOVED***Options***REMOVED*** options compilation options
 * @return ***REMOVED***Object***REMOVED***
 * @static
 */

function includeSource(path, options) ***REMOVED***
  var opts = utils.shallowCopy(***REMOVED******REMOVED***, options);
  var includePath;
  var template;
  includePath = getIncludePath(path, opts);
  template = fileLoader(includePath).toString().replace(_BOM, '');
  opts.filename = includePath;
  var templ = new Template(template, opts);
  templ.generateSource();
  return ***REMOVED***
    source: templ.source,
    filename: includePath,
    template: template
  ***REMOVED***;
***REMOVED***

/**
 * Re-throw the given `err` in context to the `str` of ejs, `filename`, and
 * `lineno`.
 *
 * @implements RethrowCallback
 * @memberof module:ejs-internal
 * @param ***REMOVED***Error***REMOVED***  err      Error object
 * @param ***REMOVED***String***REMOVED*** str      EJS source
 * @param ***REMOVED***String***REMOVED*** filename file name of the EJS file
 * @param ***REMOVED***String***REMOVED*** lineno   line number of the error
 * @static
 */

function rethrow(err, str, flnm, lineno, esc)***REMOVED***
  var lines = str.split('\n');
  var start = Math.max(lineno - 3, 0);
  var end = Math.min(lines.length, lineno + 3);
  var filename = esc(flnm); // eslint-disable-line
  // Error context
  var context = lines.slice(start, end).map(function (line, i)***REMOVED***
    var curr = i + start + 1;
    return (curr == lineno ? ' >> ' : '    ')
      + curr
      + '| '
      + line;
  ***REMOVED***).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'ejs') + ':'
    + lineno + '\n'
    + context + '\n\n'
    + err.message;

  throw err;
***REMOVED***

function stripSemi(str)***REMOVED***
  return str.replace(/;(\s*$)/, '$1');
***REMOVED***

/**
 * Compile the given `str` of ejs into a template function.
 *
 * @param ***REMOVED***String***REMOVED***  template EJS template
 *
 * @param ***REMOVED***Options***REMOVED*** opts     compilation options
 *
 * @return ***REMOVED***(TemplateFunction|ClientFunction)***REMOVED***
 * Depending on the value of `opts.client`, either type might be returned.
 * Note that the return type of the function also depends on the value of `opts.async`.
 * @public
 */

exports.compile = function compile(template, opts) ***REMOVED***
  var templ;

  // v1 compat
  // 'scope' is 'context'
  // FIXME: Remove this in a future version
  if (opts && opts.scope) ***REMOVED***
    if (!scopeOptionWarned)***REMOVED***
      console.warn('`scope` option is deprecated and will be removed in EJS 3');
      scopeOptionWarned = true;
    ***REMOVED***
    if (!opts.context) ***REMOVED***
      opts.context = opts.scope;
    ***REMOVED***
    delete opts.scope;
  ***REMOVED***
  templ = new Template(template, opts);
  return templ.compile();
***REMOVED***;

/**
 * Render the given `template` of ejs.
 *
 * If you would like to include options but not data, you need to explicitly
 * call this function with `data` being an empty object or `null`.
 *
 * @param ***REMOVED***String***REMOVED***   template EJS template
 * @param ***REMOVED***Object***REMOVED***  [data=***REMOVED******REMOVED***] template data
 * @param ***REMOVED***Options***REMOVED*** [opts=***REMOVED******REMOVED***] compilation and rendering options
 * @return ***REMOVED***(String|Promise<String>)***REMOVED***
 * Return value type depends on `opts.async`.
 * @public
 */

exports.render = function (template, d, o) ***REMOVED***
  var data = d || ***REMOVED******REMOVED***;
  var opts = o || ***REMOVED******REMOVED***;

  // No options object -- if there are optiony names
  // in the data, copy them to options
  if (arguments.length == 2) ***REMOVED***
    utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
  ***REMOVED***

  return handleCache(opts, template)(data);
***REMOVED***;

/**
 * Render an EJS file at the given `path` and callback `cb(err, str)`.
 *
 * If you would like to include options but not data, you need to explicitly
 * call this function with `data` being an empty object or `null`.
 *
 * @param ***REMOVED***String***REMOVED***             path     path to the EJS file
 * @param ***REMOVED***Object***REMOVED***            [data=***REMOVED******REMOVED***] template data
 * @param ***REMOVED***Options***REMOVED***           [opts=***REMOVED******REMOVED***] compilation and rendering options
 * @param ***REMOVED***RenderFileCallback***REMOVED*** cb callback
 * @public
 */

exports.renderFile = function () ***REMOVED***
  var args = Array.prototype.slice.call(arguments);
  var filename = args.shift();
  var cb;
  var opts = ***REMOVED***filename: filename***REMOVED***;
  var data;
  var viewOpts;

  // Do we have a callback?
  if (typeof arguments[arguments.length - 1] == 'function') ***REMOVED***
    cb = args.pop();
  ***REMOVED***
  // Do we have data/opts?
  if (args.length) ***REMOVED***
    // Should always have data obj
    data = args.shift();
    // Normal passed opts (data obj + opts obj)
    if (args.length) ***REMOVED***
      // Use shallowCopy so we don't pollute passed in opts obj with new vals
      utils.shallowCopy(opts, args.pop());
    ***REMOVED***
    // Special casing for Express (settings + opts-in-data)
    else ***REMOVED***
      // Express 3 and 4
      if (data.settings) ***REMOVED***
        // Pull a few things from known locations
        if (data.settings.views) ***REMOVED***
          opts.views = data.settings.views;
        ***REMOVED***
        if (data.settings['view cache']) ***REMOVED***
          opts.cache = true;
        ***REMOVED***
        // Undocumented after Express 2, but still usable, esp. for
        // items that are unsafe to be passed along with data, like `root`
        viewOpts = data.settings['view options'];
        if (viewOpts) ***REMOVED***
          utils.shallowCopy(opts, viewOpts);
        ***REMOVED***
      ***REMOVED***
      // Express 2 and lower, values set in app.locals, or people who just
      // want to pass options in their data. NOTE: These values will override
      // anything previously set in settings  or settings['view options']
      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
    ***REMOVED***
    opts.filename = filename;
  ***REMOVED***
  else ***REMOVED***
    data = ***REMOVED******REMOVED***;
  ***REMOVED***

  return tryHandleCache(opts, data, cb);
***REMOVED***;

/**
 * Clear intermediate JavaScript cache. Calls ***REMOVED***@link Cache#reset***REMOVED***.
 * @public
 */

/**
 * EJS template class
 * @public
 */
exports.Template = Template;

exports.clearCache = function () ***REMOVED***
  exports.cache.reset();
***REMOVED***;

function Template(text, opts) ***REMOVED***
  opts = opts || ***REMOVED******REMOVED***;
  var options = ***REMOVED******REMOVED***;
  this.templateText = text;
  this.mode = null;
  this.truncate = false;
  this.currentLine = 1;
  this.source = '';
  this.dependencies = [];
  options.client = opts.client || false;
  options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
  options.compileDebug = opts.compileDebug !== false;
  options.debug = !!opts.debug;
  options.filename = opts.filename;
  options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;
  options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;
  options.strict = opts.strict || false;
  options.context = opts.context;
  options.cache = opts.cache || false;
  options.rmWhitespace = opts.rmWhitespace;
  options.root = opts.root;
  options.outputFunctionName = opts.outputFunctionName;
  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;
  options.views = opts.views;
  options.async = opts.async;

  if (options.strict) ***REMOVED***
    options._with = false;
  ***REMOVED***
  else ***REMOVED***
    options._with = typeof opts._with != 'undefined' ? opts._with : true;
  ***REMOVED***

  this.opts = options;

  this.regex = this.createRegex();
***REMOVED***

Template.modes = ***REMOVED***
  EVAL: 'eval',
  ESCAPED: 'escaped',
  RAW: 'raw',
  COMMENT: 'comment',
  LITERAL: 'literal'
***REMOVED***;

Template.prototype = ***REMOVED***
  createRegex: function () ***REMOVED***
    var str = _REGEX_STRING;
    var delim = utils.escapeRegExpChars(this.opts.delimiter);
    var open = utils.escapeRegExpChars(this.opts.openDelimiter);
    var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
    str = str.replace(/%/g, delim)
      .replace(/</g, open)
      .replace(/>/g, close);
    return new RegExp(str);
  ***REMOVED***,

  compile: function () ***REMOVED***
    var src;
    var fn;
    var opts = this.opts;
    var prepended = '';
    var appended = '';
    var escapeFn = opts.escapeFunction;
    var ctor;

    if (!this.source) ***REMOVED***
      this.generateSource();
      prepended += '  var __output = [], __append = __output.push.bind(__output);' + '\n';
      if (opts.outputFunctionName) ***REMOVED***
        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\n';
      ***REMOVED***
      if (opts._with !== false) ***REMOVED***
        prepended +=  '  with (' + opts.localsName + ' || ***REMOVED******REMOVED***) ***REMOVED***' + '\n';
        appended += '  ***REMOVED***' + '\n';
      ***REMOVED***
      appended += '  return __output.join("");' + '\n';
      this.source = prepended + this.source + appended;
    ***REMOVED***

    if (opts.compileDebug) ***REMOVED***
      src = 'var __line = 1' + '\n'
        + '  , __lines = ' + JSON.stringify(this.templateText) + '\n'
        + '  , __filename = ' + (opts.filename ?
        JSON.stringify(opts.filename) : 'undefined') + ';' + '\n'
        + 'try ***REMOVED***' + '\n'
        + this.source
        + '***REMOVED*** catch (e) ***REMOVED***' + '\n'
        + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\n'
        + '***REMOVED***' + '\n';
    ***REMOVED***
    else ***REMOVED***
      src = this.source;
    ***REMOVED***

    if (opts.client) ***REMOVED***
      src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\n' + src;
      if (opts.compileDebug) ***REMOVED***
        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\n' + src;
      ***REMOVED***
    ***REMOVED***

    if (opts.strict) ***REMOVED***
      src = '"use strict";\n' + src;
    ***REMOVED***
    if (opts.debug) ***REMOVED***
      console.log(src);
    ***REMOVED***

    try ***REMOVED***
      if (opts.async) ***REMOVED***
        // Have to use generated function for this, since in envs without support,
        // it breaks in parsing
        try ***REMOVED***
          ctor = (new Function('return (async function()***REMOVED******REMOVED***).constructor;'))();
        ***REMOVED***
        catch(e) ***REMOVED***
          if (e instanceof SyntaxError) ***REMOVED***
            throw new Error('This environment does not support async/await');
          ***REMOVED***
          else ***REMOVED***
            throw e;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      else ***REMOVED***
        ctor = Function;
      ***REMOVED***
      fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);
    ***REMOVED***
    catch(e) ***REMOVED***
      // istanbul ignore else
      if (e instanceof SyntaxError) ***REMOVED***
        if (opts.filename) ***REMOVED***
          e.message += ' in ' + opts.filename;
        ***REMOVED***
        e.message += ' while compiling ejs\n\n';
        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\n';
        e.message += 'https://github.com/RyanZim/EJS-Lint';
        if (!e.async) ***REMOVED***
          e.message += '\n';
          e.message += 'Or, if you meant to create an async function, pass async: true as an option.';
        ***REMOVED***
      ***REMOVED***
      throw e;
    ***REMOVED***

    if (opts.client) ***REMOVED***
      fn.dependencies = this.dependencies;
      return fn;
    ***REMOVED***

    // Return a callable function which will execute the function
    // created by the source-code, with the passed data as locals
    // Adds a local `include` function which allows full recursive include
    var returnedFn = function (data) ***REMOVED***
      var include = function (path, includeData) ***REMOVED***
        var d = utils.shallowCopy(***REMOVED******REMOVED***, data);
        if (includeData) ***REMOVED***
          d = utils.shallowCopy(d, includeData);
        ***REMOVED***
        return includeFile(path, opts)(d);
      ***REMOVED***;
      return fn.apply(opts.context, [data || ***REMOVED******REMOVED***, escapeFn, include, rethrow]);
    ***REMOVED***;
    returnedFn.dependencies = this.dependencies;
    return returnedFn;
  ***REMOVED***,

  generateSource: function () ***REMOVED***
    var opts = this.opts;

    if (opts.rmWhitespace) ***REMOVED***
      // Have to use two separate replace here as `^` and `$` operators don't
      // work well with `\r` and empty lines don't work well with the `m` flag.
      this.templateText =
        this.templateText.replace(/[\r\n]+/g, '\n').replace(/^\s+|\s+$/gm, '');
    ***REMOVED***

    // Slurp spaces and tabs before <%_ and after _%>
    this.templateText =
      this.templateText.replace(/[ \t]*<%_/gm, '<%_').replace(/_%>[ \t]*/gm, '_%>');

    var self = this;
    var matches = this.parseTemplateText();
    var d = this.opts.delimiter;
    var o = this.opts.openDelimiter;
    var c = this.opts.closeDelimiter;

    if (matches && matches.length) ***REMOVED***
      matches.forEach(function (line, index) ***REMOVED***
        var opening;
        var closing;
        var include;
        var includeOpts;
        var includeObj;
        var includeSrc;
        // If this is an opening tag, check for closing tags
        // FIXME: May end up with some false positives here
        // Better to store modes as k/v with openDelimiter + delimiter as key
        // Then this can simply check against the map
        if ( line.indexOf(o + d) === 0        // If it is a tag
          && line.indexOf(o + d + d) !== 0) ***REMOVED*** // and is not escaped
          closing = matches[index + 2];
          if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) ***REMOVED***
            throw new Error('Could not find matching close tag for "' + line + '".');
          ***REMOVED***
        ***REMOVED***
        // HACK: backward-compat `include` preprocessor directives
        if ((include = line.match(/^\s*include\s+(\S+)/))) ***REMOVED***
          opening = matches[index - 1];
          // Must be in EVAL or RAW mode
          if (opening && (opening == o + d || opening == o + d + '-' || opening == o + d + '_')) ***REMOVED***
            includeOpts = utils.shallowCopy(***REMOVED******REMOVED***, self.opts);
            includeObj = includeSource(include[1], includeOpts);
            if (self.opts.compileDebug) ***REMOVED***
              includeSrc =
                  '    ; (function()***REMOVED***' + '\n'
                  + '      var __line = 1' + '\n'
                  + '      , __lines = ' + JSON.stringify(includeObj.template) + '\n'
                  + '      , __filename = ' + JSON.stringify(includeObj.filename) + ';' + '\n'
                  + '      try ***REMOVED***' + '\n'
                  + includeObj.source
                  + '      ***REMOVED*** catch (e) ***REMOVED***' + '\n'
                  + '        rethrow(e, __lines, __filename, __line, escapeFn);' + '\n'
                  + '      ***REMOVED***' + '\n'
                  + '    ; ***REMOVED***).call(this)' + '\n';
            ***REMOVED***else***REMOVED***
              includeSrc = '    ; (function()***REMOVED***' + '\n' + includeObj.source +
                  '    ; ***REMOVED***).call(this)' + '\n';
            ***REMOVED***
            self.source += includeSrc;
            self.dependencies.push(exports.resolveInclude(include[1],
              includeOpts.filename));
            return;
          ***REMOVED***
        ***REMOVED***
        self.scanLine(line);
      ***REMOVED***);
    ***REMOVED***

  ***REMOVED***,

  parseTemplateText: function () ***REMOVED***
    var str = this.templateText;
    var pat = this.regex;
    var result = pat.exec(str);
    var arr = [];
    var firstPos;

    while (result) ***REMOVED***
      firstPos = result.index;

      if (firstPos !== 0) ***REMOVED***
        arr.push(str.substring(0, firstPos));
        str = str.slice(firstPos);
      ***REMOVED***

      arr.push(result[0]);
      str = str.slice(result[0].length);
      result = pat.exec(str);
    ***REMOVED***

    if (str) ***REMOVED***
      arr.push(str);
    ***REMOVED***

    return arr;
  ***REMOVED***,

  _addOutput: function (line) ***REMOVED***
    if (this.truncate) ***REMOVED***
      // Only replace single leading linebreak in the line after
      // -%> tag -- this is the single, trailing linebreak
      // after the tag that the truncation mode replaces
      // Handle Win / Unix / old Mac linebreaks -- do the \r\n
      // combo first in the regex-or
      line = line.replace(/^(?:\r\n|\r|\n)/, '');
      this.truncate = false;
    ***REMOVED***
    if (!line) ***REMOVED***
      return line;
    ***REMOVED***

    // Preserve literal slashes
    line = line.replace(/\\/g, '\\\\');

    // Convert linebreaks
    line = line.replace(/\n/g, '\\n');
    line = line.replace(/\r/g, '\\r');

    // Escape double-quotes
    // - this will be the delimiter during execution
    line = line.replace(/"/g, '\\"');
    this.source += '    ; __append("' + line + '")' + '\n';
  ***REMOVED***,

  scanLine: function (line) ***REMOVED***
    var self = this;
    var d = this.opts.delimiter;
    var o = this.opts.openDelimiter;
    var c = this.opts.closeDelimiter;
    var newLineCount = 0;

    newLineCount = (line.split('\n').length - 1);

    switch (line) ***REMOVED***
    case o + d:
    case o + d + '_':
      this.mode = Template.modes.EVAL;
      break;
    case o + d + '=':
      this.mode = Template.modes.ESCAPED;
      break;
    case o + d + '-':
      this.mode = Template.modes.RAW;
      break;
    case o + d + '#':
      this.mode = Template.modes.COMMENT;
      break;
    case o + d + d:
      this.mode = Template.modes.LITERAL;
      this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")' + '\n';
      break;
    case d + d + c:
      this.mode = Template.modes.LITERAL;
      this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")' + '\n';
      break;
    case d + c:
    case '-' + d + c:
    case '_' + d + c:
      if (this.mode == Template.modes.LITERAL) ***REMOVED***
        this._addOutput(line);
      ***REMOVED***

      this.mode = null;
      this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;
      break;
    default:
      // In script mode, depends on type of tag
      if (this.mode) ***REMOVED***
        // If '//' is found without a line break, add a line break.
        switch (this.mode) ***REMOVED***
        case Template.modes.EVAL:
        case Template.modes.ESCAPED:
        case Template.modes.RAW:
          if (line.lastIndexOf('//') > line.lastIndexOf('\n')) ***REMOVED***
            line += '\n';
          ***REMOVED***
        ***REMOVED***
        switch (this.mode) ***REMOVED***
        // Just executing code
        case Template.modes.EVAL:
          this.source += '    ; ' + line + '\n';
          break;
          // Exec, esc, and output
        case Template.modes.ESCAPED:
          this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\n';
          break;
          // Exec and output
        case Template.modes.RAW:
          this.source += '    ; __append(' + stripSemi(line) + ')' + '\n';
          break;
        case Template.modes.COMMENT:
          // Do nothing
          break;
          // Literal <%% mode, append as raw output
        case Template.modes.LITERAL:
          this._addOutput(line);
          break;
        ***REMOVED***
      ***REMOVED***
      // In string mode, just add the output
      else ***REMOVED***
        this._addOutput(line);
      ***REMOVED***
    ***REMOVED***

    if (self.opts.compileDebug && newLineCount) ***REMOVED***
      this.currentLine += newLineCount;
      this.source += '    ; __line = ' + this.currentLine + '\n';
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Escape characters reserved in XML.
 *
 * This is simply an export of ***REMOVED***@link module:utils.escapeXML***REMOVED***.
 *
 * If `markup` is `undefined` or `null`, the empty string is returned.
 *
 * @param ***REMOVED***String***REMOVED*** markup Input string
 * @return ***REMOVED***String***REMOVED*** Escaped string
 * @public
 * @func
 * */
exports.escapeXML = utils.escapeXML;

/**
 * Express.js support.
 *
 * This is an alias for ***REMOVED***@link module:ejs.renderFile***REMOVED***, in order to support
 * Express.js out-of-the-box.
 *
 * @func
 */

exports.__express = exports.renderFile;

// Add require support
/* istanbul ignore else */
if (require.extensions) ***REMOVED***
  require.extensions['.ejs'] = function (module, flnm) ***REMOVED***
    var filename = flnm || /* istanbul ignore next */ module.filename;
    var options = ***REMOVED***
      filename: filename,
      client: true
    ***REMOVED***;
    var template = fileLoader(filename).toString();
    var fn = exports.compile(template, options);
    module._compile('module.exports = ' + fn.toString() + ';', filename);
  ***REMOVED***;
***REMOVED***

/**
 * Version of EJS.
 *
 * @readonly
 * @type ***REMOVED***String***REMOVED***
 * @public
 */

exports.VERSION = _VERSION_STRING;

/**
 * Name for detection of EJS.
 *
 * @readonly
 * @type ***REMOVED***String***REMOVED***
 * @public
 */

exports.name = _NAME;

/* istanbul ignore if */
if (typeof window != 'undefined') ***REMOVED***
  window.ejs = exports;
***REMOVED***

***REMOVED***,***REMOVED***"../package.json":6,"./utils":2,"fs":3,"path":4***REMOVED***],2:[function(require,module,exports)***REMOVED***
/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

/**
 * Private utility functions
 * @module utils
 * @private
 */

'use strict';

var regExpChars = /[|\\***REMOVED******REMOVED***()[\]^$+*?.]/g;

/**
 * Escape characters reserved in regular expressions.
 *
 * If `string` is `undefined` or `null`, the empty string is returned.
 *
 * @param ***REMOVED***String***REMOVED*** string Input string
 * @return ***REMOVED***String***REMOVED*** Escaped string
 * @static
 * @private
 */
exports.escapeRegExpChars = function (string) ***REMOVED***
  // istanbul ignore if
  if (!string) ***REMOVED***
    return '';
  ***REMOVED***
  return String(string).replace(regExpChars, '\\$&');
***REMOVED***;

var _ENCODE_HTML_RULES = ***REMOVED***
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&#34;',
  "'": '&#39;'
***REMOVED***;
var _MATCH_HTML = /[&<>'"]/g;

function encode_char(c) ***REMOVED***
  return _ENCODE_HTML_RULES[c] || c;
***REMOVED***

/**
 * Stringified version of constants used by ***REMOVED***@link module:utils.escapeXML***REMOVED***.
 *
 * It is used in the process of generating ***REMOVED***@link ClientFunction***REMOVED***s.
 *
 * @readonly
 * @type ***REMOVED***String***REMOVED***
 */

var escapeFuncStr =
  'var _ENCODE_HTML_RULES = ***REMOVED***\n'
+ '      "&": "&amp;"\n'
+ '    , "<": "&lt;"\n'
+ '    , ">": "&gt;"\n'
+ '    , \'"\': "&#34;"\n'
+ '    , "\'": "&#39;"\n'
+ '    ***REMOVED***\n'
+ '  , _MATCH_HTML = /[&<>\'"]/g;\n'
+ 'function encode_char(c) ***REMOVED***\n'
+ '  return _ENCODE_HTML_RULES[c] || c;\n'
+ '***REMOVED***;\n';

/**
 * Escape characters reserved in XML.
 *
 * If `markup` is `undefined` or `null`, the empty string is returned.
 *
 * @implements ***REMOVED***EscapeCallback***REMOVED***
 * @param ***REMOVED***String***REMOVED*** markup Input string
 * @return ***REMOVED***String***REMOVED*** Escaped string
 * @static
 * @private
 */

exports.escapeXML = function (markup) ***REMOVED***
  return markup == undefined
    ? ''
    : String(markup)
      .replace(_MATCH_HTML, encode_char);
***REMOVED***;
exports.escapeXML.toString = function () ***REMOVED***
  return Function.prototype.toString.call(this) + ';\n' + escapeFuncStr;
***REMOVED***;

/**
 * Naive copy of properties from one object to another.
 * Does not recurse into non-scalar properties
 * Does not check to see if the property has a value before copying
 *
 * @param  ***REMOVED***Object***REMOVED*** to   Destination object
 * @param  ***REMOVED***Object***REMOVED*** from Source object
 * @return ***REMOVED***Object***REMOVED***      Destination object
 * @static
 * @private
 */
exports.shallowCopy = function (to, from) ***REMOVED***
  from = from || ***REMOVED******REMOVED***;
  for (var p in from) ***REMOVED***
    to[p] = from[p];
  ***REMOVED***
  return to;
***REMOVED***;

/**
 * Naive copy of a list of key names, from one object to another.
 * Only copies property if it is actually defined
 * Does not recurse into non-scalar properties
 *
 * @param  ***REMOVED***Object***REMOVED*** to   Destination object
 * @param  ***REMOVED***Object***REMOVED*** from Source object
 * @param  ***REMOVED***Array***REMOVED*** list List of properties to copy
 * @return ***REMOVED***Object***REMOVED***      Destination object
 * @static
 * @private
 */
exports.shallowCopyFromList = function (to, from, list) ***REMOVED***
  for (var i = 0; i < list.length; i++) ***REMOVED***
    var p = list[i];
    if (typeof from[p] != 'undefined') ***REMOVED***
      to[p] = from[p];
    ***REMOVED***
  ***REMOVED***
  return to;
***REMOVED***;

/**
 * Simple in-process cache implementation. Does not implement limits of any
 * sort.
 *
 * @implements Cache
 * @static
 * @private
 */
exports.cache = ***REMOVED***
  _data: ***REMOVED******REMOVED***,
  set: function (key, val) ***REMOVED***
    this._data[key] = val;
  ***REMOVED***,
  get: function (key) ***REMOVED***
    return this._data[key];
  ***REMOVED***,
  remove: function (key) ***REMOVED***
    delete this._data[key];
  ***REMOVED***,
  reset: function () ***REMOVED***
    this._data = ***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],3:[function(require,module,exports)***REMOVED***

***REMOVED***,***REMOVED******REMOVED***],4:[function(require,module,exports)***REMOVED***
(function (process)***REMOVED***
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) ***REMOVED***
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) ***REMOVED***
    var last = parts[i];
    if (last === '.') ***REMOVED***
      parts.splice(i, 1);
    ***REMOVED*** else if (last === '..') ***REMOVED***
      parts.splice(i, 1);
      up++;
    ***REMOVED*** else if (up) ***REMOVED***
      parts.splice(i, 1);
      up--;
    ***REMOVED***
  ***REMOVED***

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) ***REMOVED***
    for (; up--; up) ***REMOVED***
      parts.unshift('..');
    ***REMOVED***
  ***REMOVED***

  return parts;
***REMOVED***

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.***REMOVED***1,2***REMOVED***|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) ***REMOVED***
  return splitPathRe.exec(filename).slice(1);
***REMOVED***;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() ***REMOVED***
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) ***REMOVED***
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') ***REMOVED***
      throw new TypeError('Arguments to path.resolve must be strings');
    ***REMOVED*** else if (!path) ***REMOVED***
      continue;
    ***REMOVED***

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  ***REMOVED***

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) ***REMOVED***
    return !!p;
  ***REMOVED***), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
***REMOVED***;

// path.normalize(path)
// posix version
exports.normalize = function(path) ***REMOVED***
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) ***REMOVED***
    return !!p;
  ***REMOVED***), !isAbsolute).join('/');

  if (!path && !isAbsolute) ***REMOVED***
    path = '.';
  ***REMOVED***
  if (path && trailingSlash) ***REMOVED***
    path += '/';
  ***REMOVED***

  return (isAbsolute ? '/' : '') + path;
***REMOVED***;

// posix version
exports.isAbsolute = function(path) ***REMOVED***
  return path.charAt(0) === '/';
***REMOVED***;

// posix version
exports.join = function() ***REMOVED***
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) ***REMOVED***
    if (typeof p !== 'string') ***REMOVED***
      throw new TypeError('Arguments to path.join must be strings');
    ***REMOVED***
    return p;
  ***REMOVED***).join('/'));
***REMOVED***;


// path.relative(from, to)
// posix version
exports.relative = function(from, to) ***REMOVED***
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) ***REMOVED***
    var start = 0;
    for (; start < arr.length; start++) ***REMOVED***
      if (arr[start] !== '') break;
    ***REMOVED***

    var end = arr.length - 1;
    for (; end >= 0; end--) ***REMOVED***
      if (arr[end] !== '') break;
    ***REMOVED***

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  ***REMOVED***

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) ***REMOVED***
    if (fromParts[i] !== toParts[i]) ***REMOVED***
      samePartsLength = i;
      break;
    ***REMOVED***
  ***REMOVED***

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) ***REMOVED***
    outputParts.push('..');
  ***REMOVED***

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
***REMOVED***;

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) ***REMOVED***
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) ***REMOVED***
    // No dirname whatsoever
    return '.';
  ***REMOVED***

  if (dir) ***REMOVED***
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  ***REMOVED***

  return root + dir;
***REMOVED***;


exports.basename = function(path, ext) ***REMOVED***
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) ***REMOVED***
    f = f.substr(0, f.length - ext.length);
  ***REMOVED***
  return f;
***REMOVED***;


exports.extname = function(path) ***REMOVED***
  return splitPath(path)[3];
***REMOVED***;

function filter (xs, f) ***REMOVED***
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) ***REMOVED***
        if (f(xs[i], i, xs)) res.push(xs[i]);
    ***REMOVED***
    return res;
***REMOVED***

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) ***REMOVED*** return str.substr(start, len) ***REMOVED***
    : function (str, start, len) ***REMOVED***
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    ***REMOVED***
;

***REMOVED***).call(this,require('_process'))
***REMOVED***,***REMOVED***"_process":5***REMOVED***],5:[function(require,module,exports)***REMOVED***
// shim for using process in browser
var process = module.exports = ***REMOVED******REMOVED***;

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() ***REMOVED***
    throw new Error('setTimeout has not been defined');
***REMOVED***
function defaultClearTimeout () ***REMOVED***
    throw new Error('clearTimeout has not been defined');
***REMOVED***
(function () ***REMOVED***
    try ***REMOVED***
        if (typeof setTimeout === 'function') ***REMOVED***
            cachedSetTimeout = setTimeout;
        ***REMOVED*** else ***REMOVED***
            cachedSetTimeout = defaultSetTimout;
        ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
        cachedSetTimeout = defaultSetTimout;
    ***REMOVED***
    try ***REMOVED***
        if (typeof clearTimeout === 'function') ***REMOVED***
            cachedClearTimeout = clearTimeout;
        ***REMOVED*** else ***REMOVED***
            cachedClearTimeout = defaultClearTimeout;
        ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
        cachedClearTimeout = defaultClearTimeout;
    ***REMOVED***
***REMOVED*** ())
function runTimeout(fun) ***REMOVED***
    if (cachedSetTimeout === setTimeout) ***REMOVED***
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    ***REMOVED***
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) ***REMOVED***
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    ***REMOVED***
    try ***REMOVED***
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    ***REMOVED*** catch(e)***REMOVED***
        try ***REMOVED***
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        ***REMOVED*** catch(e)***REMOVED***
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        ***REMOVED***
    ***REMOVED***


***REMOVED***
function runClearTimeout(marker) ***REMOVED***
    if (cachedClearTimeout === clearTimeout) ***REMOVED***
        //normal enviroments in sane situations
        return clearTimeout(marker);
    ***REMOVED***
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) ***REMOVED***
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    ***REMOVED***
    try ***REMOVED***
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    ***REMOVED*** catch (e)***REMOVED***
        try ***REMOVED***
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        ***REMOVED*** catch (e)***REMOVED***
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        ***REMOVED***
    ***REMOVED***



***REMOVED***
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() ***REMOVED***
    if (!draining || !currentQueue) ***REMOVED***
        return;
    ***REMOVED***
    draining = false;
    if (currentQueue.length) ***REMOVED***
        queue = currentQueue.concat(queue);
    ***REMOVED*** else ***REMOVED***
        queueIndex = -1;
    ***REMOVED***
    if (queue.length) ***REMOVED***
        drainQueue();
    ***REMOVED***
***REMOVED***

function drainQueue() ***REMOVED***
    if (draining) ***REMOVED***
        return;
    ***REMOVED***
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) ***REMOVED***
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) ***REMOVED***
            if (currentQueue) ***REMOVED***
                currentQueue[queueIndex].run();
            ***REMOVED***
        ***REMOVED***
        queueIndex = -1;
        len = queue.length;
    ***REMOVED***
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
***REMOVED***

process.nextTick = function (fun) ***REMOVED***
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) ***REMOVED***
        for (var i = 1; i < arguments.length; i++) ***REMOVED***
            args[i - 1] = arguments[i];
        ***REMOVED***
    ***REMOVED***
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) ***REMOVED***
        runTimeout(drainQueue);
    ***REMOVED***
***REMOVED***;

// v8 likes predictible objects
function Item(fun, array) ***REMOVED***
    this.fun = fun;
    this.array = array;
***REMOVED***
Item.prototype.run = function () ***REMOVED***
    this.fun.apply(null, this.array);
***REMOVED***;
process.title = 'browser';
process.browser = true;
process.env = ***REMOVED******REMOVED***;
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = ***REMOVED******REMOVED***;

function noop() ***REMOVED******REMOVED***

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) ***REMOVED*** return [] ***REMOVED***

process.binding = function (name) ***REMOVED***
    throw new Error('process.binding is not supported');
***REMOVED***;

process.cwd = function () ***REMOVED*** return '/' ***REMOVED***;
process.chdir = function (dir) ***REMOVED***
    throw new Error('process.chdir is not supported');
***REMOVED***;
process.umask = function() ***REMOVED*** return 0; ***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],6:[function(require,module,exports)***REMOVED***
module.exports=***REMOVED***
  "name": "ejs",
  "description": "Embedded JavaScript templates",
  "keywords": [
    "template",
    "engine",
    "ejs"
  ],
  "version": "2.6.1",
  "author": "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)",
  "contributors": [
    "Timothy Gu <timothygu99@gmail.com> (https://timothygu.github.io)"
  ],
  "license": "Apache-2.0",
  "main": "./lib/ejs.js",
  "repository": ***REMOVED***
    "type": "git",
    "url": "git://github.com/mde/ejs.git"
  ***REMOVED***,
  "bugs": "https://github.com/mde/ejs/issues",
  "homepage": "https://github.com/mde/ejs",
  "dependencies": ***REMOVED******REMOVED***,
  "devDependencies": ***REMOVED***
    "browserify": "^13.1.1",
    "eslint": "^4.14.0",
    "git-directory-deploy": "^1.5.1",
    "istanbul": "~0.4.3",
    "jake": "^8.0.16",
    "jsdoc": "^3.4.0",
    "lru-cache": "^4.0.1",
    "mocha": "^5.0.5",
    "uglify-js": "^3.3.16"
  ***REMOVED***,
  "engines": ***REMOVED***
    "node": ">=0.10.0"
  ***REMOVED***,
  "scripts": ***REMOVED***
    "test": "jake test",
    "lint": "eslint \"**/*.js\" Jakefile",
    "coverage": "istanbul cover node_modules/mocha/bin/_mocha",
    "doc": "jake doc",
    "devdoc": "jake doc[dev]"
  ***REMOVED***
***REMOVED***

***REMOVED***,***REMOVED******REMOVED***]***REMOVED***,***REMOVED******REMOVED***,[1])(1)
***REMOVED***);
