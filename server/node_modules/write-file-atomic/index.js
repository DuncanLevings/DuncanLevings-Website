'use strict'
module.exports = writeFile
module.exports.sync = writeFileSync
module.exports._getTmpname = getTmpname // for testing
module.exports._cleanupOnExit = cleanupOnExit

const fs = require('fs')
const MurmurHash3 = require('imurmurhash')
const onExit = require('signal-exit')
const path = require('path')
const isTypedArray = require('is-typedarray')
const typedArrayToBuffer = require('typedarray-to-buffer')
const ***REMOVED*** promisify ***REMOVED*** = require('util')
const activeFiles = ***REMOVED******REMOVED***

// if we run inside of a worker_thread, `process.pid` is not unique
/* istanbul ignore next */
const threadId = (function getId () ***REMOVED***
  try ***REMOVED***
    const workerThreads = require('worker_threads')

    /// if we are in main thread, this is set to `0`
    return workerThreads.threadId
  ***REMOVED*** catch (e) ***REMOVED***
    // worker_threads are not available, fallback to 0
    return 0
  ***REMOVED***
***REMOVED***)()

let invocations = 0
function getTmpname (filename) ***REMOVED***
  return filename + '.' +
    MurmurHash3(__filename)
      .hash(String(process.pid))
      .hash(String(threadId))
      .hash(String(++invocations))
      .result()
***REMOVED***

function cleanupOnExit (tmpfile) ***REMOVED***
  return () => ***REMOVED***
    try ***REMOVED***
      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)
    ***REMOVED*** catch (_) ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***

function serializeActiveFile (absoluteName) ***REMOVED***
  return new Promise(resolve => ***REMOVED***
    // make a queue if it doesn't already exist
    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = []

    activeFiles[absoluteName].push(resolve) // add this job to the queue
    if (activeFiles[absoluteName].length === 1) resolve() // kick off the first one
  ***REMOVED***)
***REMOVED***

// https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342
function isChownErrOk (err) ***REMOVED***
  if (err.code === 'ENOSYS') ***REMOVED***
    return true
  ***REMOVED***

  const nonroot = !process.getuid || process.getuid() !== 0
  if (nonroot) ***REMOVED***
    if (err.code === 'EINVAL' || err.code === 'EPERM') ***REMOVED***
      return true
    ***REMOVED***
  ***REMOVED***

  return false
***REMOVED***

async function writeFileAsync (filename, data, options = ***REMOVED******REMOVED***) ***REMOVED***
  if (typeof options === 'string') ***REMOVED***
    options = ***REMOVED*** encoding: options ***REMOVED***
  ***REMOVED***

  let fd
  let tmpfile
  /* istanbul ignore next -- The closure only gets called when onExit triggers */
  const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))
  const absoluteName = path.resolve(filename)

  try ***REMOVED***
    await serializeActiveFile(absoluteName)
    const truename = await promisify(fs.realpath)(filename).catch(() => filename)
    tmpfile = getTmpname(truename)

    if (!options.mode || !options.chown) ***REMOVED***
      // Either mode or chown is not explicitly set
      // Default behavior is to copy it from original file
      const stats = await promisify(fs.stat)(truename).catch(() => ***REMOVED******REMOVED***)
      if (stats) ***REMOVED***
        if (options.mode == null) ***REMOVED***
          options.mode = stats.mode
        ***REMOVED***

        if (options.chown == null && process.getuid) ***REMOVED***
          options.chown = ***REMOVED*** uid: stats.uid, gid: stats.gid ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    fd = await promisify(fs.open)(tmpfile, 'w', options.mode)
    if (options.tmpfileCreated) ***REMOVED***
      await options.tmpfileCreated(tmpfile)
    ***REMOVED***
    if (isTypedArray(data)) ***REMOVED***
      data = typedArrayToBuffer(data)
    ***REMOVED***
    if (Buffer.isBuffer(data)) ***REMOVED***
      await promisify(fs.write)(fd, data, 0, data.length, 0)
    ***REMOVED*** else if (data != null) ***REMOVED***
      await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'))
    ***REMOVED***

    if (options.fsync !== false) ***REMOVED***
      await promisify(fs.fsync)(fd)
    ***REMOVED***

    await promisify(fs.close)(fd)
    fd = null

    if (options.chown) ***REMOVED***
      await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch(err => ***REMOVED***
        if (!isChownErrOk(err)) ***REMOVED***
          throw err
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED***

    if (options.mode) ***REMOVED***
      await promisify(fs.chmod)(tmpfile, options.mode).catch(err => ***REMOVED***
        if (!isChownErrOk(err)) ***REMOVED***
          throw err
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED***

    await promisify(fs.rename)(tmpfile, truename)
  ***REMOVED*** finally ***REMOVED***
    if (fd) ***REMOVED***
      await promisify(fs.close)(fd).catch(
        /* istanbul ignore next */
        () => ***REMOVED******REMOVED***
      )
    ***REMOVED***
    removeOnExitHandler()
    await promisify(fs.unlink)(tmpfile).catch(() => ***REMOVED******REMOVED***)
    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile
    if (activeFiles[absoluteName].length > 0) ***REMOVED***
      activeFiles[absoluteName][0]() // start next job if one is pending
    ***REMOVED*** else delete activeFiles[absoluteName]
  ***REMOVED***
***REMOVED***

function writeFile (filename, data, options, callback) ***REMOVED***
  if (options instanceof Function) ***REMOVED***
    callback = options
    options = ***REMOVED******REMOVED***
  ***REMOVED***

  const promise = writeFileAsync(filename, data, options)
  if (callback) ***REMOVED***
    promise.then(callback, callback)
  ***REMOVED***

  return promise
***REMOVED***

function writeFileSync (filename, data, options) ***REMOVED***
  if (typeof options === 'string') options = ***REMOVED*** encoding: options ***REMOVED***
  else if (!options) options = ***REMOVED******REMOVED***
  try ***REMOVED***
    filename = fs.realpathSync(filename)
  ***REMOVED*** catch (ex) ***REMOVED***
    // it's ok, it'll happen on a not yet existing file
  ***REMOVED***
  const tmpfile = getTmpname(filename)

  if (!options.mode || !options.chown) ***REMOVED***
    // Either mode or chown is not explicitly set
    // Default behavior is to copy it from original file
    try ***REMOVED***
      const stats = fs.statSync(filename)
      options = Object.assign(***REMOVED******REMOVED***, options)
      if (!options.mode) ***REMOVED***
        options.mode = stats.mode
      ***REMOVED***
      if (!options.chown && process.getuid) ***REMOVED***
        options.chown = ***REMOVED*** uid: stats.uid, gid: stats.gid ***REMOVED***
      ***REMOVED***
    ***REMOVED*** catch (ex) ***REMOVED***
      // ignore stat errors
    ***REMOVED***
  ***REMOVED***

  let fd
  const cleanup = cleanupOnExit(tmpfile)
  const removeOnExitHandler = onExit(cleanup)

  let threw = true
  try ***REMOVED***
    fd = fs.openSync(tmpfile, 'w', options.mode || 0o666)
    if (options.tmpfileCreated) ***REMOVED***
      options.tmpfileCreated(tmpfile)
    ***REMOVED***
    if (isTypedArray(data)) ***REMOVED***
      data = typedArrayToBuffer(data)
    ***REMOVED***
    if (Buffer.isBuffer(data)) ***REMOVED***
      fs.writeSync(fd, data, 0, data.length, 0)
    ***REMOVED*** else if (data != null) ***REMOVED***
      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))
    ***REMOVED***
    if (options.fsync !== false) ***REMOVED***
      fs.fsyncSync(fd)
    ***REMOVED***

    fs.closeSync(fd)
    fd = null

    if (options.chown) ***REMOVED***
      try ***REMOVED***
        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)
      ***REMOVED*** catch (err) ***REMOVED***
        if (!isChownErrOk(err)) ***REMOVED***
          throw err
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (options.mode) ***REMOVED***
      try ***REMOVED***
        fs.chmodSync(tmpfile, options.mode)
      ***REMOVED*** catch (err) ***REMOVED***
        if (!isChownErrOk(err)) ***REMOVED***
          throw err
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    fs.renameSync(tmpfile, filename)
    threw = false
  ***REMOVED*** finally ***REMOVED***
    if (fd) ***REMOVED***
      try ***REMOVED***
        fs.closeSync(fd)
      ***REMOVED*** catch (ex) ***REMOVED***
        // ignore close errors at this stage, error may have closed fd already.
      ***REMOVED***
    ***REMOVED***
    removeOnExitHandler()
    if (threw) ***REMOVED***
      cleanup()
    ***REMOVED***
  ***REMOVED***
***REMOVED***
